<?xml version="1.0"?>
<doc>
    <assembly>
        "IrrlichtLime"
    </assembly>
    <members>
        <member name="P:IrrlichtLime.Video.Material.Layer">
            <summary>
Texture layers.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Transparent">
            <summary>
Is this a transparent meterial.
Takes into account material type, blend operation and blend factor.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Mipmaps">
            <summary>
Shall mipmaps be used if available?
Sometimes, disabling mipmap usage can be useful.
Default is true.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.NormalizeNormals">
            <summary>
Should normals be normalized?
Always use this if the mesh lit and scaled.
Default is false.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Fog">
            <summary>
Is fog enabled?
Default is false.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.FrontfaceCulling">
            <summary>
Is frontface culling enabled?
Default is false.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.BackfaceCulling">
            <summary>
Is backface culling enabled?
Default is true.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.ZWriteFineControl">
            <summary>
Give more control how the <c>ZWrite</c> is interpreted.
Default is false.
When set to true: writing will just be based on <c>ZBuffer</c>, transparency is ignored.
When set to false: only write zbuffer when When <c>ZBuffer</c> is true and <c>Transparent</c> is false.
<para>Note that there is also the global flag <c>SceneParameters.AllowZWriteOnTransparent</c> which when set
acts like all materials have set this value to <c>true</c>.</para></summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.ZWrite">
            <summary>
Is the zbuffer writable or is it read-only.
Default is true.
This flag is forced to false if the Type is a transparent material type and the <c>SceneParameters.AllowZWriteOnTransparent</c> is not set.
If you set this parameter to true, make sure that <c>ZBuffer</c> value is other than <see cref="F:IrrlichtLime.Video.ComparisonFunc.Disabled" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Lighting">
            <summary>
Will this material be lighted?
Default is true.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.GouraudShading">
            <summary>
Flat or Gouraud shading?
Default is true.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.PointCloud">
            <summary>
Draw as point cloud or filled triangles?
Default is false.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Wireframe">
            <summary>
Draw as wireframe or filled triangles?
Default is false.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.PolygonOffsetSlopeScale">
            <summary>
Variable z-buffer offset based on the slope of the polygon.
For polygons looking flat at a camera you could use 0 (for example in a 2D game).
But in most cases you will have polygons rendered at a certain slope.
The driver will calculate the slope for you and this value allows to scale that slope.
The complete polygon offset is: PolygonOffsetSlopeScale * slope + PolygonOffsetDepthBias.
A good default here is to use 1.f if you want to push the polygons away from the camera and -1.f to pull them towards the camera.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.PolygonOffsetDepthBias">
            <summary>
A constant z-buffer offset for a polygon/line/point.
The range of the value is driver specific.
On OpenGL you get units which are multiplied by the smallest value that is guaranteed to produce a resolvable offset.
On D3D9 you can pass a range between -1 and 1. But you should likely divide it by the range of the depthbuffer.
Like dividing by 65535.0 for a 16 bit depthbuffer. Thought it still might produce too large of a bias.
Some article (https://aras-p.info/blog/2008/06/12/depth-bias-and-the-power-of-deceiving-yourself/)
recommends multiplying by 2.0*4.8e-7 (and strangely on both 16 bit and 24 bit).
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.ColorMaterial">
            <summary>
Defines the interpretation of vertex color in the lighting equation.
When lighting is enabled, vertex color can be used instead of the material values for light modulation.
This allows to easily change e.g. the diffuse light behavior of each face.
The default, <see cref="F:IrrlichtLime.Video.ColorMaterial.Diffuse" />, will result in a very similar rendering as with lighting turned off, just with light shading.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.ColorMask">
            <summary>
Defines the enabled color planes.
Only enabled color planes will be rendered to the current render target.
Typical use is to disable all colors when rendering only to depth or stencil buffer, or using Red and Green for stereo rendering.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.AntiAliasing">
            <summary>
The antialiasing mode.
Default is <see cref="F:IrrlichtLime.Video.AntiAliasingMode.Simple" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.ZBuffer">
            <summary>
Is the ZBuffer enabled?
Default is <see cref="F:IrrlichtLime.Video.ComparisonFunc.LessEqual" />.
If you want to disable depth test for this material just set this parameter to <see cref="F:IrrlichtLime.Video.ComparisonFunc.Disabled" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Thickness">
            <summary>
Thickness of non-3dimensional elements such as lines and points.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.MaterialTypeParam2">
            <summary>
Second free parameter, dependent on the material type.
Mostly ignored.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.MaterialTypeParam">
            <summary>
Free parameter, dependent on the material type.
Mostly ignored, used for example in <see cref="F:IrrlichtLime.Video.MaterialType.ParallaxMapSolid" /> and <see cref="F:IrrlichtLime.Video.MaterialType.TransparentAlphaChannel" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Shininess">
            <summary>
Value affecting the size of specular highlights.
<para>A value of 20 is common. If set to 0, no specular highlights are being used.
To activate, simply set the shininess of a material to a value in the range [0.5,128].
You can change the color of the highlights using <c>SpecularColor</c>.</para><para>The specular color of the dynamic lights (<c>Light.SpecularColor</c>) will influence the the highlight color too,
but they are set to a useful value by default when creating the light scene node.</para></summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.SpecularColor">
            <summary>
How much specular light (highlights from a light) is reflected.
The default is to reflect white specular light.
See <c>Shininess</c> on how to enable specular lights.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.EmissiveColor">
            <summary>
Light emitted by this material.
Default is to emit no light.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.DiffuseColor">
            <summary>
How much diffuse light coming from a light source is reflected by this material.
The default is full white.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.BlendOperation">
            <summary>
The blend operation of choice.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.AmbientColor">
            <summary>
How much ambient light (a global light) is reflected by this material.
The default is full white, meaning objects are completely globally illuminated.
Reduce this if you want to see diffuse or specular light effects.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Type">
            <summary>
Type of the material.
Specifies how everything is blended together.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Material.SetTextureMatrix(System.Int32,IrrlichtLime.Core.Matrix)">
            <summary>
Set the texture transformation matrix.
</summary>
            <param name="index">Texture index. Should be in range [0,MaxTextures-1].</param>
        </member>
        <member name="M:IrrlichtLime.Video.Material.SetTexture(System.Int32,IrrlichtLime.Video.Texture)">
            <summary>
Set specific texture.
</summary>
            <param name="index">Texture index. Should be in range [0,MaxTextures-1].</param>
        </member>
        <member name="M:IrrlichtLime.Video.Material.SetFlag(IrrlichtLime.Video.MaterialFlag,System.Boolean)">
            <summary>
Set the material flag.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Material.GetTextureMatrix(System.Int32)">
            <summary>
Get the texture transformation matrix.
</summary>
            <param name="index">Texture index. Should be in range [0,MaxTextures-1].</param>
        </member>
        <member name="M:IrrlichtLime.Video.Material.GetTexture(System.Int32)">
            <summary>
Get specific texture.
</summary>
            <param name="index">Texture index. Should be in range [0,MaxTextures-1].</param>
        </member>
        <member name="M:IrrlichtLime.Video.Material.GetFlag(IrrlichtLime.Video.MaterialFlag)">
            <summary>
Get the material flag.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Material.#ctor(IrrlichtLime.Video.Material)">
            <summary>
Copy constructor.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Material.#ctor">
            <summary>
Default constructor.
Creates a solid, lit material with white colors.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.MaxTextures">
            <summary>
Maximum number of texture a Material can have.
Material might ignore some textures in most function, like assignment and comparison,
when <c>IrrlichtCreationParameters.MaxTextureUnits</c> is set to a lower number.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.IdentityRedWireframe">
            <summary>
Identity material with red wireframe setup.
Intended for debugging purposes.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.IdentityNoLighting">
            <summary>
Identity material with no lighting setup.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Material.Identity">
            <summary>
Identity material.
Solid, lit material with white colors.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.Material">
            <summary>
Parameters for a material renderer.
</summary>
        </member>
        <member name="M:IrrlichtLime.IrrlichtDevice.Yield">
            <summary>
Cause the device to temporarily pause execution and let other processes run.
This should bring down processor usage without major performance loss for Irrlicht.
</summary>
        </member>
        <member name="M:IrrlichtLime.IrrlichtDevice.Run">
            <summary>
Runs the device.
Also increments the virtual timer by calling <c>Timer.Tick()</c>.
You can prevent this by calling <c>Timer.Stop()</c>; before and <c>Timer.Start()</c> after calling this method.
</summary>
            <returns>False if device wants to be deleted.</returns>
        </member>
        <member name="T:IrrlichtLime.IrrlichtDevice">
            <summary>
The Irrlicht device. You can create it with <c>IrrlichtDevice.CreateDevice()</c>.
This is the most important class of the Irrlicht Engine.
You can access everything in the engine if you have a pointer to an instance of this class.
There should be only one instance of this class at any time.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.Type">
            <summary>
Type of this event.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.User">
            <summary>
User event.
Valid only when Type is <see cref="F:IrrlichtLime.EventType.User" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.Mouse">
            <summary>
Mouse event.
Valid only when Type is <see cref="F:IrrlichtLime.EventType.Mouse" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.Log">
            <summary>
Log event.
Valid only when Type is <see cref="F:IrrlichtLime.EventType.Log" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.Key">
            <summary>
Keyboard event.
Valid only when Type is <see cref="F:IrrlichtLime.EventType.Key" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.Joystick">
            <summary>
Joystick event.
Valid only when Type is <see cref="F:IrrlichtLime.EventType.Joystick" />.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.GUI">
            <summary>
GUI event.
Valid only when Type is <see cref="F:IrrlichtLime.EventType.GUI" />.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(System.Int32,System.Int32)">
            <summary>
Constructs a user event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(System.String)">
            <summary>
Constructs a log event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(System.String,IrrlichtLime.LogLevel)">
            <summary>
Constructs a log event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(System.Byte,System.Int16[],System.UInt16)">
            <summary>
Constructs a joystick event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(System.Byte,System.Int16[],System.UInt16,System.UInt32)">
            <summary>
Constructs a joystick event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(System.Char,IrrlichtLime.KeyCode,System.Boolean)">
            <summary>
Constructs a keyboard event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(System.Char,IrrlichtLime.KeyCode,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Constructs a keyboard event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32)">
            <summary>
Constructs a mouse event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32,System.Single)">
            <summary>
Constructs a mouse event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32,System.Single,System.UInt32)">
            <summary>
Constructs a mouse event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32,System.Single,System.UInt32,System.Boolean,System.Boolean)">
            <summary>
Constructs a mouse event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.GUI.GUIEventType,IrrlichtLime.GUI.GUIElement)">
            <summary>
Constructs a GUI event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.GUI.GUIEventType,IrrlichtLime.GUI.GUIElement,IrrlichtLime.GUI.GUIElement)">
            <summary>
Constructs a GUI event.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.UserEvent.UserData2">
            <summary>
Another user specified data.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.UserEvent.UserData1">
            <summary>
Some user specified data.
</summary>
        </member>
        <member name="T:IrrlichtLime.Event.UserEvent">
            <summary>
Any kind of user event.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.LogEvent.Level">
            <summary>
Log level in which the text has been logged.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.LogEvent.Text">
            <summary>
Text which has been logged.
</summary>
        </member>
        <member name="T:IrrlichtLime.Event.LogEvent">
            <summary>
Any kind of log event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.JoystickEvent.IsButtonPressed(System.Int32)">
            <summary>
Checks if specific button is pressed.
The button is an index value from 0 to ButtonCount-1.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.JoystickEvent.Joystick">
            <summary>
The ID of the joystick which generated this event.
This is an internal Irrlicht index; it does not map directly to any particular hardware joystick.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.JoystickEvent.POV">
            <summary>
The POV represents the angle of the POV hat in degrees*100, from 0 to 35,900.
A value of 65535 indicates that the POV hat is centered (or not present).
This value is only supported on Windows.
On Linux, the POV hat will be sent as 2 axes instead.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.JoystickEvent.Axis">
            <summary>
Array of axes.
Holds AxisCount values; where
index 0 named as X (e.g. analog stick 1 left to right),
index 1 named as Y (e.g. analog stick 1 top to bottom),
index 2 named as Z (e.g. throttle, or analog 2 stick 2 left to right),
index 3 named as R (e.g. rudder, or analog 2 stick 2 top to bottom),
index 4 named as U,
index 5 named as V.
Values are in the range -32768 to 32767, with 0 representing the center position.
You will receive the raw value from the joystick, and so will usually want to implement a dead zone around the center of the range.
Axes not supported by this joystick will always have a value of 0.
On Linux, POV hats are represented as axes, usually the last two active axis.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.JoystickEvent.ButtonStates">
            <summary>
A bitmap of button states.
You can use <c>IsButtonPressed()</c> to check the state of each button from 0 to ButtonCount-1.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.JoystickEvent.AxisCount">
            <summary>
Number of axes.
</summary>
        </member>
        <member name="P:IrrlichtLime.Event.JoystickEvent.ButtonCount">
            <summary>
Number of buttons.
</summary>
        </member>
        <member name="T:IrrlichtLime.Event.JoystickEvent">
            <summary>
A joystick event.
Unlike other events, joystick events represent the result of polling each connected joystick once per <c>device.Run()</c>.
Joystick events will not be generated by default.
If joystick support is available for the active device and <c>device.ActivateJoysticks()</c> has been called,
an event of this type will be generated once per joystick per <c>device.Run()</c>
regardless of whether the state of the joystick has actually changed.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.KeyEvent.Control">
            <summary>
True if CTRL key was also pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.KeyEvent.Shift">
            <summary>
True if Shift key was also pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.KeyEvent.PressedDown">
            <summary>
If not true, then the key was left up.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.KeyEvent.Key">
            <summary>
Key which has been pressed or released.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.KeyEvent.Char">
            <summary>
Character corresponding to the key (0, if not a character, value undefined in key releases).
</summary>
        </member>
        <member name="T:IrrlichtLime.Event.KeyEvent">
            <summary>
Any kind of keyboard event.
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.MouseEvent.IsMiddlePressed">
            <summary>
Is the middle button pressed down?
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.MouseEvent.IsRightPressed">
            <summary>
Is the right button pressed down?
</summary>
        </member>
        <member name="M:IrrlichtLime.Event.MouseEvent.IsLeftPressed">
            <summary>
Is the left button pressed down?
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.MouseEvent.Type">
            <summary>
Type of this mouse event.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.MouseEvent.ButtonStates">
            <summary>
A bitmap of button states.
You can use Is[button]Pressed() to determine if a button is pressed or not.
Currently only valid if the event was <see cref="F:IrrlichtLime.MouseEventType.Move" />.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.MouseEvent.Control">
            <summary>
True if CTRL key was also pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.MouseEvent.Shift">
            <summary>
True if Shift key was also pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.MouseEvent.Wheel">
            <summary>
Mouse wheel delta, often 1.0 or -1.0, but can have other values &lt;0.0f or &gt;0.0f.
Only valid if event was <see cref="F:IrrlichtLime.MouseEventType.Wheel" />.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.MouseEvent.Y">
            <summary>
Y position of mouse cursor.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.MouseEvent.X">
            <summary>
X position of mouse cursor.
</summary>
        </member>
        <member name="T:IrrlichtLime.Event.MouseEvent">
            <summary>
Any kind of mouse event.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.GUIEvent.Type">
            <summary>
Type of GUI event.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.GUIEvent.Element">
            <summary>
If the event has something to do with another element, it will be held here.
</summary>
        </member>
        <member name="F:IrrlichtLime.Event.GUIEvent.Caller">
            <summary>
Who called the event.
</summary>
        </member>
        <member name="T:IrrlichtLime.Event.GUIEvent">
            <summary>
Any kind of GUI event.
</summary>
        </member>
        <member name="T:IrrlichtLime.Event">
            <summary>
Information about an event.
</summary>
        </member>
        <member name="P:IrrlichtLime.ReferenceCounted.ReferenceCount">
            <summary>
Current value of the reference counter.
</summary>
        </member>
        <member name="P:IrrlichtLime.ReferenceCounted.DebugName">
            <summary>
The debug name of the object.
This value may only be set and changed by the object itself.
This value should only be used in Debug mode.
</summary>
        </member>
        <member name="M:IrrlichtLime.ReferenceCounted.Grab">
            <summary>
Grabs the object. Increments the reference counter by one.
Someone who calls Grab() to an object, should later also call Drop() to it.
If an object never gets as much Drop() as Grab() calls, it will never be destroyed.
</summary>
        </member>
        <member name="M:IrrlichtLime.ReferenceCounted.Drop">
            <summary>
Drops the object. Decrements the reference counter by one.
Note, that you only need to call Drop() if you created the object
(e.g. you get the object by calling method with "Create" in its name).
</summary>
            <returns>True, if the object was deleted.</returns>
        </member>
        <member name="M:IrrlichtLime.ReferenceCounted.op_Inequality(IrrlichtLime.ReferenceCounted,IrrlichtLime.ReferenceCounted)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.ReferenceCounted.op_Equality(IrrlichtLime.ReferenceCounted,IrrlichtLime.ReferenceCounted)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.ReferenceCounted">
            <summary>
Base class of most objects of the Irrlicht Engine.
This class provides reference counting through the methods Grab() and Drop().
It also is able to store a debug string for every instance of an object.
Most objects of the Irrlicht Engine are derived from ReferenceCounted, and so they are reference counted.
<para>When you create an object in the Irrlicht engine, calling a method which starts with "Create", an object is created,
and you get a pointer to the new object. If you no longer need the object, you have to call Drop().
This will destroy the object, if Grab() was not called in another part of your program, because this part still needs the object.
Note, that you only need to call Drop() to the object, if you created it, and the method had a "Create" in it.</para></summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3DTangents.Binormal">
            <summary>
Binormal vector (tangent x normal).
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3DTangents.Tangent">
            <summary>
Tangent vector along the x-axis of the texture.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color,IrrlichtLime.Core.Vector2Df)">
            <summary>
Constructs vertex from position, normal, color and texture coords.
Tangent and Binormal are both set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructs vertex from position, normal, color, texture coords and tangent.
Binormal is set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructs vertex from position, normal, color, texture coords, tangent and binormal.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position.
Color is set to solid white (0xffffffff).
TCoords is set to (0,0).
Normal, Tangent and Binormal are all set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position and normal.
Color is set to solid white (0xffffffff).
TCoords is set to (0,0).
Tangent and Binormal are both set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color)">
            <summary>
Constructs vertex from position, normal and color.
TCoords is set to (0,0).
Tangent and Binormal are both set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color,System.Single,System.Single)">
            <summary>
Constructs vertex from position, normal, color and texture coords.
Tangent and Binormal are both set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position, normal, color, texture coords and tangent.
Binormal is set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTangents.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position, normal, color, texture coords, tangent and binormal.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.Vertex3DTangents">
            <summary>
Vertex with a tangent and binormal vector.
Usually used for tangent space normal mapping.
Usually tangent and binormal get send to shaders as texture coordinate sets 1 and 2.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3DTTCoords.TCoords2">
            <summary>
Second set of texture coordinates.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTTCoords.#ctor(IrrlichtLime.Video.Vertex3D)">
            <summary>
Constructs vertex from Vertex3D.
TCoords2 is not initialized (can contain any value).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTTCoords.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color,IrrlichtLime.Core.Vector2Df)">
            <summary>
Constructs vertex from position, normal, color and one texture coords.
TCoords and TCoords2 are getting same value.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTTCoords.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Constructs vertex from position, normal, color and two texture coords.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTTCoords.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Constructs vertex from position, color and two texture coords.
Normal is set to (0,0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTTCoords.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color,System.Single,System.Single)">
            <summary>
Constructs vertex from position, normal, color and one texture coords.
TCoords and TCoords2 are getting same value.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTTCoords.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position, normal, color and two texture coords.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3DTTCoords.#ctor(System.Single,System.Single,System.Single,IrrlichtLime.Video.Color,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position, color and two texture coords.
Normal is set to (0,0,0).
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.Vertex3DTTCoords">
            <summary>
Vertex with two texture coordinates.
Usually used for geometry with lightmaps or other special materials.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructs vertex from position.
Normal is set to (0,0,0).
Color is not initialized (can contain any value).
Texture coords set to (0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructs vertex from position and normal.
Color is not initialized (can contain any value).
Texture coords set to (0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color)">
            <summary>
Constructs vertex from position, normal and color.
Texture coords set to (0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Video.Color,IrrlichtLime.Core.Vector2Df)">
            <summary>
Constructs vertex from position, normal, color and texture coords.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position.
Normal is set to (0,0,0).
Color is not initialized (can contain any value).
Texture coords set to (0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs vertex from position and normal.
Color is not initialized (can contain any value).
Texture coords set to (0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color)">
            <summary>
Constructs vertex from position, normal and color.
Texture coords set to (0,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,IrrlichtLime.Video.Color,System.Single,System.Single)">
            <summary>
Constructs vertex from position, normal, color and texture coords.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3D.Type">
            <summary>
Type of this vertex.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3D.TCoords">
            <summary>
Texture coordinates.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3D.Color">
            <summary>
Color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3D.Normal">
            <summary>
Normal vector.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Vertex3D.Position">
            <summary>
Position.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.GetInterpolated(IrrlichtLime.Video.Vertex3D,System.Single)">
            <summary>
Get interpolated vertex from other (d=0) to this (d=1) vertex.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor(IrrlichtLime.Video.Vertex3D)">
            <summary>
Copy constructor.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Vertex3D.#ctor">
            <summary>
Default constructor.
Data is not initialized.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.Vertex3D">
            <summary>
Standard vertex used by the Irrlicht Engine.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Triangle3Df.C">
            <summary>
Point C of the triangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Triangle3Df.B">
            <summary>
Point B of the triangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Triangle3Df.A">
            <summary>
Point A of the triangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Triangle3Df.Normal">
            <summary>
The normal of the triangle.
Please note: The normal is not always normalized.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Triangle3Df.Area">
            <summary>
The area of the triangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Triangle3Df.Plane">
            <summary>
The plane of the triangle.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.GetIntersectionOfPlaneWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df@)">
            <summary>
Calculates the intersection between a 3d line and the plane the triangle is on.
</summary>
            <param name="linePoint">Point of the line to intersect with.</param>
            <param name="lineVect">Vector of the line to intersect with.</param>
            <param name="intersection">Place to store the intersection point, if there is one.</param>
            <returns>True if there was an intersection, else false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.GetIntersectionWithLimitedLine(IrrlichtLime.Core.Line3Df,IrrlichtLime.Core.Vector3Df@)">
            <summary>
Get an intersection with a 3d line.
</summary>
            <param name="line">Line to intersect with.</param>
            <param name="intersection">Place to store the intersection point, if there is one.</param>
            <returns>True if there was an intersection, false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.GetIntersectionWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df@)">
            <summary>
Get an intersection with a 3d line.
Please note that also points are returned as intersection which are on the line, but not between the start and end point of the line.
If you want the returned point be between start and end use <c>GetIntersectionWithLimitedLine()</c>.
</summary>
            <param name="linePoint">Point of the line to intersect with.</param>
            <param name="lineVect">Vector of the line to intersect with.</param>
            <param name="intersection">Place to store the intersection point, if there is one.</param>
            <returns>True if there was an intersection, false if there was not.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.IsPointInsideFast(IrrlichtLime.Core.Vector3Df)">
            <summary>
Check if a point is inside the triangle (border-points count also as inside).
This method uses a barycentric coordinate system.
It is faster than <c>isPointInside()</c> but is more susceptible to floating point rounding errors.
This will especially be noticeable when the FPU is in single precision mode (which is for example set on default by Direct3D).
</summary>
            <param name="point">Point to test. Assumes that this point is already on the plane of the triangle.</param>
            <returns>True if the point is inside the triangle, otherwise false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.IsPointInside(IrrlichtLime.Core.Vector3Df)">
            <summary>
Check if a point is inside the triangle (border-points count also as inside).
</summary>
            <param name="point">Point to test. Assumes that this point is already on the plane of the triangle.</param>
            <returns>True if the point is inside the triangle, otherwise false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.IsFrontFacing(IrrlichtLime.Core.Vector3Df)">
            <summary>
Test if the triangle would be front or backfacing from any point.
Thus, this method assumes a camera position from which the triangle is definitely visible when looking at the given direction.
Do not use this method with points as it will give wrong results!
</summary>
            <param name="lookDirection">Look direction.</param>
            <returns>True if the plane is front facing and false if it is backfacing.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.IsTotalOutsideBox(IrrlichtLime.Core.AABBox)">
            <summary>
Determines if the triangle is totally outside a bounding box.
</summary>
            <param name="box">Box to check.</param>
            <returns>True if triangle is outside the box, otherwise false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.IsTotalInsideBox(IrrlichtLime.Core.AABBox)">
            <summary>
Determines if the triangle is totally inside a bounding box.
</summary>
            <param name="box">Box to check.</param>
            <returns>True if triangle is within the box, otherwise false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.GetClosestPointOnTriangle(IrrlichtLime.Core.Vector3Df)">
            <summary>
Get the closest point on a triangle to a point on the same plane.
</summary>
            <param name="point">Point which must be on the same plane as the triangle.</param>
            <returns>The closest point of the triangle.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Sets the triangle's points.
</summary>
            <param name="point1">First point.</param>
            <param name="point2">Second point.</param>
            <param name="point3">Third point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor for triangle with given three vertices.
</summary>
            <param name="point1">First point.</param>
            <param name="point2">Second point.</param>
            <param name="point3">Third point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.#ctor(IrrlichtLime.Core.Triangle3Df)">
            <summary>
Copy constructor.
</summary>
            <param name="copy">Other triangle.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.#ctor">
            <summary>
Constructor for an all 0 triangle.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.op_Inequality(IrrlichtLime.Core.Triangle3Df,IrrlichtLime.Core.Triangle3Df)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Triangle3Df.op_Equality(IrrlichtLime.Core.Triangle3Df,IrrlichtLime.Core.Triangle3Df)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Triangle3Df">
            <summary>
3D triangle class for doing collision detection and other things.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Quaternion.Z">
            <summary>
Z coordinate of the vectorial (imaginary) part.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Quaternion.Y">
            <summary>
Y coordinate of the vectorial (imaginary) part.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Quaternion.X">
            <summary>
X coordinate of the vectorial (imaginary) part.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Quaternion.W">
            <summary>
Real part.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.ToEuler">
            <summary>
Euler angle (radians).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.ToAngleAxis(System.Single@,IrrlichtLime.Core.Vector3Df@)">
            <summary>
Fills an angle (radians) around an axis (unit vector).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Slerp(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Quaternion,System.Single)">
            <summary>
Set this quaternion to the result of the spherical interpolation between two quaternions.
</summary>
            <param name="q1">First quaternion to be interpolated.</param>
            <param name="q2">Second quaternion to be interpolated.</param>
            <param name="time">Progress of interpolation. For time=0 the result is q1, for time=1 the result is q2. Otherwise interpolation between q1 and q2.</param>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Slerp(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Quaternion,System.Single,System.Single)">
            <summary>
Set this quaternion to the result of the spherical interpolation between two quaternions.
</summary>
            <param name="q1">First quaternion to be interpolated.</param>
            <param name="q2">Second quaternion to be interpolated.</param>
            <param name="time">Progress of interpolation. For time=0 the result is q1, for time=1 the result is q2. Otherwise interpolation between q1 and q2.</param>
            <param name="threshold">To avoid inaccuracies at the end (time=1) the interpolation switches to linear interpolation at some point.
This value defines how much of the remaining interpolation will be calculated with <c>Lerp()</c>.
Everything from 1-threshold up will be linear interpolation. Default is .05f.</param>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Normalize">
            <summary>
Normalizes this quaternion.
</summary>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.MakeRotation(System.Single,IrrlichtLime.Core.Vector3Df)">
            <summary>
Set this quaternion to represent a rotation from angle and axis.
Axis must be unit length, angle in radians.
The quaternion representing the rotation is q = cos(A/2) + sin(A/2) * (x*i + y*j + z*k).
</summary>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.MakeRotation(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Set this quaternion to represent a rotation from one vector to another.
</summary>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.MakeInverse">
            <summary>
Inverts this quaternion.
</summary>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.MakeIdentity">
            <summary>
Set this quaternion to identity.
</summary>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Lerp(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Quaternion,System.Single)">
            <summary>
Set this quaternion to the result of the linear interpolation between two quaternions.
</summary>
            <returns>This quaternion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.GetMatrixCenter(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Creates a matrix from this quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.GetMatrixFast">
            <summary>
Faster method to create a rotation matrix, you should normalize the quaternion before!
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.GetMatrix(IrrlichtLime.Core.Vector3Df)">
            <summary>
Gets the rotation matrix from this quaternion.
</summary>
            <param name="translation">Default is (0,0,0).</param>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.GetMatrix">
            <summary>
Gets the rotation matrix from this quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.EqualsTo(IrrlichtLime.Core.Quaternion)">
            <summary>
Checks if this quaternion equals the other one, taking floating point rounding errors into account.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.DotProduct(IrrlichtLime.Core.Quaternion)">
            <summary>
Calculates the dot product.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Set(System.Single,System.Single,System.Single)">
            <summary>
Set this quaternion based on Euler angles (radians).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Set(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Set this quaternion directly by given imaginary part (x, y, z) and real part (w).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Set(IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor which converts Euler angles (radians) to a quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.Set(IrrlichtLime.Core.Quaternion)">
            <summary>
Set this quaternion from other quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructor which converts Euler angles (radians) to a quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.#ctor(IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor which converts Euler angles (radians) to a quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.#ctor(IrrlichtLime.Core.Matrix)">
            <summary>
Constructor which converts a matrix to a quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs quaternion directly by given imaginary part (x, y, z) and real part (w).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.#ctor(IrrlichtLime.Core.Quaternion)">
            <summary>
Copy constructor.
</summary>
            <param name="copy">Other quaternion.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.#ctor">
            <summary>
Constructs identity quaternion.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.op_Multiply(IrrlichtLime.Core.Quaternion,System.Single)">
            <summary>
Multiplication operator with scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.op_Multiply(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Vector3Df)">
            <summary>
Multiplication operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.op_Multiply(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Quaternion)">
            <summary>
Multiplication operator.
Be careful, unfortunately the operator order here is opposite of that in <c>Matrix.operator*()</c>.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.op_Addition(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Quaternion)">
            <summary>
Add operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.op_Inequality(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Quaternion)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Quaternion.op_Equality(IrrlichtLime.Core.Quaternion,IrrlichtLime.Core.Quaternion)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Quaternion.Identity">
            <summary>
Identity quaternion.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Quaternion">
            <summary>
Quaternion class for representing rotations.
It provides cheap combinations and avoids gimbal locks.
Also useful for interpolations.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.Transposed">
            <summary>
Transposed matrix.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.Translation">
            <summary>
Current translation of the matrix.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.Scale">
            <summary>
Current scale of the matrix.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.Rotation">
            <summary>
Current rotation of the matrix.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.IsOrthogonal">
            <summary>
The matrix is orthogonal matrix.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.IsIdentityIntegerBase">
            <summary>
The matrix is identity matrix.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.IsIdentity">
            <summary>
The matrix is identity matrix.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.IsDefinitelyIdentity">
            <summary>
The matrix is definitely identity matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.TranslateVector(IrrlichtLime.Core.Vector3Df@)">
            <summary>
Translates a vector by the translation part of this matrix.
This operation is performed as if the vector was 4d with the 4th component =1.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.TransformVector(IrrlichtLime.Core.Vector3Df@)">
            <summary>
Transforms a vector by this matrix.
This operation is performed as if the vector was 4d with the 4th component =1.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.TransformPlane(IrrlichtLime.Core.Plane3Df@)">
            <summary>
Transforms a plane by this matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.TransformBoxEx(IrrlichtLime.Core.AABBox@)">
            <summary>
Transforms an axis aligned bounding box.
The result box of this operation should be accurate, but this operation is slower than TransformBox().
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.TransformBox(IrrlichtLime.Core.AABBox@)">
            <summary>
Transforms the edge-points of a bounding box.
The result box of this operation may not be accurate at all. For correct results, use TransformBoxEx().
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.ToArray">
            <summary>
Returns array of all 16 elements of the matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetTextureTranslateTransposed(System.Single,System.Single)">
            <summary>
Set texture transformation translation, using a transposed representation.
Doesn't clear other elements than those affected.
</summary>
            <param name="x">Offset on x axis.</param>
            <param name="y">Offset on y axis.</param>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetTextureTranslate(System.Single,System.Single)">
            <summary>
Set texture transformation translation.
Doesn't clear other elements than those affected.
</summary>
            <param name="x">Offset on x axis.</param>
            <param name="y">Offset on y axis.</param>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetTextureScaleCenter(System.Single,System.Single)">
            <summary>
Set texture transformation scale, and recenter at (0.5,0.5).
Doesn't clear other elements than those affected.
</summary>
            <param name="sx">Scale factor on x axis.</param>
            <param name="sy">Scale factor on y axis.</param>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetTextureScale(System.Single,System.Single)">
            <summary>
Set texture transformation scale.
Doesn't clear other elements than those affected.
</summary>
            <param name="sx">Scale factor on x axis.</param>
            <param name="sy">Scale factor on y axis.</param>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetTextureRotationCenter(System.Single)">
            <summary>
Set texture transformation rotation.
Rotate about z axis, recenter at (0.5,0.5). Doesn't clear other elements than those affected.
</summary>
            <param name="radAngle">Angle in radians.</param>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetRotationRadians(IrrlichtLime.Core.Vector3Df)">
            <summary>
Make a rotation matrix from Euler angles.
The 4th row and column are unmodified.
</summary>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetRotationAxisRadians(System.Single,IrrlichtLime.Core.Vector3Df)">
            <summary>
Make a rotation matrix from angle and axis, assuming left handed rotation.
The 4th row and column are unmodified.
</summary>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetRotationCenter(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Builds a combined matrix which translates to a center before rotation and translates from origin afterwards.
</summary>
            <param name="center">Position to rotate around.</param>
            <param name="translate">Translation applied after the rotation.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetInverseTranslation(IrrlichtLime.Core.Vector3Df)">
            <summary>
Set the inverse translation of the current matrix. Will erase any previous values.
</summary>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetInverseRotationRadians(IrrlichtLime.Core.Vector3Df)">
            <summary>
Make an inverted rotation matrix from Euler angles.
The 4th row and column are unmodified.
</summary>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetInverseRotationDegrees(IrrlichtLime.Core.Vector3Df)">
            <summary>
Make an inverted rotation matrix from Euler angles.
The 4th row and column are unmodified.
</summary>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetElementArray(System.Single[])">
            <summary>
Set all matrix elements at once.
</summary>
            <param name="values">Array of elements to set. Array length must be at least 16.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetElement(System.Int32,System.Single)">
            <summary>
Set value of the element of the matrix.
</summary>
            <param name="index">Linear index of the element. Must be in range of [0..15].</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetElement(System.Int32,System.Int32,System.Single)">
            <summary>
Set value of the element of the matrix.
</summary>
            <param name="row">Row of the element. Must be in range of [0..3].</param>
            <param name="column">Column of the element. Must be in range of [0..3].</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetByProductNoCheck(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
            <summary>
Set this matrix to the product of two matrices.
Calculate otherA * otherB.
No optimization used, use it if you know you never have an identity matrix.
</summary>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.SetByProduct(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
            <summary>
Set this matrix to the product of two matrices.
Calculate otherA * otherB.
</summary>
            <returns>This matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.RotateVector(IrrlichtLime.Core.Vector3Df)">
            <summary>
Rotate a vector by the rotation part of this matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.MultiplyWith1x4Matrix(System.Single[]@)">
            <summary>
Multiplies this matrix by a 1x4 matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.MakeInverse">
            <summary>
Calculates inverse of matrix. Slow.
</summary>
            <returns>This matrix after inverse or null if no inverse matrix.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.MakeIdentity">
            <summary>
Set matrix to identity.
</summary>
            <returns>This matrix after making it identity.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.InverseTranslateVector(IrrlichtLime.Core.Vector3Df@)">
            <summary>
Translate a vector by the inverse of the translation part of this matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.InverseRotateVector(IrrlichtLime.Core.Vector3Df@)">
            <summary>
Rotate a vector by the inverse of the rotation part of this matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.GetInversePrimitive">
            <summary>
Inverts a primitive matrix which only contains a translation and a rotation.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.GetInverse">
            <summary>
Gets an inverted matrix.
The inverse is calculated using Cramers rule.
</summary>
            <returns>Inverse matrix or null the one doesn't exist.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.GetInterpolated(IrrlichtLime.Core.Matrix,System.Single)">
            <summary>
Gets an interpolated matrix from this and other one.
</summary>
            <param name="other">Other matrix to interpolate with.</param>
            <param name="time">Must be a value between 0 and 1.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.GetElement(System.Int32)">
            <summary>
Gets specific matrix element.
</summary>
            <param name="index">Linear index of the element. Must be in range of [0..15].</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.GetElement(System.Int32,System.Int32)">
            <summary>
Gets specific matrix element.
</summary>
            <param name="row">Row index of the element. Must be in range of [0..3].</param>
            <param name="column">Column index of the element. Must be in range of [0..3].</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildTextureTransform(System.Single,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Builds a texture transformation matrix with the given parameters.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildShadowMatrix(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Plane3Df)">
            <summary>
Builds a matrix that flattens geometry into a plane.
</summary>
            <param name="light">Light source.</param>
            <param name="plane">Plane into which the geometry if flattened into.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildShadowMatrix(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Plane3Df,System.Single)">
            <summary>
Builds a matrix that flattens geometry into a plane.
</summary>
            <param name="light">Light source.</param>
            <param name="plane">Plane into which the geometry if flattened into.</param>
            <param name="point">value between 0 and 1, describing the light source.
If this is 1, it is a point light, if it is 0, it is a directional light. Default is 1.f.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildRotateFromTo(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Builds a matrix that rotates from one vector to another.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveRH(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Builds a right-handed perspective projection matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveRH(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
Builds a right-handed perspective projection matrix.
</summary>
            <param name="zClipFromZero">Clipping of z can be projected from 0 to w when true (D3D style) and from -w to w when false (OGL style). Default is true.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveLH(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Builds a left-handed perspective projection matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveLH(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
Builds a left-handed perspective projection matrix.
</summary>
            <param name="zClipFromZero">Clipping of z can be projected from 0 to w when true (D3D style) and from -w to w when false (OGL style). Default is true.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveFovRH(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Builds a right-handed perspective projection matrix based on a field of view.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveFovRH(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
Builds a right-handed perspective projection matrix based on a field of view.
</summary>
            <param name="zClipFromZero">Clipping of z can be projected from 0 to w when true (D3D style) and from -w to w when false (OGL style). Default is true.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveFovLH(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Builds a left-handed perspective projection matrix based on a field of view.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveFovLH(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
Builds a left-handed perspective projection matrix based on a field of view.
</summary>
            <param name="zClipFromZero">Clipping of z can be projected from 0 to w when true (D3D style) and from -w to w when false (OGL style). Default is true.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixOrthoRH(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Builds a right-handed orthogonal projection matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixOrthoRH(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
Builds a right-handed orthogonal projection matrix.
</summary>
            <param name="zClipFromZero">Clipping of z can be projected from 0 to 1 when true (D3D style) and from -1 to 1 when false (OGL style). Default is true.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixOrthoLH(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Builds a left-handed orthogonal projection matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixOrthoLH(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
Builds a left-handed orthogonal projection matrix.
</summary>
            <param name="zClipFromZero">Clipping of z can be projected from 0 to 1 when true (D3D style) and from -1 to 1 when false (OGL style). Default is true.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildNDCToDCMatrix(IrrlichtLime.Core.Recti,System.Single)">
            <summary>
Builds a matrix which transforms a normalized Device Coordinate to Device Coordinates.
Used to scale (-1,-1)(1,1) to viewport, for example from (-1,-1)(1,1) to the viewport (0,0)(0,640).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildCameraLookAtMatrixRH(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Builds a right-handed look-at matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildCameraLookAtMatrixLH(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Builds a left-handed look-at matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.BuildAxisAlignedBillboard(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Builds a matrix which rotates a source vector to a look vector over an arbitrary axis.
</summary>
            <param name="camPos">Viewer position in world coord.</param>
            <param name="center">Object position in world-coord, rotation pivot.</param>
            <param name="translation">Object final translation from center.</param>
            <param name="axis">Axis to rotate about.</param>
            <param name="from">Source vector to rotate from.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.#ctor(IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor with vectors.
</summary>
            <param name="translation">The translation vector.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor with vectors.
</summary>
            <param name="translation">The translation vector.</param>
            <param name="rotation">The rotation vector. Default is no rotation, e.g. (0,0,0).</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor with vectors.
</summary>
            <param name="translation">The translation vector.</param>
            <param name="rotation">The rotation vector. Default is no rotation, e.g. (0,0,0).</param>
            <param name="scale">The scale vector. Default is no scale, e.g. (1,1,1).</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.#ctor(IrrlichtLime.Core.Matrix)">
            <summary>
Copy constructor.
</summary>
            <param name="copy">Other matrix.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.#ctor">
            <summary>
Default constructor.
Initializes identity matrix.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.op_Multiply(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
            <summary>
Multiply by another matrix.
Calculate other*this.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.op_Multiply(IrrlichtLime.Core.Matrix,System.Single)">
            <summary>
Multiply by scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.op_Subtraction(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
            <summary>
Subtract matrices.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.op_Addition(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
            <summary>
Add two matrices.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.op_Inequality(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Matrix.op_Equality(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Matrix.Identity">
            <summary>
Identity matrix.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Matrix">
            <summary>
4x4 matrix. Mostly used as transformation matrix for 3d calculations.
The matrix is a D3D style matrix, row major with translations in the 4th row.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Plane3Df.D">
            <summary>
Distance from origin.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Plane3Df.Normal">
            <summary>
Normal vector of the plane.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Plane3Df.MemberPoint">
            <summary>
Member point of the plane.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.ExistsIntersection(IrrlichtLime.Core.Plane3Df)">
            <summary>
Tests if there is an intersection with the other plane.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.GetDistanceTo(IrrlichtLime.Core.Vector3Df)">
            <summary>
Get the distance to a point.
Note that this only works if the normal is normalized.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.IsFrontFacing(IrrlichtLime.Core.Vector3Df)">
            <summary>
Test if the triangle would be front or backfacing from any point.
Thus, this method assumes a camera position from which the triangle is definitely visible when looking into the given direction.
Note that this only works if the normal is normalized.
Do not use this method with points as it will give wrong results!
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithPlanes(IrrlichtLime.Core.Plane3Df,IrrlichtLime.Core.Plane3Df)">
            <summary>
Get the intersection point with two other planes if there is one.
</summary>
            <returns>The intersection point, or null if none.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithPlane(IrrlichtLime.Core.Plane3Df,IrrlichtLime.Core.Vector3Df@,IrrlichtLime.Core.Vector3Df@)">
            <summary>
Get the intersection with other plane if there is one.
</summary>
            <param name="other">Other plane to intersect with.</param>
            <param name="intersectionLinePoint">Base point of intersection line.</param>
            <param name="intersectionLineVector">Vector of intersection.</param>
            <returns>True if there is a intersection, false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithLimitedLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Get an intersection with a 3d line, limited between two 3d points.
</summary>
            <returns>The intersection point, or null if none.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.GetKnownIntersectionWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Get percentage of line between two points where an intersection with this plane happens.
Only useful if known that there is an intersection.
</summary>
            <returns>Where on a line between two points an intersection with this plane happened.
For example, 0.5 is returned if the intersection happened exactly in the middle of the two points.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Get an intersection with a 3d line.
</summary>
            <param name="linePoint">Point of the line to intersect with.</param>
            <param name="lineVect">Vector of the line to intersect with.</param>
            <returns>The intersection point, or null if none.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.Set(IrrlichtLime.Core.Vector3Df,System.Single)">
            <summary>
Set this plane from normal and the distance from origin.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Set this plane from three member points.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Set this plane from specified member point and normal.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.#ctor(IrrlichtLime.Core.Vector3Df,System.Single)">
            <summary>
Constructs plane from normal and the distance from origin.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructs plane from three member points.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs plane from specified member point and normal.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructs plane from specified member point and normal.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.#ctor(IrrlichtLime.Core.Plane3Df)">
            <summary>
Copy constructor.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.#ctor">
            <summary>
Constructs plane from member point (0,0,0) and normal (0,1,0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.op_Inequality(IrrlichtLime.Core.Plane3Df,IrrlichtLime.Core.Plane3Df)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Plane3Df.op_Equality(IrrlichtLime.Core.Plane3Df,IrrlichtLime.Core.Plane3Df)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Plane3Df">
            <summary>
Plane class with some intersection testing methods.
It has to be ensured, that the normal is always normalized.
The constructors and setters of this class will not ensure this automatically.
So any normal passed in has to be normalized in advance.
No change to the normal will be made by any of the class methods.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.LowerRightCorner">
            <summary>
Lower right corner of the rectangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.UpperLeftCorner">
            <summary>
Upper left corner of the rectangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.Center">
            <summary>
Center of the rectangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.Size">
            <summary>
Dimensions of the rectangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.Area">
            <summary>
Area of the rectangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.Height">
            <summary>
Height of the rectangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.Width">
            <summary>
Width of the rectangle.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Recti.IsValid">
            <summary>
True if the rect is valid to draw.
It would be invalid if the UpperLeftCorner is lower or more right than the LowerRightCorner.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.Offset(System.Int32,System.Int32)">
            <summary>
Moves rectangle by given x and y.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.IsRectCollided(IrrlichtLime.Core.Recti)">
            <summary>
Check if the rectangle collides with another rectangle.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.IsPointInside(System.Int32,System.Int32)">
            <summary>
Check if a point is within this rectangle.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.IsPointInside(IrrlichtLime.Core.Vector2Di)">
            <summary>
Check if a point is within this rectangle.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.Inflate(System.Int32,System.Int32)">
            <summary>
Inflates rectangle by given width and height.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.ConstrainTo(IrrlichtLime.Core.Recti)">
            <summary>
Moves this rectangle to fit inside another one.
</summary>
            <returns>True on success, false if not possible.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.ClipAgainst(IrrlichtLime.Core.Recti)">
            <summary>
Clips this rectangle with another one.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.Adjust(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Moves each corner coordinate of the rectagle by given amount.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.AddInternalPoint(IrrlichtLime.Core.Vector2Di)">
            <summary>
Adds a point to the bounding rectangle.
Causes the rectangle to grow bigger if point is outside of the box.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.AddInternalPoint(System.Int32,System.Int32)">
            <summary>
Adds a point to the bounding rectangle.
Causes the rectangle to grow bigger if point is outside of the box.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.Repair">
            <summary>
If the lower right corner of the rect is smaller then the upper left, the points are swapped.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.#ctor(IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Dimension2Di)">
            <summary>
Constructor with upper left corner and dimension.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.#ctor(IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Vector2Di)">
            <summary>
Constructor with two corners.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Constructor with two corners.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.#ctor">
            <summary>
Default constructor creating empty rectangle at (0, 0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.op_Subtraction(IrrlichtLime.Core.Recti,IrrlichtLime.Core.Vector2Di)">
            <summary>
Subtract one rectangle from another.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.op_Addition(IrrlichtLime.Core.Recti,IrrlichtLime.Core.Vector2Di)">
            <summary>
Add two rectangles.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.op_Inequality(IrrlichtLime.Core.Recti,IrrlichtLime.Core.Recti)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Recti.op_Equality(IrrlichtLime.Core.Recti,IrrlichtLime.Core.Recti)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Recti">
            <summary>
Rectangle template.
Mostly used by 2D GUI elements and for 2D drawing methods.
It has 2 positions instead of position and dimension and a fast method for collision detection with other rectangles and points.
Coordinates are (0,0) for top-left corner, and increasing to the right and to the bottom.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Dimension2Df">
            <summary>
Specifies a 2 dimensional size.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Dimension2Di.Height">
            <summary>
Height of the dimension.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Dimension2Di.Width">
            <summary>
Width of the dimension.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Dimension2Di.Area">
            <summary>
Area of the dimension (width x height).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.Inflate(System.Int32,System.Int32)">
            <summary>
Inflates width and height by given values.
</summary>
            <param name="width">Value to inflate width by.</param>
            <param name="height">Value to inflate height by.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize">
            <summary>
Get the optimal size according to some properties.
This function often used for texture dimension calculations.
The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n, 2^m) and/or square (Width = Height).
</summary>
            <returns>The optimal dimension under the given constraints.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean)">
            <summary>
Get the optimal size according to some properties.
This function often used for texture dimension calculations.
The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n, 2^m) and/or square (Width = Height).
</summary>
            <param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default is true.</param>
            <returns>The optimal dimension under the given constraints.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean,System.Boolean)">
            <summary>
Get the optimal size according to some properties.
This function often used for texture dimension calculations.
The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n, 2^m) and/or square (Width = Height).
</summary>
            <param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default is true.</param>
            <param name="requireSquare">Makes width == height in the result. Default is false.</param>
            <returns>The optimal dimension under the given constraints.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Get the optimal size according to some properties.
This function often used for texture dimension calculations.
The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n, 2^m) and/or square (Width = Height).
</summary>
            <param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default is true.</param>
            <param name="requireSquare">Makes width == height in the result. Default is false.</param>
            <param name="larger">Choose whether the result is larger or smaller than the current dimension.
If one dimension need not be changed it is kept with any value of larger. Default is true.</param>
            <returns>The optimal dimension under the given constraints.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean,System.Boolean,System.Boolean,System.UInt32)">
            <summary>
Get the optimal size according to some properties.
This function often used for texture dimension calculations.
The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n, 2^m) and/or square (Width = Height).
</summary>
            <param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default is true.</param>
            <param name="requireSquare">Makes width == height in the result. Default is false.</param>
            <param name="larger">Choose whether the result is larger or smaller than the current dimension.
If one dimension need not be changed it is kept with any value of larger. Default is true.</param>
            <param name="maxValue">Maximum texturesize. If value &gt; 0 size is clamped to maxValue. Default is 0.</param>
            <returns>The optimal dimension under the given constraints.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.GetInterpolated(IrrlichtLime.Core.Dimension2Di,System.Single)">
            <summary>
Get the interpolated dimension.
</summary>
            <param name="other">Other dimension to interpolate with.</param>
            <param name="d">Value between 0.0f and 1.0f. d=0 returns other, d=1 returns this, values between interpolate.</param>
            <returns>Interpolated dimension.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.Set(System.Int32,System.Int32)">
            <summary>
Sets this dimension to new values.
</summary>
            <param name="width">New width.</param>
            <param name="height">New height.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.Set(IrrlichtLime.Core.Dimension2Di)">
            <summary>
Sets this dimension to a new dimension.
</summary>
            <param name="copy">Other dimension.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.#ctor(System.Int32,System.Int32)">
            <summary>
Constructor with width and height.
</summary>
            <param name="width">Width value.</param>
            <param name="height">Height value.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.#ctor(System.Int32)">
            <summary>
Constructor with same width and height.
</summary>
            <param name="widthAndHeight">Value for width and height.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.#ctor(IrrlichtLime.Core.Dimension2Di)">
            <summary>
Copy constructor.
</summary>
            <param name="copy">Other dimension.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.#ctor">
            <summary>
Default constructor.
Initializes empty dimension (0x0).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.op_Division(IrrlichtLime.Core.Dimension2Di,System.Int32)">
            <summary>
Divide width and height by scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.op_Multiply(IrrlichtLime.Core.Dimension2Di,System.Int32)">
            <summary>
Multiply width and height by scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.op_Subtraction(IrrlichtLime.Core.Dimension2Di,IrrlichtLime.Core.Dimension2Di)">
            <summary>
Subtract one dimension from another.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.op_Addition(IrrlichtLime.Core.Dimension2Di,IrrlichtLime.Core.Dimension2Di)">
            <summary>
Add two dimensions.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.op_Inequality(IrrlichtLime.Core.Dimension2Di,IrrlichtLime.Core.Dimension2Di)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Dimension2Di.op_Equality(IrrlichtLime.Core.Dimension2Di,IrrlichtLime.Core.Dimension2Di)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Dimension2Di">
            <summary>
Specifies a 2 dimensional size.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.ColorHSL.Saturation">
            <summary>
Saturation component of the color. Value in range [0,100].
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.ColorHSL.Luminance">
            <summary>
Luminance component of the color. Value in range [0,100].
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.ColorHSL.Hue">
            <summary>
Hue component of the color. Value in range [0,360].
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.ToColorf">
            <summary>
Returns color represented via four floats.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.ToColor">
            <summary>
Returns 32 bit integer color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.Set(System.Single,System.Single,System.Single)">
            <summary>
Set this color from specified hue, saturation and luminance values.
</summary>
            <param name="hue">Hue component in range [0,360].</param>
            <param name="saturation">Saturation component in range [0,100].</param>
            <param name="luminance">Luminance component in range [0,100].</param>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.Set(IrrlichtLime.Video.Colorf)">
            <summary>
Set this color from another Colorf.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.Set(IrrlichtLime.Video.Color)">
            <summary>
Set this color from another 32 bit Color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.Set(IrrlichtLime.Video.ColorHSL)">
            <summary>
Set this color from another ColorHSL.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructs a color from specified hue, saturation and luminance values.
</summary>
            <param name="hue">Hue component in range [0,360].</param>
            <param name="saturation">Saturation component in range [0,100].</param>
            <param name="luminance">Luminance component in range [0,100].</param>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.#ctor(IrrlichtLime.Video.Colorf)">
            <summary>
Constructs a color from Colorf.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.#ctor(IrrlichtLime.Video.Color)">
            <summary>
Constructs a color from 32 bit Color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.#ctor(IrrlichtLime.Video.ColorHSL)">
            <summary>
Copy constructor.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.#ctor">
            <summary>
Default constructor.
Sets hue, saturation and luminance to 0.0f.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.op_Inequality(IrrlichtLime.Video.ColorHSL,IrrlichtLime.Video.ColorHSL)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.ColorHSL.op_Equality(IrrlichtLime.Video.ColorHSL,IrrlichtLime.Video.ColorHSL)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.ColorHSL">
            <summary>
Class representing a color in HSL format.
The color values for hue, saturation and luminance are stored in 32 bit floating point variables.
Hue is in range [0,360], Luminance and Saturation are in percent [0,100].
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Colorf.Red">
            <summary>
The red component of the color.
Value between 0.0f and 1.0f.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Colorf.Green">
            <summary>
The green component of the color.
Value between 0.0f and 1.0f.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Colorf.Blue">
            <summary>
The blue component of the color.
Value between 0.0f and 1.0f.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Colorf.Alpha">
            <summary>
The alpha component of the color.
This component defines how opaque a color is: 0.0f is fully transparent, 1.0f is fully opaque.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.ToColor">
            <summary>
Returns 32 bit integer color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.ToArray">
            <summary>
Returns this color as array of four floats.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.GetInterpolatedQuadratic(IrrlichtLime.Video.Colorf,IrrlichtLime.Video.Colorf,System.Single)">
            <summary>
Quadratic color interpolation.
</summary>
            <param name="c1">First color to interpolate with.</param>
            <param name="c2">Second color to interpolate with.</param>
            <param name="d">Value between 0.0f and 1.0f.</param>
            <returns>Interpolated (quadratic) color.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.GetInterpolated(IrrlichtLime.Video.Colorf,System.Single)">
            <summary>
Interpolates this color to another color.
</summary>
            <param name="other">Other color.</param>
            <param name="d">Value between 0.0f and 1.0f. d=0 returns other, d=1 returns this, values between interpolate.</param>
            <returns>Interpolated color.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.Set(System.Single,System.Single,System.Single)">
            <summary>
Set this color from values representing red, green and blue component.
Must be values between 0.0f and 1.0f.
Alpha component left unchanged.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.Set(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Set this color from values representing red, green, blue and alpha component.
Must be values between 0.0f and 1.0f.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.Set(IrrlichtLime.Video.Color)">
            <summary>
Set this color from another color (32 bit integer).
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.Set(IrrlichtLime.Video.Colorf)">
            <summary>
Set this color from another color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructs a color from up to four color values: red, green, blue, and alpha.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs a color from up to four color values: red, green, blue, and alpha.
</summary>
            <param name="a">Alpha component. Default is 1.0f.</param>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.#ctor(IrrlichtLime.Video.Color)">
            <summary>
Constructs a color from 32 bit Color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.#ctor(IrrlichtLime.Video.Colorf)">
            <summary>
Copy constructor.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.#ctor">
            <summary>
Default constructor.
Sets red, green and blue to 0.0f and alpha to 1.0f.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.op_Inequality(IrrlichtLime.Video.Colorf,IrrlichtLime.Video.Colorf)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Colorf.op_Equality(IrrlichtLime.Video.Colorf,IrrlichtLime.Video.Colorf)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.Colorf">
            <summary>
Class representing a color with four floats.
The color values for red, green, blue and alpha are each stored in a 32 bit floating point variable.
So all four values may be between 0.0f and 1.0f.
Another, faster way to define colors is using the class Color, which stores the color values in a single 32 bit integer.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.Red">
            <summary>
The red component of the color.
Value between 0 and 255, specifying how red the color is.
0 means no red, 255 means full red.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.Luminance">
            <summary>
Luminance of the color in the range [0,255].
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.Lightness">
            <summary>
Lightness of the color in the range [0,255].
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.Green">
            <summary>
The green component of the color.
Value between 0 and 255, specifying how green the color is.
0 means no green, 255 means full green.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.Blue">
            <summary>
The blue component of the color.
Value between 0 and 255, specifying how blue the color is.
0 means no blue, 255 means full blue.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.Average">
            <summary>
Average intensity of the color in the range [0,255].
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.ARGB">
            <summary>
Color in A8R8G8B8 Format.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.Alpha">
            <summary>
The alpha component of the color.
This component defines how opaque a color is: 0 is fully transparent, 255 is fully opaque.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.A1R5G5B5">
            <summary>
16 bit A1R5G5B5 value of this color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.GetInterpolatedQuadratic(IrrlichtLime.Video.Color,IrrlichtLime.Video.Color,System.Single)">
            <summary>
Quadratic color interpolation.
</summary>
            <param name="c1">First color to interpolate with.</param>
            <param name="c2">Second color to interpolate with.</param>
            <param name="d">Value between 0.0f and 1.0f.</param>
            <returns>Interpolated (quadratic) color.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.Color.GetInterpolated(IrrlichtLime.Video.Color,System.Single)">
            <summary>
Interpolates this color to another color.
</summary>
            <param name="other">Other color.</param>
            <param name="d">Value between 0.0f and 1.0f. d=0 returns other, d=1 returns this, values between interpolate.</param>
            <returns>Interpolated color.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.Color.Set(System.UInt32)">
            <summary>
Set this color from a 32 bit value.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.Set(System.Int32,System.Int32,System.Int32)">
            <summary>
Set this color from values representing red, green, blue and alpha component.
Must be values between 0 and 255.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.Set(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Set this color from values representing red, green, blue and alpha component.
Must be values between 0 and 255.
</summary>
            <param name="a">Alpha component. Default is 255.</param>
        </member>
        <member name="M:IrrlichtLime.Video.Color.Set(IrrlichtLime.Video.Color)">
            <summary>
Set this color from another color.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
Constructs the color from values representing red, green, blue and alpha component.
Must be values between 0 and 255.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Constructs the color from values representing red, green, blue and alpha component.
Must be values between 0 and 255.
</summary>
            <param name="a">Alpha component. Default is 255.</param>
        </member>
        <member name="M:IrrlichtLime.Video.Color.#ctor(System.UInt32)">
            <summary>
Constructs the color from a 32 bit value.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.#ctor(IrrlichtLime.Video.Color)">
            <summary>
Copy constructor.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.#ctor">
            <summary>
Default constructor.
Does nothing. The color value is not initialized to save time.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.op_Inequality(IrrlichtLime.Video.Color,IrrlichtLime.Video.Color)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Color.op_Equality(IrrlichtLime.Video.Color,IrrlichtLime.Video.Color)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidYellow">
            <summary>
Fully opaque yellow color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidWhite">
            <summary>
Fully opaque white color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidRed">
            <summary>
Fully opaque red color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidMagenta">
            <summary>
Fully opaque magenta color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidGreen">
            <summary>
Fully opaque green color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidCyan">
            <summary>
Fully opaque cyan color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidBlue">
            <summary>
Fully opaque blue color.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Color.SolidBlack">
            <summary>
Fully opaque black color.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.Color">
            <summary>
Class representing a 32 bit ARGB color.
The color values for alpha, red, green, and blue are stored in a single 32 bit unsigned int.
So all four values may be between 0 and 255.
Alpha in Irrlicht is opacity, so 0 is fully transparent, 255 is fully opaque (solid).
This class is used by most parts of the Irrlicht Engine to specify a color.
Another way is using the class SColorf, which stores the color values in 4 floats.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.Volume">
            <summary>
Volume enclosed by the box in cubed units.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.Radius">
            <summary>
Radius of the bounding sphere.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.MinEdge">
            <summary>
The near edge.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.MaxEdge">
            <summary>
The far edge.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.IsValid">
            <summary>
Check if MaxEdge &gt; MinEdge.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.IsEmpty">
            <summary>
Check if the box is empty.
This means that there is no space between the min and max edge.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.Extent">
            <summary>
Extent of the box (maximal distance of two points in the box).
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.Edges">
            <summary>
All 8 edges of the bounding box.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.Center">
            <summary>
Center of the bounding box.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.AABBox.Area">
            <summary>
Surface area of the box in squared units.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.Repair">
            <summary>
Repairs the box.
Necessary if for example MinEdge and MaxEdge are swapped.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.IsInside(IrrlichtLime.Core.AABBox)">
            <summary>
Check if this box is completely inside given bounding box.
Border is excluded (NOT part of the box)!
</summary>
            <param name="b">Other box to check against.</param>
            <returns>True if this box is completely inside the other box, otherwise false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.IsInsideFully(IrrlichtLime.Core.Vector3Df)">
            <summary>
Determines if a point is within this box and not its borders.
Border is excluded (NOT part of the box)!
</summary>
            <param name="p">Point to check.</param>
            <returns>True if the point is within the box and false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.IsInside(IrrlichtLime.Core.Vector3Df)">
            <summary>
Determines if a point is within this box.
Border is included (IS part of the box)!
</summary>
            <param name="p">Point to check.</param>
            <returns>True if the point is within the box and false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.IntersectsWithLine(IrrlichtLime.Core.Line3Df)">
            <summary>
Tests if the box intersects with a line.
</summary>
            <param name="line">Line to test intersection with.</param>
            <returns>True if there is an intersection, else false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.IntersectsWithBox(IrrlichtLime.Core.AABBox)">
            <summary>
Determines if the axis-aligned box intersects with another axis-aligned box.
</summary>
            <param name="other">Other box to check a intersection with.</param>
            <returns>True if there is an intersection with the other box, otherwise false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.Intersect(IrrlichtLime.Core.AABBox)">
            <summary>
Returns the intersection of this box with another, if possible.
</summary>
            <param name="other">Other bounding box.</param>
            <returns>AABBox if there is an intersection and null if no intersection.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.AddInternalBox(IrrlichtLime.Core.AABBox)">
            <summary>
Adds another bounding box.
The box grows bigger, if the new box was outside of the box.
</summary>
            <param name="b">Other bounding box to add into this box.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.AddInternalPoint(IrrlichtLime.Core.Vector3Df)">
            <summary>
Adds a point to the bounding box.
The box grows bigger, if point was outside of the box.
</summary>
            <param name="p">Point to add into the box.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.AddInternalPoint(System.Single,System.Single,System.Single)">
            <summary>
Adds a point to the bounding box.
The box grows bigger, if point was outside of the box.
</summary>
            <param name="x">X coordinate of the point to add to this box.</param>
            <param name="y">Y coordinate of the point to add to this box.</param>
            <param name="z">Z coordinate of the point to add to this box.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.Set(IrrlichtLime.Core.AABBox)">
            <summary>
Sets the bounding box to new bounding box.
</summary>
            <param name="newBox">New box to set this one to.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.Set(IrrlichtLime.Core.Vector3Df)">
            <summary>
Sets the bounding box to a one-point box.
</summary>
            <param name="newPoint">The point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.Set(System.Single,System.Single,System.Single)">
            <summary>
Sets the bounding box to a one-point box.
</summary>
            <param name="x">X coord of the point.</param>
            <param name="y">Y coord of the point.</param>
            <param name="z">Z coord of the point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Sets new values for min edge and max edge.
</summary>
            <param name="min">New value for min edge point.</param>
            <param name="max">New value for max edge point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.Set(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Sets new values for min edge and max edge.
</summary>
            <param name="minx">Min edge X coord.</param>
            <param name="miny">Min edge Y coord.</param>
            <param name="minz">Min edge Z coord.</param>
            <param name="maxx">Max edge X coord.</param>
            <param name="maxy">Max edge Y coord.</param>
            <param name="maxz">Max edge Z coord.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.#ctor(IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor with only one point.
</summary>
            <param name="point">The point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor with min edge and max edge.
</summary>
            <param name="min">Min edge point.</param>
            <param name="max">Max edge point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructor with only one point.
</summary>
            <param name="x">X coord of the point.</param>
            <param name="y">Y coord of the point.</param>
            <param name="z">Z coord of the point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructor with min edge and max edge.
</summary>
            <param name="minx">Min edge X coord.</param>
            <param name="miny">Min edge Y coord.</param>
            <param name="minz">Min edge Z coord.</param>
            <param name="maxx">Max edge X coord.</param>
            <param name="maxy">Max edge Y coord.</param>
            <param name="maxz">Max edge Z coord.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.#ctor(IrrlichtLime.Core.AABBox)">
            <summary>
Copy constructor.
</summary>
            <param name="copy">Other bouding box.</param>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.#ctor">
            <summary>
Default constructor.
Initializes MinEdge with (-1,-1,-1) and MaxEdge with (1,1,1).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.op_Inequality(IrrlichtLime.Core.AABBox,IrrlichtLime.Core.AABBox)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.AABBox.op_Equality(IrrlichtLime.Core.AABBox,IrrlichtLime.Core.AABBox)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.AABBox">
            <summary>
Axis aligned bounding box in 3d dimensional space.
Has some useful methods used with occlusion culling or clipping.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Line3Df.End">
            <summary>
End point of line.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Line3Df.Start">
            <summary>
Start point of line.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Line3Df.Vector">
            <summary>
Vector of line.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Line3Df.Middle">
            <summary>
Center of line.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Line3Df.LengthSQ">
            <summary>
Squared length of line.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Line3Df.Length">
            <summary>
Length of line.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.GetIntersectionWithSphere(IrrlichtLime.Core.Vector3Df,System.Single,System.Double@)">
            <summary>
Check if the line intersects with a sphere.
</summary>
            <param name="sphereOrigin">Origin of the sphere.</param>
            <param name="sphereRadius">Radius of the sphere.</param>
            <param name="distance">The distance to the first intersection point.</param>
            <returns>True if there is an intersection. If there is one, the distance to the first intersection point is stored in "distance".</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.GetClosestPoint(IrrlichtLime.Core.Vector3Df)">
            <summary>
Get the closest point on this line to a point.
</summary>
            <param name="point">The point to compare to.</param>
            <returns>The nearest point which is part of the line.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.IsPointBetweenStartAndEnd(IrrlichtLime.Core.Vector3Df)">
            <summary>
Check if the given point is between start and end of the line.
Assumes that the point is already somewhere on the line.
</summary>
            <param name="point">The point to test.</param>
            <returns>True if point is on the line between start and end, else false.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.Set(IrrlichtLime.Core.Line3Df)">
            <summary>
Set this line to a new line.
</summary>
            <param name="newLine">New line.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Set this line to a new line going through the two points.
</summary>
            <param name="start">Start point.</param>
            <param name="end">End point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.Set(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Set this line to a new line going through the two points.
</summary>
            <param name="startX">Start X coord.</param>
            <param name="startY">Start Y coord.</param>
            <param name="startZ">Start Z coord.</param>
            <param name="endX">End X coord.</param>
            <param name="endY">End Y coord.</param>
            <param name="endZ">End Z coord.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
            <summary>
Constructor with two points.
</summary>
            <param name="start">Start point.</param>
            <param name="end">End point.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructor with two points.
</summary>
            <param name="startX">Start X coord.</param>
            <param name="startY">Start Y coord.</param>
            <param name="startZ">Start Z coord.</param>
            <param name="endX">End X coord.</param>
            <param name="endY">End Y coord.</param>
            <param name="endZ">End Z coord.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.#ctor(IrrlichtLime.Core.Line3Df)">
            <summary>
Copy constructor.
</summary>
            <param name="copy">Other line.</param>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.#ctor">
            <summary>
Default constructor.
Initializes line from (0,0,0) to (1,1,1).
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.op_Inequality(IrrlichtLime.Core.Line3Df,IrrlichtLime.Core.Line3Df)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Line3Df.op_Equality(IrrlichtLime.Core.Line3Df,IrrlichtLime.Core.Line3Df)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Line3Df">
            <summary>
3D line between two points with intersection methods.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector3Df.Z">
            <summary>
Z coordinate of the vector.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector3Df.SphericalCoordinateAngles">
            <summary>
The spherical coordinate angles.
This returns Euler degrees for the point represented by this vector.
The calculation assumes the pole at (0, 1, 0) and returns the angles in X and Y.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector3Df.Length">
            <summary>
The length of the vector.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector3Df.HorizontalAngle">
            <summary>
The rotations that would make a (0,0,1) direction vector point in the same direction as this direction vector.
Thanks to Arras on the Irrlicht forums for this method. This utility method is very useful for orienting scene nodes towards specific targets.
For example, if this vector represents the difference between two scene nodes, then applying the result of this property to one scene node
will point it at the other one.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotationToDirection">
            <summary>
Builds a direction vector from (this) rotation vector.
This vector is assumed to be a rotation vector composed of 3 Euler angle rotations, in degrees.
The implementation performs the same calculations as using a matrix to do the rotation.
</summary>
            <returns>A direction vector calculated by rotating the forwards direction by the 3 Euler angles (in degrees) represented by this vector.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotationToDirection(IrrlichtLime.Core.Vector3Df)">
            <summary>
Builds a direction vector from (this) rotation vector.
This vector is assumed to be a rotation vector composed of 3 Euler angle rotations, in degrees.
The implementation performs the same calculations as using a matrix to do the rotation.
</summary>
            <param name="forwards">The direction representing "forwards" which will be rotated by this vector. Default is (0,0,1).</param>
            <returns>A direction vector calculated by rotating the forwards direction by the 3 Euler angles (in degrees) represented by this vector.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotateYZby(System.Double)">
            <summary>
Rotates this vector by a specified number of degrees around the X axis and the specified center.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotateYZby(System.Double,IrrlichtLime.Core.Vector3Df)">
            <summary>
Rotates this vector by a specified number of degrees around the X axis and the specified center.
</summary>
            <param name="center">The center of the rotation. Default is (0,0,0).</param>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotateXZby(System.Double)">
            <summary>
Rotates this vector by a specified number of degrees around the Y axis and the specified center.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotateXZby(System.Double,IrrlichtLime.Core.Vector3Df)">
            <summary>
Rotates this vector by a specified number of degrees around the Y axis and the specified center.
</summary>
            <param name="center">The center of the rotation. Default is (0,0,0).</param>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotateXYby(System.Double)">
            <summary>
Rotates this vector by a specified number of degrees around the Z axis and the specified center.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.RotateXYby(System.Double,IrrlichtLime.Core.Vector3Df)">
            <summary>
Rotates this vector by a specified number of degrees around the Z axis and the specified center.
</summary>
            <param name="center">The center of the rotation. Default is (0,0,0).</param>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.Invert">
            <summary>
Inverts this vector.
</summary>
            <returns>This vector after inversion.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.ToArrayOf4">
            <summary>
Fills an array of 4 values with the vector data.
Useful for setting in shader constants for example. The fourth value will always be 0.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.ToArrayOf3">
            <summary>
Fills an array of 3 values with the vector data.
Useful for setting in shader constants for example.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.EqualsTo(IrrlichtLime.Core.Vector3Df,System.Single)">
            <summary>
Check if this vector equals the other one, taking floating point rounding errors into account.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.CrossProduct(IrrlichtLime.Core.Vector3Df)">
            <summary>
Calculates the cross product with another vector.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.Set(System.Single,System.Single,System.Single)">
            <summary>
Set this vector by three scalars.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector3Df.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructor with three scalars.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Vector3Df">
            <summary>
3d vector class with lots of operators and methods.
This class is used in Irrlicht for three main purposes:
1) As a direction vector (most of the methods assume this).
2) As a position in 3d space (which is synonymous with a direction vector from the origin to this position).
3) To hold three Euler rotations, where X is pitch, Y is yaw and Z is roll.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector2Df.Length">
            <summary>
The length of the vector.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector2Df.AngleTrig">
            <summary>
The angle of this vector in degrees in the trigonometric sense.
0 is to the right (3 o'clock), values increase counter-clockwise.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector2Df.Angle">
            <summary>
The angle of this vector in degrees in the counter trigonometric sense.
0 is to the right (3 o'clock), values increase clockwise.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.RotateBy(System.Double)">
            <summary>
Rotates the point anticlockwise around a center by an amount of degrees.
</summary>
            <returns>This vector after transformation.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.RotateBy(System.Double,IrrlichtLime.Core.Vector2Df)">
            <summary>
Rotates the point anticlockwise around a center by an amount of degrees.
</summary>
            <param name="center">The center of the rotation. Default is (0,0).</param>
            <returns>This vector after transformation.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.GetAngleWith(IrrlichtLime.Core.Vector2Df)">
            <summary>
Calculates the angle between this vector and another one in degree.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.Set(System.Single,System.Single)">
            <summary>
Set this vector by two scalars.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.#ctor(System.Single,System.Single)">
            <summary>
Constructor with two scalars.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector2Df.Y">
            <summary>
Y coordinate of the vector.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector2Df.X">
            <summary>
X coordinate of the vector.
</summary>
        </member>
        <member name="P:IrrlichtLime.Core.Vector2Df.LengthSQ">
            <summary>
Squared length of the vector.
This is useful because it is much faster than <c>Length</c>.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.Normalize">
            <summary>
Normalizes the vector.
In case of the 0 vector the result is still 0, otherwise the length of the vector will be 1.
</summary>
            <returns>This vector after normalization.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.IsBetweenPoints(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Check if this vector interpreted as a point is on a line between two other points.
It is assumed that the point is on the line.
</summary>
            <param name="begin">Beginning vector to compare between.</param>
            <param name="end">Ending vector to compare between.</param>
            <returns>True if this vector is between begin and end, false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.Interpolate(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df,System.Double)">
            <summary>
Sets this vector to the linearly interpolated vector between a and b.
</summary>
            <param name="a">First vector to interpolate with, maximum at 1.0f.</param>
            <param name="b">Second vector to interpolate with, maximum at 0.0f.</param>
            <param name="d">Interpolation value between 0.0f (all vector b) and 1.0f (all vector a).
Note that this is the opposite direction of interpolation to <c>GetInterpolatedQuadratic()</c>.</param>
            <returns>This vector.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.GetInterpolatedQuadratic(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df,System.Double)">
            <summary>
Creates a quadratically interpolated vector between this and two other vectors.
</summary>
            <param name="v2">Second vector to interpolate with.</param>
            <param name="v3">Third vector to interpolate with (maximum at 1.0f).</param>
            <param name="d">Interpolation value between 0.0f (all this vector) and 1.0f (all the 3rd vector).
Note that this is the opposite direction of interpolation to <c>GetInterpolatedQuadratic()</c> and <c>Interpolate()</c>.</param>
            <returns>An interpolated vector. This vector is not modified.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.GetInterpolated(IrrlichtLime.Core.Vector2Df,System.Double)">
            <summary>
Creates an interpolated vector between this vector and another vector.
</summary>
            <param name="other">The other vector to interpolate with.</param>
            <param name="d">Interpolation value between 0.0f (all the other vector) and 1.0f (all this vector).
Note that this is the opposite direction of interpolation to <c>GetInterpolatedQuadratic()</c>.</param>
            <returns>An interpolated vector. This vector is not modified.</returns>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.GetDistanceFromSQ(IrrlichtLime.Core.Vector2Df)">
            <summary>
Get squared distance from another point.
Here, the vector is interpreted as point in space.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.GetDistanceFrom(IrrlichtLime.Core.Vector2Df)">
            <summary>
Get distance from another point.
Here, the vector is interpreted as point in space.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.EqualsTo(IrrlichtLime.Core.Vector2Df)">
            <summary>
Check if this vector equals the other one, taking floating point rounding errors into account.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.DotProduct(IrrlichtLime.Core.Vector2Df)">
            <summary>
Get the dot product with another vector.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.Set(IrrlichtLime.Core.Vector2Df)">
            <summary>
Set this vector to another one.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.#ctor">
            <summary>
Default constructor. Set all components to 0.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.#ctor(System.Single)">
            <summary>
Construct vector with all component same.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.#ctor(IrrlichtLime.Core.Vector2Df)">
            <summary>
Copy constructor.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Division(IrrlichtLime.Core.Vector2Df,System.Single)">
            <summary>
Divide vector and scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Division(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Divide two vectors.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Multiply(IrrlichtLime.Core.Vector2Df,System.Single)">
            <summary>
Multiple vector and scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Multiply(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Multiple two vectors.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Subtraction(IrrlichtLime.Core.Vector2Df,System.Single)">
            <summary>
Subtract vector and scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Subtraction(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Subtract two vectors.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Addition(IrrlichtLime.Core.Vector2Df,System.Single)">
            <summary>
Add vector and scalar.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Addition(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Add two vectors.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_LessThanOrEqual(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
&lt;= operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_LessThan(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
&lt; operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_GreaterThanOrEqual(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
&gt;= operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_GreaterThan(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
&gt; operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Inequality(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Inequality operator.
</summary>
        </member>
        <member name="M:IrrlichtLime.Core.Vector2Df.op_Equality(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
            <summary>
Equality operator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Core.Vector2Df">
            <summary>
2d vector class with lots of operators and methods.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.VideoModeAspectRatio">
            <summary>
Video aspect ratios.
Use <c>VideoMode.GetAspectRatio()</c> to get the value.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoModeAspectRatio._16x10">
            <summary>
16x10 aspect ratio.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoModeAspectRatio._16x9">
            <summary>
16x9 aspect ratio.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoModeAspectRatio._5x4">
            <summary>
5x4 aspect ratio.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoModeAspectRatio._5x3">
            <summary>
5x3 aspect ratio.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoModeAspectRatio._4x3">
            <summary>
4x3 aspect ratio.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoModeAspectRatio._3x2">
            <summary>
3x2 aspect ratio.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoModeAspectRatio.Other">
            <summary>
Other aspect ratio.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.VideoDriverFeature">
            <summary>
Enumeration for querying features of the video driver.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureCubemapSeamless">
            <summary>
Support for filtering across different faces of the cubemap.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureCubemap">
            <summary>
Support for cube map textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureCompressedETC2">
            <summary>
Support for ETC2 compressed textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureCompressedETC1">
            <summary>
Support for ETC1 compressed textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureCompressedPVRTC2">
            <summary>
Support for PVRTC2 compressed textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureCompressedPVRTC">
            <summary>
Support for PVRTC compressed textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureCompressedDXT">
            <summary>
Support for DXTn compressed textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureMatrix">
            <summary>
Support for texture coord transformation via texture matrix.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.BlendSeparate">
            <summary>
Support for separate blending for RGB and Alpha.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.BlendOperations">
            <summary>
Support for different blend functions. Without, only ADD is available.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.PolygonOffset">
            <summary>
Supports polygon offset/depth bias for avoiding z-fighting.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.OcclusionQuery">
            <summary>
Supports occlusion queries.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.GeomertyShader">
            <summary>
Supports geometry shaders.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.MRT_BlendFunc">
            <summary>
Supports separate blend functions for multiple render targets.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.MRT_ColorMask">
            <summary>
Supports separate color masks for multiple render targets.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.MRT_Blend">
            <summary>
Supports separate blend settings for multiple render targets.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.MultipleRenderTargets">
            <summary>
Supports multiple render targets at once.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.ColorMask">
            <summary>
Supports Color masks (disabling color planes in output).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.AlphaToCoverage">
            <summary>
Supports Alpha To Coverage.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexBufferObject">
            <summary>
Are vertex buffer objects supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.FrameBufferObject">
            <summary>
Are frame buffer objects supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureNonPOT">
            <summary>
Are non-power-of-two textures supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureNonSquare">
            <summary>
Are non-square textures supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.HLSL">
            <summary>
Is HLSL supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.ARB_GLSL">
            <summary>
Is GLSL supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.ARB_FragmentProgram_1">
            <summary>
Are ARB fragment programs 1.0 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.ARB_VertexProgram_1">
            <summary>
Are ARB vertex programs 1.0 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_3_0">
            <summary>
Is Pixel Shader 3.0 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_2_0">
            <summary>
Is Pixel Shader 2.0 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_4">
            <summary>
Is Pixel Shader 1.4 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_3">
            <summary>
Is Pixel Shader 1.3 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_2">
            <summary>
Is Pixel Shader 1.2 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_1">
            <summary>
Is Pixel Shader 1.1 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexShader_3_0">
            <summary>
Is Vertex Shader 3.0 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexShader_2_0">
            <summary>
Is Vertex Shader 2.0 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexShader_1_1">
            <summary>
Is Vertex Shader 1.1 supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.StencilBuffer">
            <summary>
Are stencil buffers switched on and does the device support stencil buffers?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.MipmapAutoUpdate">
            <summary>
Can the driver update mip maps automatically?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.Mipmap">
            <summary>
Can the driver handle mip maps?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.BilinearFilter">
            <summary>
Is driver able to render with a bilinear filter applied?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.Multitexture">
            <summary>
Are multiple textures per material possible?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.HardwareTL">
            <summary>
Is hardware transform and lighting supported?
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VideoDriverFeature.RenderToTarget">
            <summary>
Is driver able to render to a surface?
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.VertexType">
            <summary>
Enumeration for all vertex types there are.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexType.Tangents">
            <summary>
Vertex with a tangent and binormal vector (<c>Vertex3DTangents</c>).
Usually used for tangent space normal mapping.
Usually tangent and binormal get send to shaders as texture coordinate sets 1 and 2.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexType.TTCoords">
            <summary>
Vertex with two texture coordinates (<c>Vertex3DTTCoords</c>).
Usually used for geometry with lightmaps or other special materials.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexType.Standard">
            <summary>
Standard vertex type used by the Irrlicht engine (<c>Vertex3D</c>).
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.VertexShaderType">
            <summary>
Compile target enumeration for the <c>GPUProgrammingServices.AddHighLevelShaderMaterial()</c> method.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexShaderType.VS_5_0">
            <summary>
Vertex shader 5.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexShaderType.VS_4_1">
            <summary>
Vertex shader 4.1.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexShaderType.VS_4_0">
            <summary>
Vertex shader 4.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexShaderType.VS_3_0">
            <summary>
Vertex shader 3.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexShaderType.VS_2_a">
            <summary>
Vertex shader 2.0a.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexShaderType.VS_2_0">
            <summary>
Vertex shader 2.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.VertexShaderType.VS_1_1">
            <summary>
Vertex shader 1.1.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.TransformationState">
            <summary>
Enumeration for geometry transformation states.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture7">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture6">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture5">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture4">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture3">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture2">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture1">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Texture0">
            <summary>
Texture transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.Projection">
            <summary>
Projection transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.World">
            <summary>
World transformation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TransformationState.View">
            <summary>
View transformation.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.TextureLockMode">
            <summary>
Enumeration for the mode for texture locking.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureLockMode.WriteOnly">
            <summary>
Write only. The texture is not downloaded and might be uninitialized.
The updated texture is uploaded to the GPU.
Used for initializing the shader from the CPU.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureLockMode.ReadOnly">
            <summary>
Read only. The texture is downloaded, but not uploaded again.
Often used to read back shader generated textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureLockMode.ReadWrite">
            <summary>
The default mode. Texture can be read and written to.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.TextureCreationFlag">
            <summary>
Enumeration flags telling the video driver in which format textures should be created.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.AllowMemoryCopy">
            <summary>
Allow the driver to keep a copy of the texture in memory.
Enabling this makes calls to <c>TexturePainter.Lock()</c> a lot faster, but costs main memory.
Currently only used in combination with OpenGL drivers.
NOTE: Disabling this does not yet work correctly with alpha-textures. So the default is off for now
(but might change with Irrlicht 1.9 if we get the alpha-troubles fixed).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.AllowNonPower2">
            <summary>
Allow the Driver to use non-power-2 textures.
BurningVideo can handle non-power-2 textures in 2D (GUI), but not in 3D.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.NoAlphaChannel">
            <summary>
Discard any alpha layer and use non-alpha color format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.CreateMipMaps">
            <summary>
Automatically creates mip map levels for the textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.OptimizedForSpeed">
            <summary>
Lets the driver decide in which format the textures are created and tries to create them maximizing render speed.
When using this flag, it does not make sense to use the flags <c>Always16Bit</c>, <c>Always32Bit</c>, or <c>OptimizedForQuality</c> at the same time.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.OptimizedForQuality">
            <summary>
Lets the driver decide in which format the textures are created and tries to make the textures look as good as possible.
Usually it simply chooses the format in which the texture was stored on disk.
When using this flag, it does not make sense to use the flags <c>Always16Bit</c>, <c>Always32Bit</c>, or <c>OptimizedForSpeed</c> at the same time.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.Always32Bit">
            <summary>
Forces the driver to create 32 bit textures always, independent of which format the file on disk has.
Please note that some drivers (like the software device) will ignore this, because they are only able to create and use 16 bit textures.
When using this flag, it does not make sense to use the flags <c>Always16Bit</c>, <c>OptimizedForQuality</c>, or <c>OptimizedForSpeed</c> at the same time.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureCreationFlag.Always16Bit">
            <summary>
Forces the driver to create 16 bit textures always, independent of which format the file on disk has.
When choosing this you may lose some color detail, but gain much speed and memory.
16 bit textures can be transferred twice as fast as 32 bit textures and only use half of the space in memory.
When using this flag, it does not make sense to use the flags <c>Always32Bit</c>, <c>OptimizedForQuality</c>, or <c>OptimizedForSpeed</c> at the same time.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.TextureClamp">
            <summary>
Texture coord clamp mode outside [0.0, 1.0].
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.MirrorClampToBorder">
            <summary>
Texture is mirrored once and then clamped to border.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.MirrorClampToEdge">
            <summary>
Texture is mirrored once and then clamped to edge.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.MirrorClamp">
            <summary>
Texture is mirrored once and then clamped (0..1..0).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.Mirror">
            <summary>
Texture is alternatingly mirrored (0..1..0..1..0..).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.ClampToBorder">
            <summary>
Texture is clamped to the border pixel (if exists).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.ClampToEdge">
            <summary>
Texture is clamped to the edge pixel.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.Clamp">
            <summary>
Texture is clamped to the last pixel.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.TextureClamp.Repeat">
            <summary>
Texture repeats.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.TerrainPatchSize">
            <summary>
Enumeration for patch sizes specifying the size of patches in the <c>TerrainSceneNode</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.TerrainPatchSize._129">
            <summary>
Patch size of 129, at most, use 8 levels of detail with this patch size.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.TerrainPatchSize._65">
            <summary>
Patch size of 65, at most, use 7 levels of detail with this patch size.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.TerrainPatchSize._33">
            <summary>
Patch size of 33, at most, use 6 levels of detail with this patch size.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.TerrainPatchSize._17">
            <summary>
Patch size of 17, at most, use 5 levels of detail with this patch size.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.TerrainPatchSize._9">
            <summary>
Patch size of 9, at most, use 4 levels of detail with this patch size.
</summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.OBJ_TexturePath">
            <summary>
Deprecated. Was used for changing the texture path of the built-in obj loader
like this: <c>SceneManager.Attributes.SetValue(SceneParameters.OBJ_TexturePath, "path/to/your/textures");</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.OBJ_IgnoreMaterialFiles">
            <summary>
Flag to avoid loading material .mtl file for .obj files.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.OBJ_IgnoreMaterialFiles, true);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.OBJ_IgnoreGroups">
            <summary>
Flag to avoid loading group structures in .obj files.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.OBJ_IgnoreGroups, true);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.MY3D_TexturePath">
            <summary>
Deprecated. Was used for changing the texture path of the built-in MY3D loader
like this: <c>SceneManager.Attributes.SetValue(SceneParameters.MY3D_TexturePath, "path/to/your/textures");</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.LMTS_TexturePath">
            <summary>
Deprecated. Was used for changing the texture path of the built-in lmts loader
like this: <c>SceneManager.Attributes.SetValue(SceneParameters.LMTS_TexturePath, "path/to/your/textures");</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.IRR_Editor">
            <summary>
Flag set as parameter when the scene manager is used as editor.
In this way special animators like deletion animators can be stopped from deleting scene nodes for example.
</summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.DMF_TexturePath">
            <summary>
Deprecated. Was used to set path which will get prefixed to the file names defined in the Deled file when loading textures.
This allows to alter the paths for a specific project setting
like this: <c>SceneManager.Attributes.SetValue(SceneParameters.DMF_TexturePath, "path/to/your/textures");</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.DMF_IgnoreMaterialsDir">
            <summary>
The parameter for preserving DMF textures dir structure with built-in DMF loader.
If this parameter is set to true, the texture directory defined in the Deled file is ignored, and only the texture name is used to find the proper file.
Otherwise, the texture path is also used, which allows to use a nicer media layout. By default this parameter is false.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.DMF_IgnoreMaterialsDir, true);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.DMF_FlipAlphaTextures">
            <summary>
The parameter for choose to flip or not tga files.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.DMF_FlipAlphaTextures, true);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.DMF_AlphaChannelRef">
            <summary>
The parameter for setting reference value of alpha in transparent materials.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.DMF_AlphaChannelRef, 0.1f);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.DebugNormalLength">
            <summary>
The parameter for setting the length of debug normals.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.DebugNormalLength, 1.5f);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.DebugNormalColor">
            <summary>
The parameter for setting the color of debug normals.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.DebugNormalColor, new Color(255, 255, 255, 255));</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.CSM_TexturePath">
            <summary>
Deprecated. Was used for changing the texture path of the built-in csm loader
like this: <c>SceneManager.Attributes.SetValue(SceneParameters.CSM_TexturePath, "path/to/your/textures");</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.COLLADA_CreateSceneInstances">
            <summary>
The parameter specifying the COLLADA mesh loading mode.
Specifies if the COLLADA loader should create instances of the models, lights and cameras when loading COLLADA meshes.
By default, this is set to false. If this is set to true, the <c>SceneManager.GetMesh()</c> method will only return a pointer to a dummy mesh
and create instances of all meshes and lights and cameras in the collada file by itself.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.COLLADA_CreateSceneInstances, true);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.B3D_TexturePath">
            <summary>
Deprecated. Was used for changing the texture path of the built-in b3d loader
like this: <c>SceneManager.Attributes.SetValue(SceneParameters.B3D_TexturePath, "path/to/your/textures");</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.B3D_IgnoreMipmapFlag">
            <summary>
Flag to ignore the b3d file's mipmapping flag. Instead Irrlicht's texture creation flag is used.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.B3D_IgnoreMipmapFlag, true);</c></summary>
        </member>
        <member name="P:IrrlichtLime.Scene.SceneParameters.AllowZWriteOnTransparent">
            <summary>
Parameter for changing how Irrlicht handles the ZWrite flag for transparent (blending) materials.
The default behavior in Irrlicht is to disable writing to the z-buffer for all really transparent, i.e. blending materials.
This avoids problems with intersecting faces, but can also break renderings.
If transparent materials should use the <c>MaterialFlag.ZWrite</c> flag just as other material types use this attribute.
Use it like this: <c>SceneManager.Attributes.SetValue(SceneParameters.AllowZWriteOnTransparent, true);</c></summary>
        </member>
        <member name="T:IrrlichtLime.Scene.SceneParameters">
            <summary>
Scene parameters for modifying mesh loading etc.
Check <c>SceneManager.Attributes</c> for actual values. To set an attribute you need to do <c>SceneManager.Attributes.SetValue()</c>.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.SceneNodeType">
            <summary>
An enumeration for all types of built-in scene nodes.
A scene node type is represented by a four character code such as 'cube' or 'mesh' instead of simple numbers, to avoid name clashes with external scene nodes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Any">
            <summary>
Will match with any scene node when checking types.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Unknown">
            <summary>
Unknown scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Camera_FPS">
            <summary>
First person shooter camera.
Legacy, for loading version &lt;= 1.4.x .irr files.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Camera_Maya">
            <summary>
Maya camera scene node.
Legacy, for loading version &lt;= 1.4.x .irr files.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.VolumeLight">
            <summary>
Volume light scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Quake3_Model">
            <summary>
Quake3 model scene node (has tag to link to).
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Quake3_Shader">
            <summary>
Quake3 shader scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.ParticleSystem">
            <summary>
Particle system scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.AnimatedMesh">
            <summary>
Animated mesh scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Billboard">
            <summary>
Billboard scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Camera">
            <summary>
Camera scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.DummyTransformation">
            <summary>
Dummy transformation scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Empty">
            <summary>
Empty scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Light">
            <summary>
Light scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Mesh">
            <summary>
Mesh scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Octree">
            <summary>
Octree scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.ShadowVolume">
            <summary>
Shadow volume scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.SkyDome">
            <summary>
Sky dome scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.SkyBox">
            <summary>
Sky box scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Terrain">
            <summary>
Terrain scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.WaterSurface">
            <summary>
Water surface scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Text">
            <summary>
Text scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Sphere">
            <summary>
Sphere scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.Cube">
            <summary>
Simple cube scene node.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeType.SceneManager">
            <summary>
Type for <c>SceneManager</c> (note that <c>SceneManager</c> is not(!) a <c>SceneNode</c>).
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.SceneNodeRenderPass">
            <summary>
Enumeration for render passes.
A parameter passed to the <c>SceneManager.RegisterNodeForRendering()</c>, specifying when the node wants to be drawn in relation to the other nodes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.Shadow">
            <summary>
Drawn after the solid nodes, before the transparent nodes, the time for drawing shadow volumes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.TransparentEffect">
            <summary>
Transparent effect scene nodes, drawn after transparent nodes. They are sorted from back to front and drawn in that order.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.Transparent">
            <summary>
Transparent scene nodes, drawn after solid nodes. They are sorted from back to front and drawn in that order.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.Solid">
            <summary>
Solid scene nodes or special scene nodes without materials.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.Automatic">
            <summary>
All normal objects can use this for registering themselves.
<para>This value will never be returned by <c>SceneManager.SceneNodeRenderPass</c>.
The scene manager will determine by itself if an object is transparent or solid and register the object as <c>Transparent</c> or <c>Solid</c>
automatically if you call <c>SceneManager.RegisterNodeForRendering()</c> with this value (which is default).
Note that it will register the node only as ONE type. If your scene node has both solid and transparent material types register it twice
(one time as <c>Solid</c>, the other time as <c>Transparent</c>) and in the <c>SceneNode.Render()</c>
check <c>SceneManager.SceneNodeRenderPass</c> to find out the current render pass and render only the corresponding parts of the node.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.SkyBox">
            <summary>
This is used for sky boxes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.Light">
            <summary>
In this pass, lights are transformed into camera space and added to the driver.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.Camera">
            <summary>
Camera pass. The active view is set up here. The very first pass.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeRenderPass.None">
            <summary>
No pass currently active.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.SceneNodeAnimatorType">
            <summary>
An enumeration for all types of built-in scene node animators.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.Unknown">
            <summary>
Unknown scene node animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.CameraMaya">
            <summary>
Maya camera animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.CameraFPS">
            <summary>
FPS camera animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.CollisionResponse">
            <summary>
Collision response scene node animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.Deletion">
            <summary>
Deletion scene node animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.Texture">
            <summary>
Texture scene node animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.Rotation">
            <summary>
Rotation scene node animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.FollowSpline">
            <summary>
Follow spline scene node animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.FlyStraight">
            <summary>
Fly straight scene node animator.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.SceneNodeAnimatorType.FlyCircle">
            <summary>
Fly circle scene node animator.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.RenderTarget">
            <summary>
Special render targets, which usually map to dedicated hardware.
These render targets (besides <see cref="F:IrrlichtLime.Video.RenderTarget.FrameBuffer" /> and <see cref="F:IrrlichtLime.Video.RenderTarget.RenderTexture" />) need not be supported by gfx cards.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer4">
            <summary>
Auxiliary buffer 4.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer3">
            <summary>
Auxiliary buffer 3.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer2">
            <summary>
Auxiliary buffer 2.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer1">
            <summary>
Auxiliary buffer 1.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer0">
            <summary>
Auxiliary buffer 0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.StereoBothBuffers">
            <summary>
Render to both stereo buffers at once.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.StereoRightBuffer">
            <summary>
Render target is the right color buffer (left is the main buffer).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.StereoLeftBuffer">
            <summary>
Render target is the main color frame buffer.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.MultiRenderTextures">
            <summary>
Multi-Render target textures.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.RenderTexture">
            <summary>
Render target is a render texture.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.RenderTarget.FrameBuffer">
            <summary>
Render target is the main color frame buffer.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.PrimitiveType">
            <summary>
Enumeration for all primitive types there are.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.PointSprites">
            <summary>
The single vertices are expanded to quad billboards on the GPU.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.Polygon">
            <summary>
Just as <see cref="F:IrrlichtLime.Scene.PrimitiveType.LineLoop" />, but filled.
Not supported by Direct3D.
Deprecated with newer OpenGL drivers.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.Quads">
            <summary>
Every four vertices create a quad.
Not supported by Direct3D.
Deprecated with newer OpenGL drivers.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.QuadStrip">
            <summary>
After the first two vertices each further two vertices create a quad with the preceding two.
Not supported by Direct3D.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.Triangles">
            <summary>
Explicitly set all vertices for each triangle.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.TriangleFan">
            <summary>
After the first two vertices each vertex defines a new triangle.
All around the common first vertex.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.TriangleStrip">
            <summary>
After the first two vertices each vertex defines a new triangle.
Always the two last and the new one form a new triangle.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.Lines">
            <summary>
Every two vertices are connected creating n/2 lines.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.LineLoop">
            <summary>
Just as <see cref="F:IrrlichtLime.Scene.PrimitiveType.LineStrip" />, but the last and the first vertex is also connected.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.LineStrip">
            <summary>
All vertices form a single connected line.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.PrimitiveType.Points">
            <summary>
All vertices are non-connected points.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.PixelShaderType">
            <summary>
Compile target enumeration for the <c>GPUProgrammingServices.AddHighLevelShaderMaterial()</c> method.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_5_0">
            <summary>
Pixel shader 5.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_4_1">
            <summary>
Pixel shader 4.1.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_4_0">
            <summary>
Pixel shader 4.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_3_0">
            <summary>
Pixel shader 3.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_2_b">
            <summary>
Pixel shader 2.0b.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_2_a">
            <summary>
Pixel shader 2.0a.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_2_0">
            <summary>
Pixel shader 2.0.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_4">
            <summary>
Pixel shader 1.4.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_3">
            <summary>
Pixel shader 1.3.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_2">
            <summary>
Pixel shader 1.2.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_1">
            <summary>
Pixel shader 1.1.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.ParticleEmitterType">
            <summary>
Types of built in particle emitters.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleEmitterType.Sphere">
            <summary>
Sphere shape emitter.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleEmitterType.Ring">
            <summary>
Ring shape emitter.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleEmitterType.Mesh">
            <summary>
Mesh emitter.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleEmitterType.Cylinder">
            <summary>
Cylinder shape emitter.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleEmitterType.Box">
            <summary>
Box shape emitter.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleEmitterType.AnimatedMesh">
            <summary>
Animated mesh emitter.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleEmitterType.Point">
            <summary>
Point emitter.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.ParticleAffectorType">
            <summary>
Types of built in particle affectors.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleAffectorType.Scale">
            <summary>
Particles are scaled over time.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleAffectorType.Rotate">
            <summary>
Particles are rotated over time.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleAffectorType.Gravity">
            <summary>
Particles are affected by the gravity.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleAffectorType.FadeOut">
            <summary>
Particles fade out over time.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleAffectorType.Attract">
            <summary>
Particles are attracted.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.ParticleAffectorType.None">
            <summary>
Particles are not affected.
</summary>
        </member>
        <member name="T:IrrlichtLime.MouseEventType">
            <summary>
Enumeration for all mouse input events.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.MiddleTripleClick">
            <summary>
Middle mouse button triple click.
This event is generated after the third <see cref="F:IrrlichtLime.MouseEventType.MiddleDown" /> event.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.RightTripleClick">
            <summary>
Right mouse button triple click.
This event is generated after the third <see cref="F:IrrlichtLime.MouseEventType.RightDown" /> event.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.LeftTripleClick">
            <summary>
Left mouse button triple click.
This event is generated after the third <see cref="F:IrrlichtLime.MouseEventType.LeftDown" /> event.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.MiddleDoubleClick">
            <summary>
Middle mouse button double click.
This event is generated after the second <see cref="F:IrrlichtLime.MouseEventType.MiddleDown" /> event.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.RightDoubleClick">
            <summary>
Right mouse button double click.
This event is generated after the second <see cref="F:IrrlichtLime.MouseEventType.RightDown" /> event.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.LeftDoubleClick">
            <summary>
Left mouse button double click.
This event is generated after the second <see cref="F:IrrlichtLime.MouseEventType.LeftDown" /> event.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.Wheel">
            <summary>
The mouse wheel was moved.
Use Wheel value in event data to find out in what direction and how fast.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.Move">
            <summary>
The mouse cursor changed its position.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.MiddleUp">
            <summary>
Middle mouse button was left up.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.RightUp">
            <summary>
Right mouse button was left up.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.LeftUp">
            <summary>
Left mouse button was left up.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.MiddleDown">
            <summary>
Middle mouse button was pressed down.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.RightDown">
            <summary>
Right mouse button was pressed down.
</summary>
        </member>
        <member name="F:IrrlichtLime.MouseEventType.LeftDown">
            <summary>
Left mouse button was pressed down.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.ModulateFunc">
            <summary>
MaterialTypeParam: e.g. DirectX: D3DTOP_MODULATE, D3DTOP_MODULATE2X, D3DTOP_MODULATE4X.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ModulateFunc._4x">
            <summary>
Multiply the components of the arguments, and shift the products to the left 2 bits (effectively multiplying them by 4) for brightening.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ModulateFunc._2x">
            <summary>
Multiply the components of the arguments, and shift the products to the left 1 bit (effectively multiplying them by 2) for brightening.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ModulateFunc._1x">
            <summary>
Multiply the components of the arguments.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.MaterialType">
            <summary>
Abstracted and easy to use fixed function/programmable pipeline material modes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.OneTextureBlend">
            <summary>
BlendFunc = source * sourceFactor + dest * destFactor ( E_BLEND_FUNC ). Using only first texture. Generic blending method.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.ParallaxMapTransparentVertexAlpha">
            <summary>
A material like <see cref="F:IrrlichtLime.Video.MaterialType.ParallaxMapSolid" />, but transparent. Using <see cref="F:IrrlichtLime.Video.MaterialType.TransparentVertexAlpha" /> as base material.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.ParallaxMapTransparentAddColor">
            <summary>
A material like <see cref="F:IrrlichtLime.Video.MaterialType.ParallaxMapSolid" />, but transparent. Using <see cref="F:IrrlichtLime.Video.MaterialType.TransparentAddColor" /> as base material.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.ParallaxMapSolid">
            <summary>
Just like <see cref="F:IrrlichtLime.Video.MaterialType.NormalMapSolid" />, but uses parallax mapping.
<para>Looks a lot more realistic. This only works when the hardware supports at least vertex shader 1.1 and pixel shader 1.4.
First texture is the color map, the second should be the normal map. The normal map texture should contain the height value in the alpha component.
The <c>VideoDriver.MakeNormalMapTexture()</c> writes this value automatically when creating normal maps from a heightmap when using a 32-bit texture.
The height scale of the material (affecting the bumpiness) is being controlled by the <c>Material.MaterialTypeParam</c>.
If set to zero, the default value (0.02f) will be applied. Otherwise the value set in <c>Material.MaterialTypeParam</c> is taken.
This value depends on with which scale the texture is mapped on the material.
Too high or low values of <c>Material.MaterialTypeParam</c> can result in strange artifacts.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.NormalMapTransparentVertexAlpha">
            <summary>
A transparent (based on the vertex alpha value) normal map renderer.
<para>First texture is the color map, the second should be the normal map.
Note that you should use this material only when drawing geometry consisting of vertices of type <c>VertexType.Tangents</c>.
You can convert any mesh into this format using <c>MeshManipulator.CreateMeshWithTangents()</c>.
This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back to a fixed function lighted material if this hardware is not available.
Only two lights are supported by this shader, if there are more, the nearest two are chosen.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.NormalMapTransparentAddColor">
            <summary>
A transparent normal map renderer.
<para>First texture is the color map, the second should be the normal map.
Note that you should use this material only when drawing geometry consisting of vertices of type <c>VertexType.Tangents</c>.
You can convert any mesh into this format using <c>MeshManipulator.CreateMeshWithTangents()</c>.
This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back to a fixed function lighted material if this hardware is not available.
Only two lights are supported by this shader, if there are more, the nearest two are chosen.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.NormalMapSolid">
            <summary>
A solid normal map renderer.
<para>First texture is the color map, the second should be the normal map.
Note that you should use this material only when drawing geometry consisting of vertices of type <c>VertexType.Tangents</c>.
You can convert any mesh into this format using <c>MeshManipulator.CreateMeshWithTangents()</c>.
This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back to a fixed function lighted material if this hardware is not available.
Only two lights are supported by this shader, if there are more, the nearest two are chosen.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.TransparentReflection2Layer">
            <summary>
A transparent reflecting material with an optional additional non reflecting texture layer.
<para>The reflection map should be set as first texture. The transparency depends on the alpha value in the vertex colors.
A texture which will not reflect can be set as second texture.
Please note that this material type is currently not 100% implemented in OpenGL.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.TransparentVertexAlpha">
            <summary>
Makes the material transparent based on the vertex alpha value.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.TransparentAlphaChannelRef">
            <summary>
Makes the material transparent based on the texture alpha channel.
<para>If the alpha channel value is greater than 127, a pixel is written to the target, otherwise not.
This material does not use alpha blending and is a lot faster than <see cref="F:IrrlichtLime.Video.MaterialType.TransparentAlphaChannel" />.
It is ideal for drawing stuff like leaves of plants, because the borders are not blurry but sharp.
Only first texture is used. If you are using this material with small textures and 3d object,
it is a good idea to load the texture in 32 bit mode using <c>VideoDriver.SetTextureCreationFlag()</c>.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.TransparentAlphaChannel">
            <summary>
Makes the material transparent based on the texture alpha channel.
<para>The final color is blended together from the destination color and the texture color, using the alpha channel value as blend factor.
Only first texture is used. If you are using this material with small textures, it is a good idea to load the texture in 32-bit mode
using <c>VideoDriver.SetTextureCreationFlag()</c>.
Also, an alpha ref is used, which can be manipulated using <c>Material.MaterialTypeParam</c>.
This value controls how sharp the edges become when going from a transparent to a solid spot on the texture.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.TransparentAddColor">
            <summary>
A transparent material.
<para>Only the first texture is used. The new color is calculated by simply adding the source color and the dest color.
This means if for example a billboard using a texture with black background and a red circle on it is drawn with this material,
the result is that only the red circle will be drawn a little bit transparent, and everything which was black is 100% transparent and not visible.
This material type is useful for particle effects.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.Reflection2Layer">
            <summary>
A reflecting material with an optional non reflecting texture layer.
<para>The reflection map should be set as first texture.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.SphereMap">
            <summary>
Look like a reflection of the environment around it.
<para>To make this possible, a texture called 'sphere map' is used, which must be set as the first texture.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.DetailMap">
            <summary>
Detail mapped material.
<para>The first texture is diffuse color map, the second is added to this and usually displayed with a bigger scale value so that it adds more detail.
The detail map is added to the diffuse map using ADD_SIGNED, so that it is possible to add and subtract color from the diffuse map.
For example a value of (127, 127, 127) will not change the appearance of the diffuse map at all. Often used for terrain rendering.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.LightMapLightingM4">
            <summary>
Like <see cref="F:IrrlichtLime.Video.MaterialType.LightMapM4" />, but also supports dynamic lighting.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.LightMapLightingM2">
            <summary>
Like <see cref="F:IrrlichtLime.Video.MaterialType.LightMapM2" />, but also supports dynamic lighting.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.LightMapLighting">
            <summary>
Like <see cref="F:IrrlichtLime.Video.MaterialType.LightMap" />, but also supports dynamic lighting.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.LightMapM4">
            <summary>
Material type with standard lightmap technique.
<para>There should be 2 textures: the first texture layer is a diffuse map, the second is a light map. Dynamic light is ignored.
The texture colors are effectively multiplied by 4 for brightening. Like known in DirectX as D3DTOP_MODULATE4X.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.LightMapM2">
            <summary>
Material type with standard lightmap technique.
<para>There should be 2 textures: the first texture layer is a diffuse map, the second is a light map. Dynamic light is ignored.
The texture colors are effectively multiplied by 2 for brightening. Like known in DirectX as D3DTOP_MODULATE2X.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.LightMapAdd">
            <summary>
Material type with lightmap technique like <see cref="F:IrrlichtLime.Video.MaterialType.LightMap" />. But lightmap and diffuse texture are added instead of modulated.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.LightMap">
            <summary>
Material type with standard lightmap technique.
<para>There should be 2 textures: The first texture layer is a diffuse map, the second is a light map. Dynamic light is ignored.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.Solid2Layer">
            <summary>
Solid material with 2 texture layers.
<para>The second is blended onto the first using the alpha value of the vertex colors.</para><para>This material is currently not implemented in OpenGL.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialType.Solid">
            <summary>
Standard solid material.
<para>Only first texture is used, which is supposed to be the diffuse material.</para></summary>
        </member>
        <member name="T:IrrlichtLime.Video.MaterialFlag">
            <summary>
Material flags.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.BlendFactor">
            <summary>
Flag for blend factor.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.PolygonOffset">
            <summary>
Flag for polygon offset.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.BlendOperation">
            <summary>
Flag for blend operation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.Mipmaps">
            <summary>
Flag for enabling/disabling mipmap usage.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.ColorMaterial">
            <summary>
                <c>ColorMaterial</c> enumeration for vertex color interpretation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.ColorMask">
            <summary>
                <c>ColorPlane</c> bits, for enabling the color planes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.AntiAliasing">
            <summary>
Anti-aliasing mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.TextureWrap">
            <summary>
Access to all layers texture wrap settings. Overwrites separate layer settings.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.NormalizeNormals">
            <summary>
Normalizes normals. Default: false.
You can enable this if you need to scale a dynamic lighted model.
<para>Usually, its normals will get scaled too then and it will get darker.
If you enable this flag, the normals will be normalized again, and the model will look as bright as it should.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.Fog">
            <summary>
Is fog enabled? Default: false.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.AnisotropicFilter">
            <summary>
Is anisotropic filtering? Default: false.
In Irrlicht you can use anisotropic texture filtering in conjunction with bilinear or trilinear texture filtering to improve rendering results.
Primitives will look less blurry with this flag switched on.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.TrilinearFilter">
            <summary>
Is trilinear filtering enabled? Default: false.
If the trilinear filter flag is enabled, the bilinear filtering flag is ignored.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.BilinearFilter">
            <summary>
Is bilinear filtering enabled? Default: true.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.FrontFaceCulling">
            <summary>
Is frontface culling enabled? Default: false.
Overrides <see cref="F:IrrlichtLime.Video.MaterialFlag.BackFaceCulling" /> if both are enabled.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.BackFaceCulling">
            <summary>
Is backface culling enabled? Default: true.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.ZWrite">
            <summary>
May be written to the ZBuffer or is it read-only. Default: true.
This flag is ignored, if the material type is a transparent type.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.ZBuffer">
            <summary>
Is the ZBuffer enabled? Default: true.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.Lighting">
            <summary>
Will this material be lighted? Default: true.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.GouraudShading">
            <summary>
Flat or Gouraud shading? Default: true.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.PointCloud">
            <summary>
Draw as point cloud or filled triangles? Default: false.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.MaterialFlag.Wireframe">
            <summary>
Draw as wireframe or filled triangles? Default: false.
</summary>
        </member>
        <member name="T:IrrlichtLime.LogLevel">
            <summary>
Possible log levels.
When used has filter <see cref="F:IrrlichtLime.LogLevel.Debug" /> means "log everything" and <see cref="F:IrrlichtLime.LogLevel.None" /> means "log (nearly) nothing".
When used to print logging information <see cref="F:IrrlichtLime.LogLevel.Debug" /> will have lowest priority while <see cref="F:IrrlichtLime.LogLevel.None" /> messages are never filtered and always printed.
</summary>
        </member>
        <member name="F:IrrlichtLime.LogLevel.None">
            <summary>
Logs with <see cref="F:IrrlichtLime.LogLevel.None" /> will never be filtered.
And used as filter it will remove all logging except <see cref="F:IrrlichtLime.LogLevel.None" /> messages.
</summary>
        </member>
        <member name="F:IrrlichtLime.LogLevel.Error">
            <summary>
Something did go wrong.
</summary>
        </member>
        <member name="F:IrrlichtLime.LogLevel.Warning">
            <summary>
Warnings that something isn't as expected and can cause oddities.
</summary>
        </member>
        <member name="F:IrrlichtLime.LogLevel.Information">
            <summary>
Useful information to print. For example hardware infos or something started/stopped.
</summary>
        </member>
        <member name="F:IrrlichtLime.LogLevel.Debug">
            <summary>
Used for printing information helpful in debugging.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.LightType">
            <summary>
Enumeration for different types of lights.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.LightType.Directional">
            <summary>
Directional light, coming from a direction from an infinite distance.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.LightType.Spot">
            <summary>
Spot light, it has a position in space, a direction, and a limited cone of influence.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.LightType.Point">
            <summary>
Point light, it has a position in space and radiates light in all directions.
</summary>
        </member>
        <member name="T:IrrlichtLime.KeyCode">
            <summary>
Keys codes.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.None">
            <summary>
Usually no key mapping, but some laptops use it for "fn" key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_Clear">
            <summary>
Clear key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.PA1">
            <summary>
PA1 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Zoom">
            <summary>
Zoom key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Play">
            <summary>
Play key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.ErEOF">
            <summary>
Erase EOF key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.ExSel">
            <summary>
ExSel key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.CrSel">
            <summary>
CrSel key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Attn">
            <summary>
Attn key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_102">
            <summary>
"&lt;&gt;" or "\|".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_AX">
            <summary>
for Japan "AX".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_8">
            <summary>
None.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_7">
            <summary>
for US "'"".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_6">
            <summary>
for US "]}".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_5">
            <summary>
for US "\|".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_4">
            <summary>
for US "[{".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Backquote">
            <summary>
Backquote/tilde key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_3">
            <summary>
for US "`~".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_2">
            <summary>
for US "/?".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Period">
            <summary>
Period Key ".".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Minus">
            <summary>
Minus Key "-".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Comma">
            <summary>
Comma Key ",".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Plus">
            <summary>
Plus Key "+".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.OEM_1">
            <summary>
for US ";:".
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.RMenu">
            <summary>
Right MENU key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.LMenu">
            <summary>
Left MENU key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.RControl">
            <summary>
Right CONTROL key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.LControl">
            <summary>
Left CONTROL key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.RShift">
            <summary>
Right SHIFT key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.LShift">
            <summary>
Left SHIFT key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.ScrollLock">
            <summary>
SCROLL LOCK key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.NumLock">
            <summary>
NUM LOCK key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F24">
            <summary>
F24 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F23">
            <summary>
F23 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F22">
            <summary>
F22 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F21">
            <summary>
F21 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F20">
            <summary>
F20 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F19">
            <summary>
F19 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F18">
            <summary>
F18 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F17">
            <summary>
F17 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F16">
            <summary>
F16 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F15">
            <summary>
F15 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F14">
            <summary>
F14 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F13">
            <summary>
F13 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F12">
            <summary>
F12 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F11">
            <summary>
F11 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F10">
            <summary>
F10 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F9">
            <summary>
F9 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F8">
            <summary>
F8 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F7">
            <summary>
F7 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F6">
            <summary>
F6 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F5">
            <summary>
F5 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F4">
            <summary>
F4 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F3">
            <summary>
F3 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F2">
            <summary>
F2 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.F1">
            <summary>
F1 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Devide">
            <summary>
Divide key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Decimal">
            <summary>
Decimal key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Subtract">
            <summary>
Subtract key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Separator">
            <summary>
Separator key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Add">
            <summary>
Add key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Multiply">
            <summary>
Multiply key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num9">
            <summary>
Numeric keypad 9 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num8">
            <summary>
Numeric keypad 8 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num7">
            <summary>
Numeric keypad 7 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num6">
            <summary>
Numeric keypad 6 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num5">
            <summary>
Numeric keypad 5 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num4">
            <summary>
Numeric keypad 4 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num3">
            <summary>
Numeric keypad 3 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num2">
            <summary>
Numeric keypad 2 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num1">
            <summary>
Numeric keypad 1 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Num0">
            <summary>
Numeric keypad 0 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Sleep">
            <summary>
Computer Sleep key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Apps">
            <summary>
Applications key (Microsoft Natural keyboard).
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.RWin">
            <summary>
Right Windows key (Microsoft Natural keyboard).
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.LWin">
            <summary>
Left Windows key (Microsoft Natural keyboard).
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyZ">
            <summary>
Z key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyY">
            <summary>
Y key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyX">
            <summary>
X key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyW">
            <summary>
W key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyV">
            <summary>
V key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyU">
            <summary>
U key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyT">
            <summary>
T key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyS">
            <summary>
S key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyR">
            <summary>
R key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyQ">
            <summary>
Q key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyP">
            <summary>
P key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyO">
            <summary>
O key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyN">
            <summary>
N key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyM">
            <summary>
M key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyL">
            <summary>
L key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyK">
            <summary>
K key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyJ">
            <summary>
J key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyI">
            <summary>
I key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyH">
            <summary>
H key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyG">
            <summary>
G key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyF">
            <summary>
F key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyE">
            <summary>
E key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyD">
            <summary>
D key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyC">
            <summary>
C key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyB">
            <summary>
B key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.KeyA">
            <summary>
A key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key9">
            <summary>
9 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key8">
            <summary>
8 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key7">
            <summary>
7 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key6">
            <summary>
6 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key5">
            <summary>
5 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key4">
            <summary>
4 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key3">
            <summary>
3 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key2">
            <summary>
2 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key1">
            <summary>
1 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Key0">
            <summary>
0 key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Help">
            <summary>
HELP key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Delete">
            <summary>
DEL key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Insert">
            <summary>
INS key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.PrintScreen">
            <summary>
PRINT SCREEN key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Execute">
            <summary>
EXECUTE key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Print">
            <summary>
PRINT key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Select">
            <summary>
SELECT key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Down">
            <summary>
DOWN ARROW key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Right">
            <summary>
RIGHT ARROW key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Up">
            <summary>
UP ARROW key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Left">
            <summary>
LEFT ARROW key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Home">
            <summary>
HOME key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.End">
            <summary>
END key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.PageDown">
            <summary>
PAGE DOWN key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.PageUp">
            <summary>
PAGE UP key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Space">
            <summary>
SPACEBAR key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_ModeChange">
            <summary>
IME mode change request.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Accept">
            <summary>
IME accept.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_NonConvert">
            <summary>
IME nonconvert.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Convert">
            <summary>
IME convert.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Esc">
            <summary>
ESC key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Kanji">
            <summary>
IME Kanji mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Hanja">
            <summary>
IME Hanja mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Final">
            <summary>
IME final mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Junja">
            <summary>
IME Junja mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Hangul">
            <summary>
IME Hangul mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.IME_Kana">
            <summary>
IME Kana mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.CapsLock">
            <summary>
CAPS LOCK key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Pause">
            <summary>
PAUSE key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Alt">
            <summary>
ALT key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Ctrl">
            <summary>
CTRL key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Shift">
            <summary>
SHIFT key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Return">
            <summary>
ENTER key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Clear">
            <summary>
CLEAR key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Tab">
            <summary>
TAB key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Backspace">
            <summary>
BACKSPACE key.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.MouseXButton2">
            <summary>
Windows 2000/XP: X2 mouse button.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.MouseXButton1">
            <summary>
Windows 2000/XP: X1 mouse button.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.MouseMButton">
            <summary>
Middle mouse button (three-button mouse).
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.Cancel">
            <summary>
Control-break processing.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.MouseRButton">
            <summary>
Right mouse button.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyCode.MouseLButton">
            <summary>
Left mouse button.
</summary>
        </member>
        <member name="T:IrrlichtLime.KeyAction">
            <summary>
Enumeration for key actions. Used for example in the FPS Camera.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.RotateRight">
            <summary>
Rotate right.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.RotateLeft">
            <summary>
Rotate left.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.Crouch">
            <summary>
Crouch.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.Jump">
            <summary>
Jump.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.StrafeRight">
            <summary>
Strafe right.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.StrafeLeft">
            <summary>
Strafe left.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.MoveBackward">
            <summary>
Move backward.
</summary>
        </member>
        <member name="F:IrrlichtLime.KeyAction.MoveForward">
            <summary>
Move forward.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.JointUpdateOnRender">
            <summary>
Joint update modes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.JointUpdateOnRender.Control">
            <summary>
Control joint positions in the mesh (e.g. ragdolls, or set the animation from <c>AnimateJoints()</c>).
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.JointUpdateOnRender.Read">
            <summary>
Get joints positions from the mesh (for attached nodes, etc).
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.JointUpdateOnRender.None">
            <summary>
Do nothing.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.InterpolationMode">
            <summary>
Interpolation modes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.InterpolationMode.Linear">
            <summary>
Linear interpolation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.InterpolationMode.Constant">
            <summary>
Constant does use the current key-values without interpolation.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.IndexType">
            <summary>
Index types.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.IndexType._32Bit">
            <summary>
32 bit indices.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.IndexType._16Bit">
            <summary>
16 bit indices.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.HardwareMappingHint">
            <summary>
Hardware mapping hints.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareMappingHint.Stream">
            <summary>
Always changed, cache optimizing on the GPU.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareMappingHint.Dynamic">
            <summary>
Sometimes changed, driver optimized placement.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareMappingHint.Static">
            <summary>
Rarely changed, usually stored completely on the hardware.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareMappingHint.Never">
            <summary>
Don't store on the hardware.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.HardwareBufferType">
            <summary>
Hardware buffer types.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareBufferType.VertexAndIndex">
            <summary>
Change both vertex and index mapping to the same value.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareBufferType.Index">
            <summary>
Change the index mapping.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareBufferType.Vertex">
            <summary>
Change the vertex mapping.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.HardwareBufferType.None">
            <summary>
Does not change anything.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUITableDrawFlag">
            <summary>
GUI table draw flags.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUITableDrawFlag.ActiveRow">
            <summary>
Draw active row.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUITableDrawFlag.Columns">
            <summary>
Draw columns.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUITableDrawFlag.Rows">
            <summary>
Draw rows.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUISpinBoxValidation">
            <summary>
Enumeration bitflag for when to validate the text typed into the spinbox.
Default used by Irrlicht is: <see cref="F:IrrlichtLime.GUI.GUISpinBoxValidation.Enter" /> | <see cref="F:IrrlichtLime.GUI.GUISpinBoxValidation.LoseFocus" />)
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISpinBoxValidation.LoseFocus">
            <summary>
Validate when the editbox loses the focus.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISpinBoxValidation.Enter">
            <summary>
Validate when enter was pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISpinBoxValidation.Change">
            <summary>
Validate on each change. Was default up to Irrlicht 1.8.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISpinBoxValidation.Never">
            <summary>
Does not validate typed text, probably a bad idea setting this usually.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUISkinType">
            <summary>
Enumeration of available default skins.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISkinType.Unknown">
            <summary>
An unknown skin, not serializable at present.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISkinType.BurningSkin">
            <summary>
Burning's skin.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISkinType.WindowsMetallic">
            <summary>
Like <see cref="F:IrrlichtLime.GUI.GUISkinType.WindowsClassic" />, but with metallic shaded windows and buttons.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUISkinType.WindowsClassic">
            <summary>
Default windows look and feel.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIOrderingMode">
            <summary>
Ordering modes.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIOrderingMode.Descending">
            <summary>
Elements are ordered from the largest to the smallest.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIOrderingMode.Ascending">
            <summary>
Elements are ordered from the smallest to the largest.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIOrderingMode.None">
            <summary>
No element ordering.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIMessageBoxFlag">
            <summary>
Enumeration for message box layout flags.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIMessageBoxFlag.No">
            <summary>
Flag for the no button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIMessageBoxFlag.Yes">
            <summary>
Flag for the yes button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIMessageBoxFlag.Cancel">
            <summary>
Flag for the cancel button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIMessageBoxFlag.OK">
            <summary>
Flag for the OK button.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIListBoxColor">
            <summary>
Enumeration for listbox colors.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIListBoxColor.SelectedIcon">
            <summary>
Color of selected icon.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIListBoxColor.Icon">
            <summary>
Color of icon.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIListBoxColor.SelectedText">
            <summary>
Color of selected text.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIListBoxColor.Text">
            <summary>
Color of text.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIFontType">
            <summary>
An enum for the different types of GUI font.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIFontType.Custom">
            <summary>
An external font type provided by the user.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIFontType.OS">
            <summary>
A font which uses a the native API provided by the operating system. Currently not used.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIFontType.Vector">
            <summary>
Scalable vector fonts loaded from an XML file.
These fonts reside in system memory and use no video memory until they are displayed.
These are slower than bitmap fonts but can be easily scaled and rotated.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIFontType.Bitmap">
            <summary>
Bitmap fonts loaded from an XML file or a texture.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIEventType">
            <summary>
Enumeration for all events which are sendable by the gui system.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TreeViewNodeCollapse">
            <summary>
A tree view node was collapsed. See <c>GUITreeView.LastEventNode</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TreeViewNodeExpand">
            <summary>
A tree view node was expanded. See <c>GUITreeView.LastEventNode</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TreeViewNodeSelect">
            <summary>
A tree view node was selected. See <c>GUITreeView.LastEventNode</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TreeViewNodeDeselect">
            <summary>
A tree view node lost selection. See <c>GUITreeView.LastEventNode</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TableSelectedAgain">
            <summary>
A table selected again.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TableHeaderChanged">
            <summary>
A table header has changed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TableChanged">
            <summary>
A table has changed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.SpinBoxChanged">
            <summary>
The value of a spin box has changed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ComboBoxChanged">
            <summary>
The selection in a combo box has been changed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.MenuItemSelected">
            <summary>
A menu item was selected in a (context) menu.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.TabChanged">
            <summary>
The tab was changed in an tab control.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.EditBoxMarkingChanged">
            <summary>
The marked area in an editbox was changed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.EditBoxChanged">
            <summary>
The text in an editbox was changed. This does not include automatic changes in text-breaking.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.EditBoxEnter">
            <summary>
In an editbox 'ENTER' was pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.MessageBoxCancel">
            <summary>
'Cancel' was clicked on a messagebox.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.MessageBoxOK">
            <summary>
'OK' was clicked on a messagebox.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.MessageBoxNo">
            <summary>
'No' was clicked on a messagebox.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.MessageBoxYes">
            <summary>
'Yes' was clicked on a messagebox.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.FileDialogCancelled">
            <summary>
A file open dialog has been closed without choosing a file.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.FileDialogDirectorySelected">
            <summary>
A directory has been selected in the file dialog.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.FileDialogFileSelected">
            <summary>
A file has been selected in the file dialog.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ListBoxSelectedAgain">
            <summary>
An item in the listbox was selected, which was already selected.
NOTE: You get the event currently only if the item was clicked again within 500 ms or selected by "enter" or "space".
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ListBoxChanged">
            <summary>
A new item in a listbox was selected.
NOTE: You also get this event currently when the same item was clicked again after more than 500 ms.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.CheckBoxChanged">
            <summary>
A checkbox has changed its check state.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ScrollBarChanged">
            <summary>
A scrollbar has changed its position.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ButtonClicked">
            <summary>
A button was clicked.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ElementClosed">
            <summary>
An element would like to close.
Windows and context menus use this event when they would like to close, this can be canceled by absorbing the event.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ElementMouseLeft">
            <summary>
The mouse cursor left the hovered element.
If an element has sub-elements you also get this message for the subelements.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ElementMouseHovered">
            <summary>
The mouse cursor hovered over a gui element.
If an element has sub-elements you also get this message for the subelements.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ElementFocused">
            <summary>
A gui element has got the focus.
If the event is absorbed then the focus will not be changed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIEventType.ElementFocusLost">
            <summary>
A gui element has lost its focus.
<c>GUIEvent.Caller</c> is losing the focus to <c>GUIEvent.Element</c>. If the event is absorbed then the focus will not be changed.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIElementType">
            <summary>
List of all basic Irrlicht GUI elements.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Profiler">
            <summary>
GUI profiler.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Root">
            <summary>
The root of the GUI.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Unknown">
            <summary>
Unknown element.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Window">
            <summary>
A window.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.TreeView">
            <summary>
A tree view.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.ToolBar">
            <summary>
A tool bar.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Table">
            <summary>
A Table.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.TabControl">
            <summary>
A tab control.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Tab">
            <summary>
A tab.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.StaticText">
            <summary>
A static text.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.SpinBox">
            <summary>
A spin box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.ScrollBar">
            <summary>
A scroll bar.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.ModalScreen">
            <summary>
A modal screen.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.MessageBox">
            <summary>
A message box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.MeshViewer">
            <summary>
A mesh viewer.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.ListBox">
            <summary>
A list box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Image">
            <summary>
An image.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.InOutFader">
            <summary>
An in/out fader.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.ColorSelectDialog">
            <summary>
A color select dialog.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.FileOpenDialog">
            <summary>
A file open dialog.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.EditBox">
            <summary>
An edit box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Menu">
            <summary>
A menu.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.ContextMenu">
            <summary>
A context menu.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.ComboBox">
            <summary>
A combo box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.CheckBox">
            <summary>
A check box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIElementType.Button">
            <summary>
A button.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIDefaultText">
            <summary>
Default GUI texts.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.WindowRestore">
            <summary>
Tooltip text for window restore button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.WindowMinimize">
            <summary>
Tooltip text for window minimize button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.WindowMaximize">
            <summary>
Tooltip text for window maximize button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.WindowClose">
            <summary>
Tooltip text for window close button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.MsgBoxNo">
            <summary>
Text for the No button on a message box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.MsgBoxYes">
            <summary>
Text for the Yes button on a message box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.MsgBoxCancel">
            <summary>
Text for the Cancel button on a message box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultText.MsgBoxOK">
            <summary>
Text for the OK button on a message box.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIDefaultSize">
            <summary>
Enumeration for default sizes.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonPressedSpriteOffsetY">
            <summary>
Pixels to move an unscaled button sprite down when a button is pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonPressedSpriteOffsetX">
            <summary>
Pixels to move an unscaled button sprite to the right when a button is pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonPressedTextOffsetY">
            <summary>
Pixels to move the button text down when a button is pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonPressedTextOffsetX">
            <summary>
Pixels to move the button text to the right when a button is pressed.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonPressedImageOffsetY">
            <summary>
Pixels to move an unscaled button image down when a button is pressed and the unpressed image looks identical.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonPressedImageOffsetX">
            <summary>
Pixels to move an unscaled button image to the right when a button is pressed and the unpressed image looks identical.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MessageBoxMaxTextHeight">
            <summary>
Maximal space to reserve for messagebox text-height.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MessageBoxMinTextHeight">
            <summary>
Minimal space to reserve for messagebox text-height.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MessageBoxMaxTextWidth">
            <summary>
Maximal space to reserve for messagebox text-width.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MessageBoxMinTextWidth">
            <summary>
Minimal space to reserve for messagebox text-width.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MessageBoxGapSpace">
            <summary>
Free space in a messagebox between borders and contents on all sides.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.TitleBarTextDistanceY">
            <summary>
Distance for text in the title bar, from the top of the window rect.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.TitleBarTextDistanceX">
            <summary>
Distance for text in the title bar, from the left of the window rect.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.TextDistanceY">
            <summary>
Top distance for text from background.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.TextDistanceX">
            <summary>
Left distance for text from background.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonHeight">
            <summary>
Height of a default button (OK and cancel buttons).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ButtonWidth">
            <summary>
Width of a default button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MessageBoxHeight">
            <summary>
Height of the message box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MessageBoxWidth">
            <summary>
Width of the message box.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.CheckBoxWidth">
            <summary>
Width of a checkbox check.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.WindowButtonWidth">
            <summary>
Width and height of a window titlebar button (like minimize/maximize/close buttons). The titlebar height is also calculated from that.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.MenuHeight">
            <summary>
Height of menu.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultSize.ScrollBarSize">
            <summary>
Default with / height of scrollbar. Also width of drop-down button in comboboxes.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIDefaultIcon">
            <summary>
Customizable symbols for GUI.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.Directory">
            <summary>
Folder icon for file selection.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.File">
            <summary>
File icon for file selection.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.Collapse">
            <summary>
Minus icon for trees.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.Expand">
            <summary>
Plus icon for trees.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.MoreDown">
            <summary>
Icon indicating that there is more content below.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.MoreUp">
            <summary>
Icon indicating that there is more content above.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.MoreRight">
            <summary>
Icon indicating that there is more content to the right (e.g. &gt;&gt;).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.MoreLeft">
            <summary>
Icon indicating that there is more content to the left (e.g. &lt;&lt;).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.RadioButtonChecked">
            <summary>
Selection dot in a radio button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.CursorDown_Small">
            <summary>
Smaller down arrow.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.CursorUp_Small">
            <summary>
Smaller up arrow.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.DropDown">
            <summary>
Down arrow for dropdown menus.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.CheckBoxChecked">
            <summary>
Tick for checkbox.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.MenuMore">
            <summary>
Icon for menu children.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.CursorRight">
            <summary>
Scroll bar right button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.CursorLeft">
            <summary>
Scroll bar left button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.CursorDown">
            <summary>
Scroll bar down button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.CursorUp">
            <summary>
Scroll bar up button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.WindowResize">
            <summary>
Resize icon for bottom right corner of a window.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.WindowMinimize">
            <summary>
Minimize window button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.WindowClose">
            <summary>
Close window button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.WindowRestore">
            <summary>
Restore window button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultIcon.WindowMaximize">
            <summary>
Maximize window button.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIDefaultFont">
            <summary>
Customizable fonts.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultFont.Tooltip">
            <summary>
Font for tool tips.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultFont.Menu">
            <summary>
Font for menu items.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultFont.Window">
            <summary>
Font for window title bars.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultFont.Button">
            <summary>
Font for buttons.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultFont.Default">
            <summary>
For static text, edit boxes, lists and most other places.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIDefaultColor">
            <summary>
Enumeration for skin colors.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.FocusedEditable">
            <summary>
Show focus of window background for editable field (editbox or when checkbox-field is pressed).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.GrayEditable">
            <summary>
Grayed (disabled) window background for editable field (editbox, checkbox-field).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.Editable">
            <summary>
Window background for editable field (editbox, checkbox-field).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.GrayWindowSymbol">
            <summary>
Grayed (disabled) window symbols like on close buttons, scroll bars and check boxes.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.IconHighLight">
            <summary>
Selected icons in a list or tree.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.Icon">
            <summary>
Icons in a list or tree.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.WindowSymbol">
            <summary>
Window symbols like on close buttons, scroll bars and check boxes.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.WindowBackground">
            <summary>
Window background.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.ScrollBar">
            <summary>
Scrollbar gray area.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.TooltipBackground">
            <summary>
Tool tip background color.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.TooltipText">
            <summary>
Tool tip text color.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.InactiveCaption">
            <summary>
Inactive window caption.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.InactiveBorder">
            <summary>
Inactive window border.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.HighLightText">
            <summary>
Text of item(s) selected in a control.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.HighLight">
            <summary>
Item(s) selected in a control.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.GrayText">
            <summary>
Grayed (disabled) text.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.ButtonText">
            <summary>
Text on a button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.AppWorkspace">
            <summary>
Background color of multiple document interface (MDI) applications.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.ActiveCaption">
            <summary>
Active window title bar text.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor.ActiveBorder">
            <summary>
Active window border.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor._3dLight">
            <summary>
Light color for three-dimensional display elements (for edges facing the light source).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor._3dHighLight">
            <summary>
Highlight color for three-dimensional display elements (for edges facing the light source).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor._3dFace">
            <summary>
Face color for three-dimensional display elements and for dialog box backgrounds.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor._3dShadow">
            <summary>
Shadow color for three-dimensional display elements (for edges facing away from the light source).
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIDefaultColor._3dDarkShadow">
            <summary>
Dark shadow for three-dimensional display elements.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIContextMenuClose">
            <summary>
Close behavior for a context menu. Default is <see cref="F:IrrlichtLime.GUI.GUIContextMenuClose.Remove" />.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIContextMenuClose.Hide">
            <summary>
Do <c>element.Visible = false</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIContextMenuClose.Remove">
            <summary>
Remove the GUI element.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIContextMenuClose.Ignore">
            <summary>
Do nothing - menu stays open.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIColumnOrdering">
            <summary>
Modes for ordering used when a column header is clicked.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIColumnOrdering.FlipAscendingDescending">
            <summary>
Sort it ascending on first click, descending on next, etc.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIColumnOrdering.Descending">
            <summary>
Sort it descending by it's ASCII value like: z,x,y,...
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIColumnOrdering.Ascending">
            <summary>
Sort it ascending by it's ASCII value like: a,b,c,...
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIColumnOrdering.Custom">
            <summary>
Send a <c>GUIEventType.TableHeaderChanged</c> message when a column header is clicked.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIColumnOrdering.None">
            <summary>
Do not use ordering.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIButtonState">
            <summary>
Current state of buttons used for drawing sprites.
<para>Note that up to 3 states can be active at the same time:
<see cref="F:IrrlichtLime.GUI.GUIButtonState.ButtonUp" /> or <see cref="F:IrrlichtLime.GUI.GUIButtonState.ButtonDown" />,
<see cref="F:IrrlichtLime.GUI.GUIButtonState.MouseOver" /> or <see cref="F:IrrlichtLime.GUI.GUIButtonState.MouseOff" />,
<see cref="F:IrrlichtLime.GUI.GUIButtonState.Focused" /> or <see cref="F:IrrlichtLime.GUI.GUIButtonState.NotFocused" />.</para></summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIButtonState.ButtonDisabled">
            <summary>
The button is disabled. All other states are ignored in that case.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIButtonState.NotFocused">
            <summary>
The button doesn't have the focus.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIButtonState.Focused">
            <summary>
The button has the focus.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIButtonState.MouseOff">
            <summary>
The mouse cursor is not over the button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIButtonState.MouseOver">
            <summary>
The mouse cursor is over the button.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIButtonState.ButtonDown">
            <summary>
The button is currently pressed down.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIButtonState.ButtonUp">
            <summary>
The button is not pressed.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.GUIAlignment">
            <summary>
Alignment types for a GUI element relative to its parent.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIAlignment.Scale">
            <summary>
Stretched to fit parent.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIAlignment.Center">
            <summary>
Aligned to the center of parent.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIAlignment.LowerRight">
            <summary>
Aligned to parent's bottom or right side.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.GUIAlignment.UpperLeft">
            <summary>
Aligned to parent's top or left side (default).
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.GPUShadingLanguage">
            <summary>
Enumeration for different types of shading languages.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.GPUShadingLanguage.Cg">
            <summary>
Cg shading language.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.GPUShadingLanguage.Default">
            <summary>
The default language, so HLSL for Direct3D and GLSL for OpenGL.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.GeometryShaderType">
            <summary>
Enumeration for supported geometry shader types.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.GeometryShaderType.GS_4_0">
            <summary>
Geometry shader 4.0.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.FogType">
            <summary>
Enumeration for the types of fog distributions to choose from.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.FogType.Exp2">
            <summary>
f = e ^ (-density * z) ^ 2.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.FogType.Linear">
            <summary>
f = (end-z) / (end-start).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.FogType.Exp">
            <summary>
f = e ^ (-density * z).
</summary>
        </member>
        <member name="T:IrrlichtLime.IO.FileSystemType">
            <summary>
Enumeration for all file system types.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileSystemType.Virtual">
            <summary>
Virtual file system.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileSystemType.Native">
            <summary>
Native OS file system.
</summary>
        </member>
        <member name="T:IrrlichtLime.IO.FileArchiveType">
            <summary>
Contains the different types of archives.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.Unknown">
            <summary>
The type of this archive is unknown.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.WAD">
            <summary>
A wad archive, Quake2, Halflife.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.TAR">
            <summary>
A Tape ARchive.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.NPK">
            <summary>
A Nebula Device archive.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.PAK">
            <summary>
An ID Software PAK archive.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.Folder">
            <summary>
A virtual directory.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.GZIP">
            <summary>
A gzip archive.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.FileArchiveType.ZIP">
            <summary>
A PKZIP archive.
</summary>
        </member>
        <member name="T:IrrlichtLime.EventType">
            <summary>
Enumeration for all event types there are.
</summary>
        </member>
        <member name="F:IrrlichtLime.EventType.User">
            <summary>
A user event with user data.
This is not used by Irrlicht and can be used to send user specific data though the system.
The Irrlicht 'window handle' can be obtained from <c>IrrlichtDevice.GetExposedVideoData()</c>.
The usage and behavior depends on the operating system.
Windows: send a WM_USER message to the Irrlicht window; the wParam and lParam will be used to populate the UserData1 and UserData2 members of the <c>UserEvent</c>.
Linux: send a ClientMessage via XSendEvent to the Irrlicht window; the data.l[0] and data.l[1] members will be cast to s32 and used as UserData1 and UserData2.
MacOS: not yet implemented.
</summary>
        </member>
        <member name="F:IrrlichtLime.EventType.Log">
            <summary>
A log event.
Log events are only passed to the user receiver if there is one. If they are absorbed by the user receiver then no text will be sent to the console.
</summary>
        </member>
        <member name="F:IrrlichtLime.EventType.Joystick">
            <summary>
A joystick (joypad, gamepad) input event.
Joystick events are created by polling all connected joysticks once per <c>device.Run()</c> and then passing the events to <c>IrrlichtDevice.PostEventFromUser()</c>.
They take the same path as mouse events.
This even fully implemented for Windows and SDL.
Implemented with POV hat issues for Linux.
Not implemeted for MacOS / Other.
</summary>
        </member>
        <member name="F:IrrlichtLime.EventType.Key">
            <summary>
A key input event.
Like mouse events, keyboard events are created by the device and passed to <c>IrrlichtDevice.PostEventFromUser()</c>.
They take the same path as mouse events.
</summary>
        </member>
        <member name="F:IrrlichtLime.EventType.Mouse">
            <summary>
A mouse input event.
Mouse events are created by the device and passed to <c>IrrlichtDevice.PostEventFromUser()</c> in response to mouse input received from the operating system.
Mouse events are first passed to the user receiver, then to the GUI environment and its elements,
then finally the input receiving scene manager where it is passed to the active camera.
</summary>
        </member>
        <member name="F:IrrlichtLime.EventType.GUI">
            <summary>
An event of the graphical user interface.
GUI events are created by the GUI environment or the GUI elements in response to mouse or keyboard events.
When a GUI element receives an event it will either process it and return true, or pass the event to its parent.
If an event is not absorbed before it reaches the root element then it will then be passed to the user receiver.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.DriverType">
            <summary>
An enumeration for all types of drivers the Irrlicht Engine supports.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.DriverType.OpenGL">
            <summary>
OpenGL device, available on most platforms.
Performs hardware accelerated rendering of 3D and 2D primitives.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.DriverType.Direct3D9">
            <summary>
Direct3D 9 device, only available on Win32 platforms.
Performs hardware accelerated rendering of 3D and 2D primitives.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.DriverType.BurningsVideo">
            <summary>
The Burning's Software Renderer, an alternative software renderer.
Basically it can be described as the Irrlicht Software renderer on steroids.
It rasterizes 3D geometry perfectly: it is able to perform correct 3D clipping, perspective correct texture mapping,
perspective correct color mapping, and renders sub pixel correct, sub texel correct primitives.
In addition, it does bilinear texel filtering and supports more materials than the <see cref="F:IrrlichtLime.Video.DriverType.Software" />.
This renderer has been written entirely by Thomas Alten, thanks a lot for this huge contribution.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.DriverType.Software">
            <summary>
The Irrlicht Engine Software renderer.
Runs on all platforms, with every hardware. It should only be used for 2D graphics, but it can also perform some primitive 3D functions.
These 3D drawing functions are quite fast, but very inaccurate, and don't even support clipping in 3D mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.DriverType.Null">
            <summary>
Null driver, useful for applications to run the engine without visualization.
The null device is able to load textures, but does not render and display any graphics.
</summary>
        </member>
        <member name="T:IrrlichtLime.DeviceType">
            <summary>
An enumeration for the different device types supported by the Irrlicht Engine.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.Best">
            <summary>
This selection allows Irrlicht to choose the best device from the ones available.
If this selection is chosen then Irrlicht will try to use the IrrlichtDevice native to your operating system.
If this is unavailable then the X11, SDL and then console device will be tried.
This ensures that Irrlicht will run even if your platform is unsupported, although it may not be able to render anything.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.Console">
            <summary>
A simple text only device supported by all platforms.
This device allows applications to run from the command line without opening a window.
It can render the output of the software drivers to the console as ASCII.
It only supports mouse and keyboard in Windows operating systems.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.FrameBuffer">
            <summary>
A device for raw framebuffer access.
Best used with embedded devices and mobile systems.
Does not need X11 or other graphical subsystems.
May support hw-acceleration via OpenGL-ES for FBDirect.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.SDL">
            <summary>
A device which uses Simple DirectMedia Layer.
The SDL device works under all platforms supported by SDL.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.OSX">
            <summary>
A device native to Mac OSX.
This device uses Apple's Cocoa API and works in Mac OSX 10.2 and above.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.X11">
            <summary>
A device native to Unix style operating systems.
This device uses the X11 windowing system and works in Linux, Solaris, FreeBSD, OSX and other operating systems which support X11.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.WinCE">
            <summary>
A device native to Windows CE devices.
This device works on Windows Mobile, Pocket PC and Microsoft SmartPhone devices.
</summary>
        </member>
        <member name="F:IrrlichtLime.DeviceType.Win32">
            <summary>
A device native to Microsoft Windows.
This device uses the Win32 API and works in all versions of Windows.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.DebugSceneType">
            <summary>
An enumeration for all types of debug data for built-in scene nodes (flags).
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.Full">
            <summary>
Show all debug infos.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.BBoxAll">
            <summary>
Show all bounding boxes. Same as <see cref="F:IrrlichtLime.Scene.DebugSceneType.BBox" /> | <see cref="F:IrrlichtLime.Scene.DebugSceneType.BBoxBuffers" />.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.BBoxBuffers">
            <summary>
Show bounding boxes of all mesh buffers.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.HalfTransparency">
            <summary>
Temporary use transparency material type.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.MeshWireOverlay">
            <summary>
Overlays mesh wireframe.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.Skeleton">
            <summary>
Shows skeleton/tags.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.Normals">
            <summary>
Show vertex normals.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.BBox">
            <summary>
Show bounding boxes of SceneNode.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.DebugSceneType.Off">
            <summary>
No Debug Data. Default.
</summary>
        </member>
        <member name="T:IrrlichtLime.GUI.CursorPlatformBehavior">
            <summary>
Platform specific behavior flags for the cursor.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.CursorPlatformBehavior.X11CacheUpdates">
            <summary>
On X11 try caching cursor updates as XQueryPointer calls can be expensive.
Update cursor positions only when the irrlicht timer has been updated or the timer is stopped.
This means you usually get one cursor update per <c>device.Run()</c> which will be fine in most cases.
</summary>
        </member>
        <member name="F:IrrlichtLime.GUI.CursorPlatformBehavior.None">
            <summary>
Default - no platform specific behavior.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.CullingType">
            <summary>
An enumeration for all types of automatic culling for built-in scene nodes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.CullingType.OcclusionQuery">
            <summary>
Occlusion query culling.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.CullingType.FrustumSphere">
            <summary>
Frustrum sphere culling.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.CullingType.FrustumBox">
            <summary>
Frustrum box culling.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.CullingType.Box">
            <summary>
Box culling.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.CullingType.Off">
            <summary>
No culling.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.ComparisonFunc">
            <summary>
Comparison function, e.g. for depth buffer test.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.Never">
            <summary>
Test never succeeds.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.Always">
            <summary>
Test succeeds always.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.Greater">
            <summary>
Inverse of &lt;=.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.GreaterEqual">
            <summary>
&gt;= test.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.NotEqual">
            <summary>
Succeeds almost always, except for exact equality.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.Less">
            <summary>
Exclusive less comparison, i.e. &lt;.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.Equal">
            <summary>
Exact equality.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.LessEqual">
            <summary>
&lt;= test, default for e.g. depth test.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ComparisonFunc.Disabled">
            <summary>
Depth test disabled (disable also write to depth buffer).
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.ColorPlane">
            <summary>
Enumeration values for enabling/disabling color planes for rendering.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorPlane.All">
            <summary>
All planes enabled.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorPlane.RGB">
            <summary>
All colors, no alpha.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorPlane.Blue">
            <summary>
Blue enabled.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorPlane.Green">
            <summary>
Green enabled.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorPlane.Red">
            <summary>
Red enabled.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorPlane.Alpha">
            <summary>
Alpha enabled.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorPlane.None">
            <summary>
No color enabled.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.ColorMaterial">
            <summary>
These flags allow to define the interpretation of vertex color when lighting is enabled.
<para>Without lighting being enabled the vertex color is the only value defining the fragment color.
Once lighting is enabled, the four values for diffuse, ambient, emissive, and specular take over.
With these flags it is possible to define which lighting factor shall be defined by the vertex color
instead of the lighting factor which is the same for all faces of that material.</para><para>The default is to use vertex color for the diffuse value, another pretty common value is to use
vertex color for both diffuse and ambient factor.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorMaterial.DiffuseAndAmbient">
            <summary>
Use vertex color for both diffuse and ambient light.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorMaterial.Specular">
            <summary>
Use vertex color for specular light.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorMaterial.Emissive">
            <summary>
Use vertex color for emissive light.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorMaterial.Ambient">
            <summary>
Use vertex color for ambient light.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorMaterial.Diffuse">
            <summary>
Use vertex color for diffuse light, this is default.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorMaterial.None">
            <summary>
Don't use vertex color for lighting.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.ColorFormat">
            <summary>
Enumeration for the color format of textures used by the Irrlicht Engine. A color format specifies how color information is stored.
<para>NOTE: Byte order in memory is usually flipped (it's probably correct in bitmap files, but flipped on reading).
So for example <see cref="F:IrrlichtLime.Video.ColorFormat.A8R8G8B8" /> is BGRA in memory same as in DX9's <c>D3DFMT_A8R8G8B8</c> format.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.Unknown">
            <summary>
Unknown color format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.D24S8">
            <summary>
32 bit format using 24 bits for depth and 8 bits for stencil.
Depth and stencil format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.D32">
            <summary>
32 bit format using 32 bits for depth.
Depth buffer format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.D16">
            <summary>
16 bit format using 16 bits for depth.
Depth buffer format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R16G16">
            <summary>
32 bit format using 16 bits for the red and green channels.
Unsigned normalized integer format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R16">
            <summary>
16 bit format using 16 bits for the red channel.
Unsigned normalized integer format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R8G8">
            <summary>
16 bit format using 8 bits for the red and green channels.
Unsigned normalized integer format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R8">
            <summary>
8 bit format using 8 bits for the red channel.
Unsigned normalized integer format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.A32B32G32R32F">
            <summary>
128 bit format using 32 bits for the red, green, blue and alpha channels.
May only be used for render target textures. Floating point format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.G32R32F">
            <summary>
64 bit format using 32 bits for the red and green channels.
May only be used for render target textures. Floating point format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R32F">
            <summary>
32 bit format using 32 bits for the red channel.
May only be used for render target textures. Floating point format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.A16B16G16R16F">
            <summary>
64 bit format using 16 bits for the red, green, blue and alpha channels.
May only be used for render target textures. Floating point format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.G16R16F">
            <summary>
32 bit format using 16 bits for the red and green channels.
May only be used for render target textures. Floating point format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R16F">
            <summary>
16 bit format using 16 bits for the red channel.
May only be used for render target textures. Floating point format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.ETC2_ARGB">
            <summary>
ETC2 ARGB color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.ETC2_RGB">
            <summary>
ETC2 RGB color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.ETC1">
            <summary>
ETC1 RGB color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.PVRTC2_ARGB4">
            <summary>
PVRTC2 ARGB 4bpp color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.PVRTC2_ARGB2">
            <summary>
PVRTC2 ARGB 2bpp color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.PVRTC_ARGB4">
            <summary>
PVRTC ARGB 4bpp color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.PVRTC_RGB4">
            <summary>
PVRTC RGB 4bpp color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.PVRTC_ARGB2">
            <summary>
PVRTC ARGB 2bpp color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.PVRTC_RGB2">
            <summary>
PVRTC RGB 2bpp color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.DXT5">
            <summary>
DXT5 color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.DXT4">
            <summary>
DXT4 color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.DXT3">
            <summary>
DXT3 color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.DXT2">
            <summary>
DXT2 color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.DXT1">
            <summary>
DXT1 color format.
Compressed format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.A8R8G8B8">
            <summary>
Default 32 bit color format. 8 bits are used for every component: red, green, blue and alpha.
<para>Warning: this tends to be BGRA in memory (it's ARGB on file, but with usual big-endian memory it's flipped).</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R8G8B8">
            <summary>
24 bit color, no alpha channel, but 8 bit for red, green and blue.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.R5G6B5">
            <summary>
Standard 16 bit color format.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ColorFormat.A1R5G5B5">
            <summary>
16 bit color format used by the software driver.
It is thus preferred by all other irrlicht engine video drivers.
There are 5 bits for every color component, and a single bit is left for alpha information.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.ClearBufferFlag">
            <summary>
Enumeration for the flags of clear buffer.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ClearBufferFlag.All">
            <summary>
All buffers (color, depth, stencil).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ClearBufferFlag.Stencil">
            <summary>
Stencil buffer.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ClearBufferFlag.Depth">
            <summary>
Depth buffer.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ClearBufferFlag.Color">
            <summary>
Color buffer.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.ClearBufferFlag.None">
            <summary>
None.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.BoneSkinningSpace">
            <summary>
Enumeration for different bone skinning spaces.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.BoneSkinningSpace.Global">
            <summary>
Global skinning.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.BoneSkinningSpace.Local">
            <summary>
Local skinning, standard.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.BoneAnimationMode">
            <summary>
Enumeration for different bone animation modes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.BoneAnimationMode.NotAnimated">
            <summary>
The bone is not animated by the skin.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.BoneAnimationMode.Animated">
            <summary>
The bone is animated by the skin, if it's parent is not animated then animation will resume from this bone onward.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.BoneAnimationMode.Automatic">
            <summary>
The bone is usually animated, unless it's parent is not animated.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.BlendOperation">
            <summary>
Values defining the blend operation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.MaxAlpha">
            <summary>
Choose maximum value of each color channel based on alpha value, not widely supported.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.MinAlpha">
            <summary>
Choose minimum value of each color channel based on alpha value, not widely supported.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.MaxFactor">
            <summary>
Choose maximum value of each color channel after applying blend factors, not widely supported.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.MinFactor">
            <summary>
Choose minimum value of each color channel after applying blend factors, not widely supported.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.Max">
            <summary>
Choose maximum value of each color channel.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.Min">
            <summary>
Choose minimum value of each color channel.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.RevSubtract">
            <summary>
This modes subtracts destination from source.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.Subtract">
            <summary>
This mode subtracts the color values.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.Add">
            <summary>
Default blending adds the color values.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendOperation.None">
            <summary>
No blending happens.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.BlendFactor">
            <summary>
Flag for <c>MaterialType.OneTextureBlend</c>, ( BlendFactor ) BlendFunc = source * sourceFactor + dest * destFactor.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.SrcAlphaSaturate">
            <summary>
src (min(srcA, 1-destA), idem, ...).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.OneMinusDstAlpha">
            <summary>
src &amp; dest (1-destA, 1-destA, 1-destA, 1-destA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.DstAlpha">
            <summary>
src &amp; dest (destA, destA, destA, destA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.OneMinusSrcAlpha">
            <summary>
src &amp; dest (1-srcA, 1-srcA, 1-srcA, 1-srcA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.SrcAlpha">
            <summary>
src &amp; dest (srcA, srcA, srcA, srcA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.OneMinusSrcColor">
            <summary>
dest (1-srcR, 1-srcG, 1-srcB, 1-srcA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.SrcColor">
            <summary>
dest (srcR, srcG, srcB, srcA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.OneMinusDstColor">
            <summary>
src (1-destR, 1-destG, 1-destB, 1-destA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.DstColor">
            <summary>
src (destR, destG, destB, destA).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.One">
            <summary>
src &amp; dest (1, 1, 1, 1).
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.BlendFactor.Zero">
            <summary>
src &amp; dest (0, 0, 0, 0).
</summary>
        </member>
        <member name="T:IrrlichtLime.IO.AttributeType">
            <summary>
Types of attributes available for <c>Attributes</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Unknown">
            <summary>
Unknown attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Texture">
            <summary>
Texture reference attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.ByteArray">
            <summary>
Byte array attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.StringArray">
            <summary>
Array of strings attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Line3Df">
            <summary>
Line attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Triangle3Df">
            <summary>
Triangle attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Plane3Df">
            <summary>
Plane attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.AABBox">
            <summary>
3d bounding box attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Quaternion">
            <summary>
Quaternion attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Matrix">
            <summary>
Matrix attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Recti">
            <summary>
Rectangle attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Vector2Df">
            <summary>
Float point 2d vector attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Vector2Di">
            <summary>
Integer 2d vector attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Vector3Df">
            <summary>
3d vector attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Colorf">
            <summary>
Floating point color attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Color">
            <summary>
Color attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Enum">
            <summary>
Enumeration attribute. Read-only. Please use <see cref="F:IrrlichtLime.IO.AttributeType.Int" /> in case you need to write.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Bool">
            <summary>
Boolean attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.String">
            <summary>
String attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Float">
            <summary>
Float attribute.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeType.Int">
            <summary>
Integer attribute.
</summary>
        </member>
        <member name="T:IrrlichtLime.IO.AttributeReadWriteFlag">
            <summary>
Enumeration flags passed through <c>AttributeReadWriteOptions</c> to the <c>AttributeExchangingObject</c>.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeReadWriteFlag.UseRelativePaths">
            <summary>
When writing filenames, relative paths should be used.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeReadWriteFlag.ForEditor">
            <summary>
Serialization/Deserializion is done for an editor property box.
</summary>
        </member>
        <member name="F:IrrlichtLime.IO.AttributeReadWriteFlag.ForFile">
            <summary>
Serialization/Deserializion is done for an xml file.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.AntiAliasingMode">
            <summary>
These flags are used to specify the anti-aliasing and smoothing modes.
<para>Techniques supported are multisampling, geometry smoothing, and alpha to coverage.
Some drivers don't support a per-material setting of the anti-aliasing modes.
In those cases, FSAA / multisampling is defined by the device mode chosen upon creation via <c>IrrlichtCreationParameters</c>.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.AntiAliasingMode.AlphaToCoverage">
            <summary>
Enhanced anti-aliasing for transparent materials. Usually used with <c>MaterialType.TransparentAlphaChannelRef</c> and multisampling.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AntiAliasingMode.FullBasic">
            <summary>
All typical anti-alias and smooth modes.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AntiAliasingMode.PointSmooth">
            <summary>
Point smoothing, often in software and slow, only with OpenGL.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AntiAliasingMode.LineSmooth">
            <summary>
Line smoothing. Careful, enabling this can lead to software emulation under OpenGL.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AntiAliasingMode.Quality">
            <summary>
High-quality anti-aliasing, not always supported, automatically enables <see cref="F:IrrlichtLime.Video.AntiAliasingMode.Simple" /> mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AntiAliasingMode.Simple">
            <summary>
Default anti-aliasing mode.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AntiAliasingMode.Off">
            <summary>
Use to turn off anti-aliasing for this material.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.AnimationTypeMD2">
            <summary>
Types of standard md2 animations.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Boom">
            <summary>
Boom animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Death_Fall_Back_Slow">
            <summary>
Death fall back slow animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Death_Fall_Forward">
            <summary>
Death fall forward animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Death_Fall_Back">
            <summary>
Death fall back animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Crouch_Death">
            <summary>
Death animation for crouch pose.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Crouch_Pain">
            <summary>
Pain animation for crouch pose.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Crouch_Attack">
            <summary>
Attack animation for crouch pose.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Crouch_Walk">
            <summary>
Walk animation for crouch pose.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Crouch_Stand">
            <summary>
Stand animation for crouch pose.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Point">
            <summary>
Point animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Wave">
            <summary>
Wave animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Fallback">
            <summary>
Fall back animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Salute">
            <summary>
Salute animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Flip">
            <summary>
Flip animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Jump">
            <summary>
Jump animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Pain_C">
            <summary>
Pain animation (variant C)
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Pain_B">
            <summary>
Pain animation (variant B)
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Pain_A">
            <summary>
Pain animation (variant A)
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Attack">
            <summary>
Attack animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Run">
            <summary>
Run animation.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimationTypeMD2.Stand">
            <summary>
Stand animation.
</summary>
        </member>
        <member name="T:IrrlichtLime.Scene.AnimatedMeshType">
            <summary>
Possible types of meshes.
<para>Note: was previously only used in <c>AnimatedMesh</c> so it still has the "animated" in the name.
But can now be used for all mesh-types as we need those casts as well.</para></summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.Static">
            <summary>
Generic non-animated mesh.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.Skinned">
            <summary>
Generic skinned mesh.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.MDL_HalfLife">
            <summary>
Halflife MDL model file.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.OCT">
            <summary>
.oct file for Paul Nette's FSRad or from Murphy McCauley's Blender .oct exporter.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.CSM">
            <summary>
Cartography Shop .csm file. This loader was created by Saurav Mohapatra.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.LMTS">
            <summary>
Pulsar LMTools .lmts file. This Irrlicht loader was written by Jonas Petersen.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.MY3D">
            <summary>
My3D Mesh, the file format by Zhuck Dimitry.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType._3DS">
            <summary>
3D Studio .3ds file.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.BSP">
            <summary>
Quake 3 .bsp static map.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.OBJ">
            <summary>
Maya .obj static model.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.MD3">
            <summary>
Quake 3 MD3 model file.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.MD2">
            <summary>
Quake 2 MD2 model file.
</summary>
        </member>
        <member name="F:IrrlichtLime.Scene.AnimatedMeshType.Unknown">
            <summary>
Unknown animated mesh type.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.AlphaSource">
            <summary>
Source of the alpha value to take.
<para>This is currently only supported in <c>MaterialType.OneTextureBlend</c>.
You can use an or'ed combination of values. Alpha values are modulated (multiplied).</para></summary>
        </member>
        <member name="F:IrrlichtLime.Video.AlphaSource.Texture">
            <summary>
Use texture alpha channel.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AlphaSource.VertexColor">
            <summary>
Use vertex color alpha.
</summary>
        </member>
        <member name="F:IrrlichtLime.Video.AlphaSource.None">
            <summary>
Use no alpha, somewhat redundant with other settings.
</summary>
        </member>
        <member name="P:IrrlichtLime.Lime.Version">
            <summary>
Irrlicht Lime version.
</summary>
        </member>
        <member name="T:IrrlichtLime.Lime">
            <summary>
Irrlicht Lime core class. Provides wrapper common functionality.
</summary>
        </member>
        <member name="M:irr.createDeviceEx(irr.SIrrlichtCreationParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Usually you should used createDevice() for creating an Irrlicht Engine device.
	Use this function only if you wish to specify advanced parameters like a window
	handle in which the device should be created.
	\param parameters: Structure containing advanced parameters for the creation of the device.
	See irr::SIrrlichtCreationParameters for details.
	\return Returns pointer to the created IrrlichtDevice or null if the
	device could not be created. 
</member>
        <member name="M:irr.createDevice(irr.video.E_DRIVER_TYPE,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Boolean,System.Boolean,System.Boolean,irr.IEventReceiver*)">
If you need more parameters to be passed to the creation of the Irrlicht Engine device,
	use the createDeviceEx() function.
	\param driverType: Type of the video driver to use. This can currently be video::EDT_NULL,
	video::EDT_SOFTWARE, video::EDT_BURNINGSVIDEO, video::EDT_DIRECT3D9 and video::EDT_OPENGL.
	\param windowSize: Size of the window or the video mode in fullscreen mode.
	\param bits: Bits per pixel in fullscreen mode. Ignored if windowed mode.
	\param fullscreen: Should be set to true if the device should run in fullscreen. Otherwise
		the device runs in windowed mode.
	\param stencilbuffer: Specifies if the stencil buffer should be enabled. Set this to true,
	if you want the engine be able to draw stencil buffer shadows. Note that not all
	devices are able to use the stencil buffer. If they don't no shadows will be drawn.
	\param vsync: Specifies vertical synchronization: If set to true, the driver will wait
	for the vertical retrace period, otherwise not.
	\param receiver: A user created event receiver.
	\return Returns pointer to the created IrrlichtDevice or null if the
	device could not be created.

</member>
        <member name="M:irr.scene.SViewFrustum.clipLine(irr.core.line3d&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\return True if the line was clipped, false if not 
</member>
        <member name="M:irr.scene.SViewFrustum.transform(irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param mat: Matrix by which the view frustum is transformed.
</member>
        <member name="T:irr.scene.SViewFrustum">
The view frustum is enclosed by 6 planes. These six planes share
	eight points. A bounding box around these eight points is also stored in
	this structure.

</member>
        <member name="M:irr.scene.SSharedMeshBuffer.getChangedID_Index">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.SSharedMeshBuffer.getChangedID_Vertex">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.SMesh.addMeshBuffer(irr.scene.IMeshBuffer*)">
The bounding box is not updated automatically. 
</member>
        <member name="M:irr.scene.SMesh.getMeshBuffer(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
reverse search 
</member>
        <member name="M:irr.scene.SAnimatedMesh.getMeshBuffer(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param material: material to search for
		\return Returns the pointer to the mesh buffer or
		NULL if there is no such mesh buffer. 
</member>
        <member name="M:irr.scene.SAnimatedMesh.getBoundingBox">
\return A bounding box of this mesh is returned. 
</member>
        <member name="M:irr.scene.SAnimatedMesh.getMesh(System.Int32,System.Int32,System.Int32,System.Int32)">
\param frame: Frame number as zero based index. The maximum frame number is
		getFrameCount() - 1;
		\param detailLevel: Level of detail. 0 is the lowest,
		255 the highest level of detail. Most meshes will ignore the detail level.
		\param startFrameLoop: start frame
		\param endFrameLoop: end frame
		\return The animated mesh based on a detail level. 
</member>
        <member name="M:irr.scene.SAnimatedMesh.setAnimationSpeed(System.Single)">
\param fps Frames per second to play the animation with. If the amount is 0, it is not animated.
		The actual speed is set in the scene node the mesh is instantiated in.
</member>
        <member name="M:irr.scene.SAnimatedMesh.getAnimationSpeed">
\return Amount of frames per second. If the amount is 0, it is a static, non animated mesh. 
</member>
        <member name="M:irr.scene.SAnimatedMesh.getFrameCount">
\return Amount of frames. If the amount is 1, it is a static, non animated mesh. 
</member>
        <member name="M:irr.scene.ILightManager.OnNodePostRender(irr.scene.ISceneNode*)">
\param[in] node: the scene node that has just been rendered 
</member>
        <member name="M:irr.scene.ILightManager.OnNodePreRender(irr.scene.ISceneNode*)">
\param[in] node: the scene node that's about to be rendered 
</member>
        <member name="M:irr.scene.ILightManager.OnRenderPassPostRender(irr.scene.E_SCENE_NODE_RENDER_PASS)">
\param[in] renderPass: the render pass that has finished 
</member>
        <member name="M:irr.scene.ILightManager.OnRenderPassPreRender(irr.scene.E_SCENE_NODE_RENDER_PASS)">
\param renderPass: the render pass that's about to begin 
</member>
        <member name="M:irr.scene.ILightManager.OnPostRender">
After this call returns, the lightList passed to OnPreRender() becomes invalid. 
</member>
        <member name="M:irr.scene.ILightManager.OnPreRender(irr.core.array&lt;irr.scene.ISceneNode**,irr.core.irrAllocator&lt;irr.scene.ISceneNode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
As actual device/hardware lights are not created until the
		ESNRP_LIGHT render pass, this provides an opportunity for the
		light manager to trim or re-order the light list, before any
		device/hardware lights have actually been created.
		\param lightList: the Scene Manager's light list, which
		the light manager may modify. This reference will remain valid
		until OnPostRender().

</member>
        <member name="T:irr.scene.ILightManager">
The light list can be trimmed or re-ordered before device/ hardware
	lights are created, and/or individual lights can be switched on and off
	before or after each scene node is rendered. It is assumed that the
	ILightManager implementation will store any data that it wishes to
	retain, i.e. the ISceneManager to which it is assigned, the lightList,
	the current render pass, and the current scene node. 
</member>
        <member name="M:irr.io.IWriteFile.flush">
\return True if successful, otherwise false. 
</member>
        <member name="M:irr.io.IWriteFile.getFileName">
\return File name as zero terminated character string. 
</member>
        <member name="M:irr.io.IWriteFile.getPos">
\return Current position in the file in bytes on success or -1L on failure 
</member>
        <member name="M:irr.io.IWriteFile.seek(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
\param finalPos Destination position in the file.
		\param relativeMovement If set to true, the position in the file is
		changed relative to current position. Otherwise the position is changed
		from begin of file.
		\return True if successful, otherwise false. 
</member>
        <member name="M:irr.io.IWriteFile.write(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
\param buffer Pointer to buffer of bytes to write.
		\param sizeToWrite Amount of bytes to write to the file.
		\return How much bytes were written. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.loadHeightMapRAW(irr.io.IReadFile*,System.Int32,System.Boolean,System.Boolean,System.Int32,irr.video.SColor,System.Int32)">
The data is interpreted as (signed) integers of the given bit size or
		floats (with 32bits, signed). Allowed bitsizes for integers are
		8, 16, and 32. The heightmap must be square.
		\param file The file to read the RAW data from. File is not rewinded.
		\param bitsPerPixel Size of data if integers used, for floats always use 32.
		\param signedData Whether we use signed or unsigned ints, ignored for floats.
		\param floatVals Whether the data is float or int.
		\param width Width (and also Height, as it must be square) of the heightmap. Use 0 for autocalculating from the filesize.
		\param vertexColor Color of all vertices.
		\param smoothFactor Number of smoothing passes. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.loadHeightMap(irr.io.IReadFile*,irr.video.SColor,System.Int32)">
The file must contain a loadable image of the heightmap. The heightmap
		must be square.
		\param file The file to read the image from. File is not rewinded.
		\param vertexColor Color of all vertices.
		\param smoothFactor Number of smoothing passes. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.scaleTexture(System.Single,System.Single)">
\param scale The scaling amount. Values above 1.0
		increase the number of time the texture is drawn on the
		terrain. Values below 0 will decrease the number of times the
		texture is drawn on the terrain. Using negative values will
		flip the texture, as well as still scaling it.
		\param scale2 If set to 0 (default value), this will set the
		second texture coordinate set to the same values as in the
		first set. If this is another value than zero, it will scale
		the second texture coordinate set by this value. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.overrideLODDistance(System.Int32,System.Double)">
For determining the LOD a patch is rendered at. If any LOD
		is overridden, then the scene node will no longer apply scaling
		factors to these values. If you override these distances, and
		then apply a scale to the scene node, it is your responsibility
		to update the new distances to work best with your new terrain
		size. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.setDynamicSelectorUpdate(System.Boolean)">
\param bVal: Boolean value representing whether or not to update selector dynamically. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.setCameraRotationDelta(System.Single)">
It is used to determine when to recalculate
		indices for the scene node. The default value is 1.0f. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.setCameraMovementDelta(System.Single)">
It is used to determine when to recalculate
		indices for the scene node. The default value is 10.0f. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.setLODOfPatch(System.Int32,System.Int32,System.Int32)">
NOTE: Any values set here are overwritten again in the automatic
		recalculations when the camera changes.
		\param patchX Patch x coordinate.
		\param patchZ Patch z coordinate.
		\param LOD The level of detail to set the patch to. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.getIndicesForPatch(irr.core.array&lt;System.UInt32,irr.core.irrAllocator&lt;System.UInt32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
\param indices A reference to an array of u32 indices.
		\param patchX Patch x coordinate.
		\param patchZ Patch z coordinate.
		\param LOD The level of detail to get for that patch. If -1,
		then get the CurrentLOD. If the CurrentLOD is set to -1,
		meaning it's not shown, then it will retrieve the triangles at
		the highest LOD (0).
		\return Number of indices put into the buffer. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.getMeshBufferForLOD(irr.scene.IDynamicMeshBuffer*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
\param mb A reference to an IDynamicMeshBuffer object
		\param LOD The level of detail you want the indices from. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.getMesh">
\return Pointer to the mesh. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.getIndexCount">
\return The index count. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.getBoundingBox(System.Int32,System.Int32)">
\return The bounding box of the chosen patch. 
</member>
        <member name="M:irr.scene.ITerrainSceneNode.getBoundingBox">
\return The bounding box of the entire terrain. 
</member>
        <member name="T:irr.scene.ITerrainSceneNode">
The code for the TerrainSceneNode is based on the Terrain renderer by Soconne and
	 * the GeoMipMapSceneNode developed by Spintz. They made their code available for Irrlicht
	 * and allowed it to be distributed under this licence. I only modified some parts.
	 * A lot of thanks go to them.
	 *
	 * This scene node is capable of very quickly loading
	 * terrains and updating the indices at runtime to enable viewing very large terrains. It uses a
	 * CLOD (Continuous Level of Detail) algorithm which updates the indices for each patch based on
	 * a LOD (Level of Detail) which is determined based on a patch's distance from the camera.
	 *
	 * The Patch Size of the terrain must always be a size of ( 2^N+1, i.e. 8+1(9), 16+1(17), etc. ).
	 * The MaxLOD available is directly dependent on the patch size of the terrain. LOD 0 contains all
	 * of the indices to draw all the triangles at the max detail for a patch. As each LOD goes up by 1
	 * the step taken, in generating indices increases by - 2^LOD, so for LOD 1, the step taken is 2, for
	 * LOD 2, the step taken is 4, LOD 3 - 8, etc. The step can be no larger than the size of the patch,
	 * so having a LOD of 8, with a patch size of 17, is asking the algorithm to generate indices every
	 * 2^8 ( 256 ) vertices, which is not possible with a patch size of 17. The maximum LOD for a patch
	 * size of 17 is 2^4 ( 16 ). So, with a MaxLOD of 5, you'll have LOD 0 ( full detail ), LOD 1 ( every
	 * 2 vertices ), LOD 2 ( every 4 vertices ), LOD 3 ( every 8 vertices ) and LOD 4 ( every 16 vertices ).
	 *
</member>
        <member name="M:irr.scene.IShadowVolumeSceneNode.setShadowMesh(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*)">
To optimize shadow rendering, use a simpler mesh for shadows.

</member>
        <member name="T:irr.video.IShaderConstantSetCallBack">
Implement this interface in an own class and pass a pointer to it to one of
the methods in IGPUProgrammingServices when creating a shader. The
OnSetConstants method will be called every frame now. 
</member>
        <member name="M:irr.scene.ISceneUserDataSerializer.createUserData(irr.scene.ISceneNode*)">
Implement this method and return a list of attributes containing the user data
	you want to be saved together with the scene node. Return 0 if no user data should
	be added. Please note that the scene manager will call drop() to the returned pointer
	after it no longer needs it, so if you didn't create a new object for the return value
	and returning a longer existing IAttributes object, simply call grab() before returning it. 
</member>
        <member name="M:irr.scene.ISceneUserDataSerializer.OnReadUserData(irr.scene.ISceneNode*,irr.io.IAttributes*)">
The userData pointer contains a list of attributes with userData which
	were attached to the scene node in the read scene file.
</member>
        <member name="T:irr.scene.ISceneUserDataSerializer">
This interface is to be implemented by the user, to make it possible to read
and write user data when reading or writing .irr files via ISceneManager.
To be used with ISceneManager::loadScene() and ISceneManager::saveScene() 
</member>
        <member name="M:irr.scene.ISceneNodeFactory.getCreateableSceneNodeTypeName(irr.scene.ESCENE_NODE_TYPE)">
\param type: Type of scene node.
		\return: Returns name of scene node type if this factory can create the type, otherwise 0. 
</member>
        <member name="M:irr.scene.ISceneNodeFactory.getCreateableSceneNodeTypeName(System.UInt32)">
\param idx: Index of scene node type in this factory. Must be a value between 0 and
		getCreatableSceneNodeTypeCount() 
</member>
        <member name="M:irr.scene.ISceneNodeFactory.getCreateableSceneNodeType(System.UInt32)">
\param idx: Index of scene node type in this factory. Must be a value between 0 and
		getCreatableSceneNodeTypeCount() 
</member>
        <member name="M:irr.scene.ISceneNodeFactory.addSceneNode(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode*)">
\param typeName: Type name of the scene node to add.
		\param parent: Parent scene node of the new node, can be null to add the scene node to the root.
		\return Returns pointer to the new scene node or null if not successful.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneNodeFactory.addSceneNode(irr.scene.ESCENE_NODE_TYPE,irr.scene.ISceneNode*)">
\param type: Type of the scene node to add.
		\param parent: Parent scene node of the new node, can be null to add the scene node to the root.
		\return Returns pointer to the new scene node or null if not successful.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="T:irr.scene.ISceneNodeFactory">
To be able to add custom scene nodes to Irrlicht and to make it possible for the
	scene manager to save and load those external scene nodes, simply implement this
	interface and register it in you scene manager via ISceneManager::registerSceneNodeFactory.
	Note: When implementing your own scene node factory, don't call ISceneNodeManager::grab() to
	increase the reference counter of the scene node manager. This is not necessary because the
	scene node manager will grab() the factory anyway, and otherwise cyclic references will
	be created and the scene manager and all its nodes won't get deallocated.

</member>
        <member name="M:irr.scene.ISceneNodeAnimatorFactory.getCreateableSceneNodeAnimatorTypeName(irr.scene.ESCENE_NODE_ANIMATOR_TYPE)">
\param type: Type of scene node animator.
		\return: Returns name of scene node animator type if this factory can create the type, otherwise 0. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorFactory.getCreateableSceneNodeAnimatorTypeName(System.UInt32)">
\param idx: Index of scene node animator type in this factory. Must be a value between 0 and
		getCreatableSceneNodeAnimatorTypeCount() 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorFactory.getCreateableSceneNodeAnimatorType(System.UInt32)">
\param idx: Index of scene node animator type in this factory. Must be a value between 0 and
		getCreatableSceneNodeTypeCount() 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorFactory.createSceneNodeAnimator(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode*)">
\param typeName: Type of the scene node animator to add.
		\param target: Target scene node of the new animator.
		\return Returns pointer to the new scene node animator or null if not successful. You need to
		drop this pointer after calling this, see IReferenceCounted::drop() for details. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorFactory.createSceneNodeAnimator(irr.scene.ESCENE_NODE_ANIMATOR_TYPE,irr.scene.ISceneNode*)">
\param type: Type of the scene node animator to add.
		\param target: Target scene node of the new animator.
		\return Returns pointer to the new scene node animator or null if not successful. You need to
		drop this pointer after calling this, see IReferenceCounted::drop() for details. 
</member>
        <member name="T:irr.scene.ISceneNodeAnimatorFactory">
To be able to add custom scene node animators to Irrlicht and to make it possible for the
	scene manager to save and load those external animators, simply implement this
	interface and register it in you scene manager via ISceneManager::registerSceneNodeAnimatorFactory.
	Note: When implementing your own scene node factory, don't call ISceneNodeManager::grab() to
	increase the reference counter of the scene node manager. This is not necessary because the
	scene node manager will grab() the factory anyway, and otherwise cyclic references will
	be created and the scene manager and all its nodes won't get deallocated.

</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.setCollisionCallback(irr.scene.ICollisionCallback*)">
\param callback: collision callback handler that will be called when a collision
		occurs. Set this to 0 to disable the callback.

</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.getCollisionResultPosition">
If you have a collision callback registered, and it consumes the collision, then the
node will ignore the collision and will not stop at this position. Instead, it will
move fully to the position that caused the collision to occur. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.getTargetNode">
\return The node that this animator is acting on. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.setTargetNode(irr.scene.ISceneNode*)">
\param node The new target node. Setting this will force the animator to update
					its last target position for the node, allowing setPosition() to teleport
					the node through collision geometry. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.setWorld(irr.scene.ITriangleSelector*)">
\param newWorld: New triangle selector containing triangles
		to let the scene node collide with. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.getEllipsoidTranslation">
See
		ISceneNodeAnimatorCollisionResponse::setEllipsoidTranslation()
		for more details.
		\return Translation of the ellipsoid relative to the position
		of the scene node. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.setEllipsoidTranslation(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
By default, the ellipsoid for collision detection is
		created around the center of the scene node, which means that
		the ellipsoid surrounds it completely. If this is not what you
		want, you may specify a translation for the ellipsoid.
		\param translation: Translation of the ellipsoid relative
		to the position of the scene node. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.jump(System.Single)">
\param jumpSpeed The initial speed of the jump; the velocity will be opposite
		to this animator's gravity vector. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.setGravity(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A good example value would be core::vector3df(0,-100.0f,0)
		for letting gravity affect all object to fall down. For bigger
		gravity, make increase the length of the vector. You can
		disable gravity by setting it to core::vector3df(0,0,0);
		\param gravity: New gravity vector. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.getEllipsoidRadius">
\return Radius of the ellipsoid. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCollisionResponse.isFalling">
Falling means that there is no blocking wall from the scene
		node in the direction of the gravity. The implementation of
		this method is very fast, no collision detection is done when
		invoking it.
		\return True if the scene node is falling, false if not. 
</member>
        <member name="T:irr.scene.ISceneNodeAnimatorCollisionResponse">
This scene node animator can be attached to any single scene node
	and will then prevent it from moving through specified collision geometry
	(e.g. walls and floors of the) world, as well as having it fall under gravity.
	This animator provides a simple implementation of first person shooter cameras.
	Attach it to a camera, and the camera will behave as the player control in a
	first person shooter game: The camera stops and slides at walls, walks up stairs,
	falls down if there is no floor under it, and so on.

	The animator will treat any change in the position of its target scene
	node as movement, including a setPosition(), as movement.  If you want to
	teleport the target scene node manually to a location without it being effected
	by collision geometry, then call setTargetNode(node) after calling node-&gt;setPosition().

</member>
        <member name="M:irr.scene.ICollisionCallback.onCollision(irr.scene.ISceneNodeAnimatorCollisionResponse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
See ISceneNodeAnimatorCollisionResponse::setCollisionCallback for more information.
		\param animator: Collision response animator in which the collision occurred. You can call
		this animator's methods to find the node, collisionPoint and/or collision triangle.
		\retval true if the collision was handled in the animator. The animator's target
		node will *not* be stopped at the collision point, but will instead move fully
		to the location that triggered the collision check.
		\retval false if the collision was not handled in the animator. The animator's
		target node will be moved to the collision position.

</member>
        <member name="T:irr.scene.ICollisionCallback">
Implement this interface and use
	ISceneNodeAnimatorCollisionResponse::setCollisionCallback to be able to
	be notified if a collision has occurred.
	*
</member>
        <member name="T:irr.scene.ISceneNodeAnimatorCameraMaya">
This scene node animator can be attached to a camera to make it act like a 3d
	modeling tool.
	The camera is moving relative to the target with the mouse, by pressing either
	of the three buttons.
	In order to move the camera, set a new target for the camera. The distance defines
	the current orbit radius the camera moves on. Distance can be changed via the setter
	or by mouse events.

</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCameraFPS.setInvertMouse(System.Boolean)">
If enabled then moving the mouse down will cause
		the camera to look up. It is disabled by default. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCameraFPS.setVerticalMovement(System.Boolean)">
If vertical movement is enabled then the camera may fight with
		gravity causing camera shake. Disable this if the camera has
		a collision animator with gravity enabled. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCameraFPS.setKeyMap(irr.SKeyMap*,System.UInt32)">
\param map Array of keyboard mappings, see irr::SKeyMap
		\param count Size of the keyboard map array. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimatorCameraFPS.getRotateSpeed">
The degrees are equivalent to a half screen movement of the mouse,
		i.e. if the mouse cursor had been moved to the border of the screen since
		the last animation. 
</member>
        <member name="T:irr.scene.ISceneNodeAnimatorCameraFPS">
This scene node animator can be attached to a camera to make it act
	like a first person shooter

</member>
        <member name="M:irr.scene.ISceneManager.isCulled(irr.scene.ISceneNode!System.Runtime.CompilerServices.IsConst*)">
Please note that depending on the used culling method this
		check can be rather coarse, or slow. A positive result is
		correct, though, i.e. if this method returns true the node is
		positively not visible. The node might still be invisible even
		if this method returns false.
		\param node The scene node which is checked for culling.
		\return True if node is not visible in the current scene, else
		false. 
</member>
        <member name="M:irr.scene.ISceneManager.getGeometryCreator">
The geometry creator provides some helper methods to create various types of
		basic geometry. This can be useful for custom scene nodes. 
</member>
        <member name="M:irr.scene.ISceneManager.setLightManager(irr.scene.ILightManager*)">
\param[in] lightManager: the new callbacks manager. You may pass 0 to remove the
			current callbacks manager and restore the default behavior. 
</member>
        <member name="M:irr.scene.ISceneManager.createSkinnedMesh">
Note: You need to drop() the pointer after use again, see IReferenceCounted::drop()
		for details. 
</member>
        <member name="M:irr.scene.ISceneManager.createMeshWriter(irr.scene.EMESH_WRITER_TYPE)">
Note: You need to drop() the pointer after use again, see IReferenceCounted::drop()
		for details. 
</member>
        <member name="M:irr.scene.ISceneManager.loadScene(irr.io.IReadFile*,irr.scene.ISceneUserDataSerializer*,irr.scene.ISceneNode*)">
The scene is usually loaded from an .irr file, an xml based
		format, but other scene formats can be added to the engine via
		ISceneManager::addExternalSceneLoader. .irr files can Be edited
		with the Irrlicht Engine Editor, irrEdit
		(http://www.ambiera.com/irredit/) or saved directly by the engine
		using ISceneManager::saveScene().
		\param file File where the scene is loaded from.
		\param userDataSerializer If you want to load user data
		saved in that file for some scene nodes in the file,
		implement the ISceneUserDataSerializer interface and provide it
		as parameter here. Otherwise, simply specify 0 as this
		parameter.
		\param rootNode Node which is taken as the root node of the
		scene. Pass 0 to add the scene directly to the scene manager
		(which is also the default).
		\return True if successful. 
</member>
        <member name="M:irr.scene.ISceneManager.loadScene(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ISceneUserDataSerializer*,irr.scene.ISceneNode*)">
The scene is usually loaded from an .irr file, an xml based
		format, but other scene formats can be added to the engine via
		ISceneManager::addExternalSceneLoader. .irr files can Be edited
		with the Irrlicht Engine Editor, irrEdit
		(http://www.ambiera.com/irredit/) or saved directly by the engine
		using ISceneManager::saveScene().
		\param filename Name of the file to load from.
		\param userDataSerializer If you want to load user data
		possibily saved in that file for some scene nodes in the file,
		implement the ISceneUserDataSerializer interface and provide it
		as parameter here. Otherwise, simply specify 0 as this
		parameter.
		\param rootNode Node which is taken as the root node of the
		scene. Pass 0 to add the scene directly to the scene manager
		(which is also the default).
		\return True if successful. 
</member>
        <member name="M:irr.scene.ISceneManager.saveScene(irr.io.IIrrXMLWriter&lt;System.Char,irr.IReferenceCounted&gt;*,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ISceneUserDataSerializer*,irr.scene.ISceneNode*)">
Scene nodes with the option isDebugObject set to true are
		not being saved. The scene is usually written to an .irr file,
		an xml based format. .irr files can Be edited with the Irrlicht
		Engine Editor, irrEdit (http://www.ambiera.com/irredit/). To
		load .irr files again, see ISceneManager::loadScene().
		\param writer XMLWriter with which the scene is saved.
		\param currentPath Path which is used for relative file names.
		Usually the directory of the file written into.
		\param userDataSerializer If you want to save some user data
		for every scene node into the file, implement the
		ISceneUserDataSerializer interface and provide it as parameter
		here. Otherwise, simply specify 0 as this parameter.
		\param node Node which is taken as the top node of the scene.
		This node and all of its descendants are saved into the scene
		file. Pass 0 or the scene manager to save the full scene (which
		is also the default).
		\return True if successful. 
</member>
        <member name="M:irr.scene.ISceneManager.saveScene(irr.io.IWriteFile*,irr.scene.ISceneUserDataSerializer*,irr.scene.ISceneNode*)">
Scene nodes with the option isDebugObject set to true are
		not being saved. The scene is usually written to an .irr file,
		an xml based format. .irr files can Be edited with the Irrlicht
		Engine Editor, irrEdit (http://www.ambiera.com/irredit/). To
		load .irr files again, see ISceneManager::loadScene().
		\param file File where the scene is saved into.
		\param userDataSerializer If you want to save some user data
		for every scene node into the file, implement the
		ISceneUserDataSerializer interface and provide it as parameter
		here. Otherwise, simply specify 0 as this parameter.
		\param node Node which is taken as the top node of the scene.
		This node and all of its descendants are saved into the scene
		file. Pass 0 or the scene manager to save the full scene (which
		is also the default).
		\return True if successful. 
</member>
        <member name="M:irr.scene.ISceneManager.saveScene(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ISceneUserDataSerializer*,irr.scene.ISceneNode*)">
Scene nodes with the option isDebugObject set to true are
		not being saved. The scene is usually written to an .irr file,
		an xml based format. .irr files can Be edited with the Irrlicht
		Engine Editor, irrEdit (http://www.ambiera.com/irredit/). To
		load .irr files again, see ISceneManager::loadScene().
		\param filename Name of the file.
		\param userDataSerializer If you want to save some user data
		for every scene node into the file, implement the
		ISceneUserDataSerializer interface and provide it as parameter
		here. Otherwise, simply specify 0 as this parameter.
		\param node Node which is taken as the top node of the scene.
		This node and all of its descendants are saved into the scene
		file. Pass 0 or the scene manager to save the full scene (which
		is also the default).
		\return True if successful. 
</member>
        <member name="M:irr.scene.ISceneManager.createNewSceneManager(System.Boolean)">
This can be used to easily draw and/or store two
		independent scenes at the same time. The mesh cache will be
		shared between all existing scene managers, which means if you
		load a mesh in the original scene manager using for example
		getMesh(), the mesh will be available in all other scene
		managers too, without loading.
		The original/main scene manager will still be there and
		accessible via IrrlichtDevice::getSceneManager(). If you need
		input event in this new scene manager, for example for FPS
		cameras, you'll need to forward input to this manually: Just
		implement an IEventReceiver and call
		yourNewSceneManager-&gt;postEventFromUser(), and return true so
		that the original scene manager doesn't get the event.
		Otherwise, all input will go to the main scene manager
		automatically.
		If you no longer need the new scene manager, you should call
		ISceneManager::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createSceneNodeAnimator(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode*)">
\param typeName: Type of the scene node animator to add.
		\param target: Target scene node of the new animator.
		\return Returns pointer to the new scene node animator or null if not successful. You need to
		drop this pointer after calling this, see IReferenceCounted::drop() for details. 
</member>
        <member name="M:irr.scene.ISceneManager.addSceneNode(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode*)">
\return Pointer to the scene node added by a factory
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneNodeAnimatorFactory(System.UInt32)">
\return Pointer to the requested scene node animator factory, or 0 if it does not exist.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.registerSceneNodeAnimatorFactory(irr.scene.ISceneNodeAnimatorFactory*)">
Use this to extend the scene manager with new scene node animator types which it should be
		able to create automatically, for example when loading data from xml files. 
</member>
        <member name="M:irr.scene.ISceneManager.getDefaultSceneNodeAnimatorFactory">
\return Pointer to the default scene node animator factory
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneNodeFactory(System.UInt32)">
\return Pointer to the requested scene node factory, or 0 if it does not exist.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.registerSceneNodeFactory(irr.scene.ISceneNodeFactory*)">
Use this to extend the scene manager with new scene node types which it should be
		able to create automatically, for example when loading data from xml files. 
</member>
        <member name="M:irr.scene.ISceneManager.getDefaultSceneNodeFactory">
\return Pointer to the default scene node factory
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneNodeRenderPass">
All scene nodes are being rendered in a specific order.
		First lights, cameras, sky boxes, solid geometry, and then transparent
		stuff. During the rendering process, scene nodes may want to know what the scene
		manager is rendering currently, because for example they registered for rendering
		twice, once for transparent geometry and once for solid. When knowing what rendering
		pass currently is active they can render the correct part of their geometry. 
</member>
        <member name="M:irr.scene.ISceneManager.getParameters">
String parameters can be used by plugins and mesh loaders.
		See	COLLADA_CREATE_SCENE_INSTANCES and DMF_USE_MATERIALS_DIRS 
</member>
        <member name="M:irr.scene.ISceneManager.clear">
All scene nodes are removed. 
</member>
        <member name="M:irr.scene.ISceneManager.postEventFromUser(irr.SEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Usually you do not have to
		use this method, it is used by the internal engine. 
</member>
        <member name="M:irr.scene.ISceneManager.addToDeletionQueue(irr.scene.ISceneNode*)">
The scene node is immediately
		deleted when it's secure. Which means when the scene node does not
		execute animators and things like that. This method is for example
		used for deleting scene nodes by their scene node animators. In
		most other cases, a ISceneNode::remove() call is enough, using this
		deletion queue is not necessary.
		See ISceneManager::createDeleteAnimator() for details.
		\param node: Node to delete. 
</member>
        <member name="M:irr.scene.ISceneManager.getMeshManipulator">
\return Pointer to the mesh manipulator
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneCollisionManager">
\return Pointer to the collision manager
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneLoader(System.UInt32)">
\param index The index of the loader to retrieve. This parameter is an 0-based
		array index.
		\return A pointer to the specified loader, 0 if the index is incorrect. 
</member>
        <member name="M:irr.scene.ISceneManager.addExternalSceneLoader(irr.scene.ISceneLoader*)">
If you want the engine to be extended with
		file formats it currently is not able to load (e.g. .vrml), just implement
		the ISceneLoader interface in your loading class and add it with this method.
		Using this method it is also possible to override the built-in scene loaders
		with newer or updated versions without the need to recompile the engine.
		\param externalLoader: Implementation of a new mesh loader. 
</member>
        <member name="M:irr.scene.ISceneManager.getMeshLoader(System.UInt32)">
\param index The index of the loader to retrieve. This parameter is an 0-based
		array index.
		\return A pointer to the specified loader, 0 if the index is incorrect. 
</member>
        <member name="M:irr.scene.ISceneManager.addExternalMeshLoader(irr.scene.IMeshLoader*)">
If you want the engine to be extended with
		file formats it currently is not able to load (e.g. .cob), just implement
		the IMeshLoader interface in your loading class and add it with this method.
		Using this method it is also possible to override built-in mesh loaders with
		newer or updated versions without the need to recompile the engine.
		\param externalLoader: Implementation of a new mesh loader. 
</member>
        <member name="M:irr.scene.ISceneManager.createTerrainTriangleSelector(irr.scene.ITerrainSceneNode*,System.Int32)">
\param node: Pointer to the created terrain scene node
		\param LOD: Level of detail, 0 for highest detail.
		\return The selector, or null if not successful.
		If you no longer need the selector, you should call ITriangleSelector::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createMetaTriangleSelector">
A meta triangle selector is nothing more than a
		collection of one or more triangle selectors providing together
		the interface of one triangle selector. In this way,
		collision tests can be done with different triangle soups in one pass.
		\return The selector, or null if not successful.
		If you no longer need the selector, you should call ITriangleSelector::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createOctTreeTriangleSelector(irr.scene.IMesh*,irr.scene.ISceneNode*,System.Int32)">
\deprecated Use createOctreeTriangleSelector instead. This method may be removed by Irrlicht 1.9. 
</member>
        <member name="M:irr.scene.ISceneManager.createOctreeTriangleSelector(irr.scene.IMeshBuffer*,System.UInt32,irr.scene.ISceneNode*,System.Int32)">
Triangle selectors
		can be used for doing collision detection. This triangle selector is
		optimized for huge amounts of triangle, it organizes them in an octree.
		Please note that the created triangle selector is not automatically attached
		to the scene node. You will have to call ISceneNode::setTriangleSelector()
		for this. To create and attach a triangle selector is done like this:
		\code
		ITriangleSelector* s = sceneManager-&gt;createOctreeTriangleSelector(yourMesh,
				yourSceneNode);
		yourSceneNode-&gt;setTriangleSelector(s);
		s-&gt;drop();
		\endcode
		For more information and examples on this, take a look at the collision
		tutorial in the SDK.
		\param meshBuffer: Meshbuffer of which the triangles are taken.
		\param materialIndex: Setting this value allows the triangle selector to return the material index
		\param node: Scene node of which visibility and transformation is used.
		\param minimalPolysPerNode: Specifies the minimal polygons contained a octree node.
		If a node gets less polys than this value, it will not be split into
		smaller nodes.
		\return The selector, or null if not successful.
		If you no longer need the selector, you should call ITriangleSelector::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createOctreeTriangleSelector(irr.scene.IMesh*,irr.scene.ISceneNode*,System.Int32)">
Triangle selectors
		can be used for doing collision detection. This triangle selector is
		optimized for huge amounts of triangle, it organizes them in an octree.
		Please note that the created triangle selector is not automatically attached
		to the scene node. You will have to call ISceneNode::setTriangleSelector()
		for this. To create and attach a triangle selector is done like this:
		\code
		ITriangleSelector* s = sceneManager-&gt;createOctreeTriangleSelector(yourMesh,
				yourSceneNode);
		yourSceneNode-&gt;setTriangleSelector(s);
		s-&gt;drop();
		\endcode
		For more information and examples on this, take a look at the collision
		tutorial in the SDK.
		\param mesh: Mesh of which the triangles are taken.
		\param node: Scene node of which visibility and transformation is used.
		\param minimalPolysPerNode: Specifies the minimal polygons contained a octree node.
		If a node gets less polys than this value, it will not be split into
		smaller nodes.
		\return The selector, or null if not successful.
		If you no longer need the selector, you should call ITriangleSelector::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createTriangleSelectorFromBoundingBox(irr.scene.ISceneNode*)">
Triangle selectors
		can be used for doing collision detection. Every time when triangles are
		queried, the triangle selector gets the bounding box of the scene node,
		an creates new triangles. In this way, it works good with animated scene nodes.
		\param node: Scene node of which the bounding box, visibility and transformation is used.
		\return The selector, or null if not successful.
		If you no longer need the selector, you should call ITriangleSelector::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createTriangleSelector(irr.scene.IAnimatedMeshSceneNode*,System.Boolean)">
Details of the mesh associated with the node will be extracted internally.
		\param node The animated mesh scene node from which to build the selector
		\param separateMeshbuffers: When true it's possible to get information which meshbuffer
		got hit in collision tests. But has a slight speed cost.

</member>
        <member name="M:irr.scene.ISceneManager.createTriangleSelector(irr.scene.IMeshBuffer!System.Runtime.CompilerServices.IsConst*,System.UInt32,irr.scene.ISceneNode*)">
This is a static selector which won't update when the mesh changes.
\param meshBuffer Triangles of that meshbuffer are used
\param materialIndex If you pass a material index that index can be returned by the triangle selector.
\para node: Scene node of which transformation is used.

</member>
        <member name="M:irr.scene.ISceneManager.createTriangleSelector(irr.scene.IMesh*,irr.scene.ISceneNode*,System.Boolean)">
Triangle selectors
		can be used for doing collision detection. Don't use this selector
		for a huge amount of triangles like in Quake3 maps.
		Instead, use for example ISceneManager::createOctreeTriangleSelector().
		Please note that the created triangle selector is not automatically attached
		to the scene node. You will have to call ISceneNode::setTriangleSelector()
		for this. To create and attach a triangle selector is done like this:
		\code
		ITriangleSelector* s = sceneManager-&gt;createTriangleSelector(yourMesh,
				yourSceneNode);
		yourSceneNode-&gt;setTriangleSelector(s);
		s-&gt;drop();
		\endcode
		\param mesh: Mesh of which the triangles are taken.
		\param node: Scene node of which transformation is used.
		\param separateMeshbuffers: When true it's possible to get information which meshbuffer
		got hit in collision tests. But has a slight speed cost.
		\return The selector, or null if not successful.
		If you no longer need the selector, you should call ITriangleSelector::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createFollowSplineAnimator(System.Int32,irr.core.array&lt;irr.core.vector3d&lt;System.Single&gt;,irr.core.irrAllocator&lt;irr.core.vector3d&lt;System.Single&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Boolean,System.Boolean)">
The animator modifies the position of
		the attached scene node to make it follow a Hermite spline.
		It uses a subset of Hermite splines: either cardinal splines
		(tightness != 0.5) or Catmull-Rom-splines (tightness == 0.5).
		The animator moves from one control point to the next in
		1/speed seconds. This code was sent in by Matthias Gall.
		If you no longer need the animator, you should call ISceneNodeAnimator::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createDeleteAnimator(System.UInt32)">
\param timeMs: Time in milliseconds, after when the node will be deleted.
		\return The animator. Attach it to a scene node with ISceneNode::addAnimator()
		and the animator will animate it.
		If you no longer need the animator, you should call ISceneNodeAnimator::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createTextureAnimator(irr.core.array&lt;irr.video.ITexture**,irr.core.irrAllocator&lt;irr.video.ITexture**&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
\param textures: List of textures to use.
		\param timePerFrame: Time in milliseconds, how long any texture in the list
		should be visible.
		\param loop: If set to to false, the last texture remains set, and the animation
		stops. If set to true, the animation restarts with the first texture.
		\return The animator. Attach it to a scene node with ISceneNode::addAnimator()
		and the animator will animate it.
		If you no longer need the animator, you should call ISceneNodeAnimator::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createFlyStraightAnimator(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Boolean,System.Boolean)">
\param startPoint: Start point of the line.
		\param endPoint: End point of the line.
		\param timeForWay: Time in milliseconds how long the node should need to
		move from the start point to the end point.
		\param loop: If set to false, the node stops when the end point is reached.
		If loop is true, the node begins again at the start.
		\param pingpong Flag to set whether the animator should fly
		back from end to start again.
		\return The animator. Attach it to a scene node with ISceneNode::addAnimator()
		and the animator will animate it.
		If you no longer need the animator, you should call ISceneNodeAnimator::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createFlyCircleAnimator(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
\param center: Center of the circle.
		\param radius: Radius of the circle.
		\param speed: The orbital speed, in radians per millisecond.
		\param direction: Specifies the upvector used for alignment of the mesh.
		\param startPosition: The position on the circle where the animator will
		begin. Value is in multiples of a circle, i.e. 0.5 is half way around. (phase)
		\param radiusEllipsoid: if radiusEllipsoid != 0 then radius2 from a ellipsoid
		begin. Value is in multiples of a circle, i.e. 0.5 is half way around. (phase)
		\return The animator. Attach it to a scene node with ISceneNode::addAnimator()
		and the animator will animate it.
		If you no longer need the animator, you should call ISceneNodeAnimator::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.createRotationAnimator(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param rotationSpeed Specifies the speed of the animation in degree per 10 milliseconds.
		\return The animator. Attach it to a scene node with ISceneNode::addAnimator()
		and the animator will animate it.
		If you no longer need the animator, you should call ISceneNodeAnimator::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.drawAll">
This can only be invoked between
		IVideoDriver::beginScene() and IVideoDriver::endScene(). Please note that
		the scene is not only drawn when calling this, but also animated
		by existing scene node animators, culling of scene nodes is done, etc. 
</member>
        <member name="M:irr.scene.ISceneManager.clearAllRegisteredNodesForRendering">
Usually you don't have to care about this as drawAll will clear nodes
		after rendering them. But sometimes you might have to manully reset this.
		For example when you deleted nodes between registering and rendering. 
</member>
        <member name="M:irr.scene.ISceneManager.registerNodeForRendering(irr.scene.ISceneNode*,irr.scene.E_SCENE_NODE_RENDER_PASS)">
This method should only be used by SceneNodes when they get a
		ISceneNode::OnRegisterSceneNode() call.
		\param node: Node to register for drawing. Usually scene nodes would set 'this'
		as parameter here because they want to be drawn.
		\param pass: Specifies when the node wants to be drawn in relation to the other nodes.
		For example, if the node is a shadow, it usually wants to be drawn after all other nodes
		and will use ESNRP_SHADOW for this. See scene::E_SCENE_NODE_RENDER_PASS for details.
		\return scene will be rendered ( passed culling ) 
</member>
        <member name="M:irr.scene.ISceneManager.setActiveCamera(irr.scene.ICameraSceneNode*)">
The previous active camera will be deactivated.
		\param camera: The new camera which should be active. 
</member>
        <member name="M:irr.scene.ISceneManager.getActiveCamera">
\return The active camera is returned. Note that this can
		be NULL, if there was no camera created yet.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneNodesFromType(irr.scene.ESCENE_NODE_TYPE,irr.core.array&lt;irr.scene.ISceneNode**,irr.core.irrAllocator&lt;irr.scene.ISceneNode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ISceneNode*)">
\param type: Type of scene node to find (ESNT_ANY will return all child nodes).
		\param outNodes: results will be added to this array (outNodes is not cleared).
		\param start: Scene node to start from. This node and all children of this scene
		node are checked (recursively, so also children of children, etc). If null is specified,
		the root scene node is taken as start-node. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneNodeFromType(irr.scene.ESCENE_NODE_TYPE,irr.scene.ISceneNode*)">
\param type: The type to search for
		\param start: Scene node to start from. All children of this scene
		node are searched. If null is specified, the root scene node is
		taken.
		\return Pointer to the first scene node with this type,
		and null if no scene node could be found.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneNodeFromName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode*)">
\param name: The name to search for
		\param start: Scene node to start from. All children of this scene
		node are searched. If null is specified, the root scene node is
		taken.
		\return Pointer to the first scene node with this id,
		and null if no scene node could be found.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getSceneNodeFromId(System.Int32,irr.scene.ISceneNode*)">
\param id: The id to search for
		\param start: Scene node to start from. All children of this scene
		node are searched. If null is specified, the root scene node is
		taken.
		\return Pointer to the first scene node with this id,
		and null if no scene node could be found.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getRootSceneNode">
This is the scene node which is parent
		of all scene nodes. The root scene node is a special scene node which
		only exists to manage all scene nodes. It will not be rendered and cannot
		be removed from the scene.
		\return Pointer to the root scene node.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addVolumeLightMesh(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst)">
\param name Name of the mesh
		\param SubdivideU Horizontal subdivision count
		\param SubdivideV Vertical subdivision count
		\param FootColor Color of the bottom of the light
		\param TailColor Color of the top of the light
		\return Pointer to the volume light mesh if successful, otherwise 0.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information.

</member>
        <member name="M:irr.scene.ISceneManager.addSphereMesh(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.UInt32,System.UInt32)">
\param name Name of the mesh
		\param radius Radius of the sphere
		\param polyCountX Number of quads used for the horizontal tiling
		\param polyCountY Number of quads used for the vertical tiling
		\return Pointer to the sphere mesh if successful, otherwise 0.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addArrowMesh(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor,irr.video.SColor,System.UInt32,System.UInt32,System.Single,System.Single,System.Single,System.Single)">
\param name Name of the mesh
		\param vtxColorCylinder color of the cylinder
		\param vtxColorCone color of the cone
		\param tesselationCylinder Number of quads the cylinder side consists of
		\param tesselationCone Number of triangles the cone's roof consists of
		\param height Total height of the arrow
		\param cylinderHeight Total height of the cylinder, should be lesser than total height
		\param widthCylinder Diameter of the cylinder
		\param widthCone Diameter of the cone's base, should be not smaller than the cylinder's diameter
		\return Pointer to the arrow mesh if successful, otherwise 0.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addTerrainMesh(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.IImage*,irr.video.IImage*,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The mesh is generated on the fly
		from a texture file and a height map file. Both files may be huge
		(8000x8000 pixels would be no problem) because the generator splits the
		files into smaller textures if necessary.
		You must specify a name for the mesh, because the mesh is added to the mesh pool,
		and can be retrieved again using ISceneManager::getMesh() with the name as parameter.
		\param meshname: The name of this mesh which must be specified in order
		to be able to retrieve the mesh later with ISceneManager::getMesh().
		\param texture: Texture for the terrain. Please note that this is not a
		hardware texture as usual (ITexture), but an IImage software texture.
		You can load this texture with IVideoDriver::createImageFromFile().
		\param heightmap: A grayscaled heightmap image. Like the texture,
		it can be created with IVideoDriver::createImageFromFile(). The amount
		of triangles created depends on the size of this texture, so use a small
		heightmap to increase rendering speed.
		\param stretchSize: Parameter defining how big a is pixel on the heightmap.
		\param maxHeight: Defines how high a white pixel on the heightmap is.
		\param defaultVertexBlockSize: Defines the initial dimension between vertices.
		\return Null if the creation failed. The reason could be that you
		specified some invalid parameters, that a mesh with that name already
		exists, or that a texture could not be found. If successful, a pointer to the mesh is returned.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addHillPlaneMesh(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SMaterial*,System.Single,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The mesh is generated on the fly
		and looks like a plane with some hills on it. It is uses mostly for quick
		tests of the engine only. You can specify how many hills there should be
		on the plane and how high they should be. Also you must specify a name for
		the mesh, because the mesh is added to the mesh pool, and can be retrieved
		again using ISceneManager::getMesh() with the name as parameter.
		\param name: The name of this mesh which must be specified in order
		to be able to retrieve the mesh later with ISceneManager::getMesh().
		\param tileSize: Size of a tile of the mesh. (10.0f, 10.0f) would be a
		good value to start, for example.
		\param tileCount: Specifies how much tiles there will be. If you specify
		for example that a tile has the size (10.0f, 10.0f) and the tileCount is
		(10,10), than you get a field of 100 tiles which has the dimension 100.0f x 100.0f.
		\param material: Material of the hill mesh.
		\param hillHeight: Height of the hills. If you specify a negative value
		you will get holes instead of hills. If the height is 0, no hills will be
		created.
		\param countHills: Amount of hills on the plane. There will be countHills.X
		hills along the X axis and countHills.Y along the Y axis. So in total there
		will be countHills.X * countHills.Y hills.
		\param textureRepeatCount: Defines how often the texture will be repeated in
		x and y direction.
		return Null if the creation failed. The reason could be that you
		specified some invalid parameters or that a mesh with that name already
		exists. If successful, a pointer to the mesh is returned.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addBillboardTextSceneNode(irr.gui.IGUIFont*,System.Char!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode*,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,irr.video.SColor,irr.video.SColor)">
\param font The font to use on the billboard. Pass 0 to use the GUI environment's default font.
\param text The text to display on the billboard.
\param parent The billboard's parent. Pass 0 to use the root scene node.
\param size The billboard's width and height.
\param position The billboards position relative to its parent.
\param id: An id of the node. This id can be used to identify the node.
\param colorTop: The color of the vertices at the top of the billboard (default: white).
\param colorBottom: The color of the vertices at the bottom of the billboard (default: white).
\return Pointer to the billboard if successful, otherwise NULL.
This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addDummyTransformationSceneNode(irr.scene.ISceneNode*,System.Int32)">
This scene node does not render itself, and does not respond to set/getPosition,
		set/getRotation and set/getScale. Its just a simple scene node that takes a
		matrix as relative transformation, making it possible to insert any transformation
		anywhere into the scene graph.
		\return Pointer to the created scene node.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addEmptySceneNode(irr.scene.ISceneNode*,System.Int32)">
Can be used for doing advanced transformations
		or structuring the scene graph.
		\return Pointer to the created scene node.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addQuake3SceneNode(irr.scene.IMeshBuffer!System.Runtime.CompilerServices.IsConst*,irr.scene.quake3.IShader!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode*,System.Int32)">
A Quake3 Scene renders multiple meshes for a specific HighLanguage Shader (Quake3 Style )
		\return Pointer to the quake3 scene node if successful, otherwise NULL.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addTerrainSceneNode(irr.io.IReadFile*,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor,System.Int32,irr.scene.E_TERRAIN_PATCH_SIZE,System.Int32,System.Boolean)">
Just like the other addTerrainSceneNode() method, but takes an IReadFile
		pointer as parameter for the heightmap. For more information take a look
		at the other function.
		\param heightMapFile: The file handle to read vertex data from. This should
		be a gray scale bitmap.
		\param parent: Parent of the scene node. Can be 0 if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: The absolute position of this node.
		\param rotation: The absolute rotation of this node. ( NOT YET IMPLEMENTED )
		\param scale: The scale factor for the terrain. If you're
		using a heightmap of size 129x129 and would like your terrain
		to be 12900x12900 in game units, then use a scale factor of (
		core::vector ( 100.0f, 100.0f, 100.0f ). If you use a Y
		scaling factor of 0.0f, then your terrain will be flat.
		\param vertexColor: The default color of all the vertices. If no texture is associated
		with the scene node, then all vertices will be this color. Defaults to white.
		\param maxLOD: The maximum LOD (level of detail) for the node. Only change if you
		know what you are doing, this might lead to strange behavior.
		\param patchSize: patch size of the terrain. Only change if you
		know what you are doing, this might lead to strange behavior.
		\param smoothFactor: The number of times the vertices are smoothed.
		\param addAlsoIfHeightmapEmpty: Add terrain node even with empty heightmap.
		\return Pointer to the created scene node. Can be null
		if the terrain could not be created, for example because the
		heightmap could not be loaded. The returned pointer should
		not be dropped. See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.scene.ISceneManager.addTerrainSceneNode(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor,System.Int32,irr.scene.E_TERRAIN_PATCH_SIZE,System.Int32,System.Boolean)">
This node implements is a simple terrain renderer which uses
		a technique known as geo mip mapping
		for reducing the detail of triangle blocks which are far away.
		The code for the TerrainSceneNode is based on the terrain
		renderer by Soconne and the GeoMipMapSceneNode developed by
		Spintz. They made their code available for Irrlicht and allowed
		it to be distributed under this licence. I only modified some
		parts. A lot of thanks go to them.

		This scene node is capable of loading terrains and updating
		the indices at runtime to enable viewing very large terrains
		very quickly. It uses a CLOD (Continuous Level of Detail)
		algorithm which updates the indices for each patch based on
		a LOD (Level of Detail) which is determined based on a patch's
		distance from the camera.

		The patch size of the terrain must always be a size of 2^N+1,
		i.e. 8+1(9), 16+1(17), etc.
		The MaxLOD available is directly dependent on the patch size
		of the terrain. LOD 0 contains all of the indices to draw all
		the triangles at the max detail for a patch. As each LOD goes
		up by 1 the step taken, in generating indices increases by
		-2^LOD, so for LOD 1, the step taken is 2, for LOD 2, the step
		taken is 4, LOD 3 - 8, etc. The step can be no larger than
		the size of the patch, so having a LOD of 8, with a patch size
		of 17, is asking the algorithm to generate indices every 2^8 (
		256 ) vertices, which is not possible with a patch size of 17.
		The maximum LOD for a patch size of 17 is 2^4 ( 16 ). So,
		with a MaxLOD of 5, you'll have LOD 0 ( full detail ), LOD 1 (
		every 2 vertices ), LOD 2 ( every 4 vertices ), LOD 3 ( every
		8 vertices ) and LOD 4 ( every 16 vertices ).
		\param heightMapFileName: The name of the file on disk, to read vertex data from. This should
		be a gray scale bitmap.
		\param parent: Parent of the scene node. Can be 0 if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: The absolute position of this node.
		\param rotation: The absolute rotation of this node. ( NOT YET IMPLEMENTED )
		\param scale: The scale factor for the terrain. If you're
		using a heightmap of size 129x129 and would like your terrain
		to be 12900x12900 in game units, then use a scale factor of (
		core::vector ( 100.0f, 100.0f, 100.0f ). If you use a Y
		scaling factor of 0.0f, then your terrain will be flat.
		\param vertexColor: The default color of all the vertices. If no texture is associated
		with the scene node, then all vertices will be this color. Defaults to white.
		\param maxLOD: The maximum LOD (level of detail) for the node. Only change if you
		know what you are doing, this might lead to strange behavior.
		\param patchSize: patch size of the terrain. Only change if you
		know what you are doing, this might lead to strange behavior.
		\param smoothFactor: The number of times the vertices are smoothed.
		\param addAlsoIfHeightmapEmpty: Add terrain node even with empty heightmap.
		\return Pointer to the created scene node. Can be null
		if the terrain could not be created, for example because the
		heightmap could not be loaded. The returned pointer should
		not be dropped. See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.scene.ISceneManager.addParticleSystemSceneNode(System.Boolean,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param withDefaultEmitter: Creates a default working point emitter
		which emits some particles. Set this to true to see a particle system
		in action. If set to false, you'll have to set the emitter you want by
		calling IParticleSystemSceneNode::setEmitter().
		\param parent: Parent of the scene node. Can be NULL if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: Position of the space relative to its parent where the
		scene node will be placed.
		\param rotation: Initial rotation of the scene node.
		\param scale: Initial scale of the scene node.
		\return Pointer to the created scene node.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addSkyDomeSceneNode(irr.video.ITexture*,System.UInt32,System.UInt32,System.Single,System.Single,System.Single,irr.scene.ISceneNode*,System.Int32)">
A skydome is a large (half-) sphere with a panoramic texture
		on the inside and is drawn around the camera position.
		\param texture: Texture for the dome.
		\param horiRes: Number of vertices of a horizontal layer of the sphere.
		\param vertRes: Number of vertices of a vertical layer of the sphere.
		\param texturePercentage: How much of the height of the
		texture is used. Should be between 0 and 1.
		\param spherePercentage: How much of the sphere is drawn.
		Value should be between 0 and 2, where 1 is an exact
		half-sphere and 2 is a full sphere.
		\param radius The Radius of the sphere
		\param parent: Parent scene node of the dome. A dome usually has no parent,
		so this should be null. Note: If a parent is set, the dome will not
		change how it is drawn.
		\param id: An id of the node. This id can be used to identify the node.
		\return Pointer to the sky dome if successful, otherwise NULL.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addSkyBoxSceneNode(irr.video.ITexture*,irr.video.ITexture*,irr.video.ITexture*,irr.video.ITexture*,irr.video.ITexture*,irr.video.ITexture*,irr.scene.ISceneNode*,System.Int32)">
A skybox is a big cube with 6 textures on it and
		is drawn around the camera position.
		\param top: Texture for the top plane of the box.
		\param bottom: Texture for the bottom plane of the box.
		\param left: Texture for the left plane of the box.
		\param right: Texture for the right plane of the box.
		\param front: Texture for the front plane of the box.
		\param back: Texture for the back plane of the box.
		\param parent: Parent scene node of the skybox. A skybox usually has no parent,
		so this should be null. Note: If a parent is set to the skybox, the box will not
		change how it is drawn.
		\param id: An id of the node. This id can be used to identify the node.
		\return Pointer to the sky box if successful, otherwise NULL.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addBillboardSceneNode(irr.scene.ISceneNode*,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,irr.video.SColor,irr.video.SColor)">
A billboard is like a 3d sprite: A 2d element,
		which always looks to the camera. It is usually used for things
		like explosions, fire, lensflares and things like that.
		\param parent Parent scene node of the billboard. Can be null.
		If the parent moves, the billboard will move too.
		\param size Size of the billboard. This size is 2 dimensional
		because a billboard only has width and height.
		\param position Position of the space relative to its parent
		where the billboard will be placed.
		\param id An id of the node. This id can be used to identify
		the node.
		\param colorTop The color of the vertices at the top of the
		billboard (default: white).
		\param colorBottom The color of the vertices at the bottom of
		the billboard (default: white).
		\return Pointer to the billboard if successful, otherwise NULL.
		This pointer should not be dropped. See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addLightSceneNode(irr.scene.ISceneNode*,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColorf,System.Single,System.Int32)">
The light will cast dynamic light on all
		other scene nodes in the scene, which have the material flag video::MTF_LIGHTING
		turned on. (This is the default setting in most scene nodes).
		\param parent: Parent scene node of the light. Can be null. If the parent moves,
		the light will move too.
		\param position: Position of the space relative to its parent where the light will be placed.
		\param color: Diffuse color of the light. Ambient or Specular colors can be set manually with
		the ILightSceneNode::getLightData() method.
		\param radius: Radius of the light.
		\param id: id of the node. This id can be used to identify the node.
		\return Pointer to the interface of the light if successful, otherwise NULL.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addCameraSceneNodeFPS(irr.scene.ISceneNode*,System.Single,System.Single,System.Int32,irr.SKeyMap*,System.Int32,System.Boolean,System.Single,System.Boolean,System.Boolean)">
This FPS camera is intended to provide a demonstration of a
		camera that behaves like a typical First Person Shooter. It is
		useful for simple demos and prototyping but is not intended to
		provide a full solution for a production quality game. It binds
		the camera scene node rotation to the look-at target; @see
		ICameraSceneNode::bindTargetAndRotation(). With this camera,
		you look with the mouse, and move with cursor keys. If you want
		to change the key layout, you can specify your own keymap. For
		example to make the camera be controlled by the cursor keys AND
		the keys W,A,S, and D, do something like this:
		\code
		 SKeyMap keyMap[8];
		 keyMap[0].Action = EKA_MOVE_FORWARD;
		 keyMap[0].KeyCode = KEY_UP;
		 keyMap[1].Action = EKA_MOVE_FORWARD;
		 keyMap[1].KeyCode = KEY_KEY_W;

		 keyMap[2].Action = EKA_MOVE_BACKWARD;
		 keyMap[2].KeyCode = KEY_DOWN;
		 keyMap[3].Action = EKA_MOVE_BACKWARD;
		 keyMap[3].KeyCode = KEY_KEY_S;

		 keyMap[4].Action = EKA_STRAFE_LEFT;
		 keyMap[4].KeyCode = KEY_LEFT;
		 keyMap[5].Action = EKA_STRAFE_LEFT;
		 keyMap[5].KeyCode = KEY_KEY_A;

		 keyMap[6].Action = EKA_STRAFE_RIGHT;
		 keyMap[6].KeyCode = KEY_RIGHT;
		 keyMap[7].Action = EKA_STRAFE_RIGHT;
		 keyMap[7].KeyCode = KEY_KEY_D;

		camera = sceneManager-&gt;addCameraSceneNodeFPS(0, 100, 500, -1, keyMap, 8);
		\endcode
		\param parent: Parent scene node of the camera. Can be null.
		\param rotateSpeed: Speed in degrees with which the camera is
		rotated. This can be done only with the mouse.
		\param moveSpeed: Speed in units per millisecond with which
		the camera is moved. Movement is done with the cursor keys.
		\param id: id of the camera. This id can be used to identify
		the camera.
		\param keyMapArray: Optional pointer to an array of a keymap,
		specifying what keys should be used to move the camera. If this
		is null, the default keymap is used. You can define actions
		more then one time in the array, to bind multiple keys to the
		same action.
		\param keyMapSize: Amount of items in the keymap array.
		\param noVerticalMovement: Setting this to true makes the
		camera only move within a horizontal plane, and disables
		vertical movement as known from most ego shooters. Default is
		'false', with which it is possible to fly around in space, if
		no gravity is there.
		\param jumpSpeed: Speed with which the camera is moved when
		jumping.
		\param invertMouse: Setting this to true makes the camera look
		up when the mouse is moved down and down when the mouse is
		moved up, the default is 'false' which means it will follow the
		movement of the mouse cursor.
		\param makeActive Flag whether this camera should become the active one.
		Make sure you always have one active camera.
		\return Pointer to the interface of the camera if successful,
		otherwise 0. This pointer should not be dropped. See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addCameraSceneNodeMaya(irr.scene.ISceneNode*,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Boolean)">
This is a standard camera with an animator that provides mouse control similar
		to camera in the 3D Software Maya by Alias Wavefront.
		The camera does not react on setPosition anymore after applying this animator. Instead
		use setTarget, to fix the target the camera the camera hovers around. And setDistance
		to set the current distance from that target, i.e. the radius of the orbit the camera
		hovers on.
		\param parent: Parent scene node of the camera. Can be null.
		\param rotateSpeed: Rotation speed of the camera.
		\param zoomSpeed: Zoom speed of the camera.
		\param translationSpeed: TranslationSpeed of the camera.
		\param id: id of the camera. This id can be used to identify the camera.
		\param distance Initial distance of the camera from the object
		\param makeActive Flag whether this camera should become the active one.
		Make sure you always have one active camera.
		\return Returns a pointer to the interface of the camera if successful, otherwise 0.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addCameraSceneNode(irr.scene.ISceneNode*,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
This camera does not react on user input like for example the one created with
		addCameraSceneNodeFPS(). If you want to move or animate it, use animators or the
		ISceneNode::setPosition(), ICameraSceneNode::setTarget() etc methods.
		By default, a camera's look at position (set with setTarget()) and its scene node
		rotation (set with setRotation()) are independent. If you want to be able to
		control the direction that the camera looks by using setRotation() then call
		ICameraSceneNode::bindTargetAndRotation(true) on it.
		\param position: Position of the space relative to its parent where the camera will be placed.
		\param lookat: Position where the camera will look at. Also known as target.
		\param parent: Parent scene node of the camera. Can be null. If the parent moves,
		the camera will move too.
		\param id: id of the camera. This id can be used to identify the camera.
		\param makeActive Flag whether this camera should become the active one.
		Make sure you always have one active camera.
		\return Pointer to interface to camera if successful, otherwise 0.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addOctreeSceneNode(irr.scene.IMesh*,irr.scene.ISceneNode*,System.Int32,System.Int32,System.Boolean)">
This a good method for rendering scenes with lots of
		geometry. The octree is built on the fly from the mesh, much
		faster then a bsp tree.
		\param mesh: The mesh containing all geometry from which the octree will be build.
		\param parent: Parent node of the octree node.
		\param id: id of the node. This id can be used to identify the node.
		\param minimalPolysPerNode: Specifies the minimal polygons contained a octree node.
		If a node gets less polys than this value it will not be split into
		smaller nodes.
		\param alsoAddIfMeshPointerZero: Add the scene node even if a 0 pointer is passed.
		\return Pointer to the octree if successful, otherwise 0.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addOctreeSceneNode(irr.scene.IAnimatedMesh*,irr.scene.ISceneNode*,System.Int32,System.Int32,System.Boolean)">
This a good method for rendering
		scenes with lots of geometry. The octree is built on the fly from the mesh.
		\param mesh: The mesh containing all geometry from which the octree will be build.
		If this animated mesh has more than one frames in it, the first frame is taken.
		\param parent: Parent node of the octree node.
		\param id: id of the node. This id can be used to identify the node.
		\param minimalPolysPerNode: Specifies the minimal polygons contained a octree node.
		If a node gets less polys than this value it will not be split into
		smaller nodes.
		\param alsoAddIfMeshPointerZero: Add the scene node even if a 0 pointer is passed.
		\return Pointer to the octree if successful, otherwise 0.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addWaterSurfaceSceneNode(irr.scene.IMesh*,System.Single,System.Single,System.Single,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Looks really good when the Material type EMT_TRANSPARENT_REFLECTION
		is used.
		\param waveHeight: Height of the water waves.
		\param waveSpeed: Speed of the water waves.
		\param waveLength: Length of a water wave.
		\param mesh: Pointer to the loaded static mesh to be displayed with water waves on it.
		\param parent: Parent of the scene node. Can be NULL if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: Position of the space relative to its parent where the
		scene node will be placed.
		\param rotation: Initial rotation of the scene node.
		\param scale: Initial scale of the scene node.
		\return Pointer to the created scene node.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addMeshSceneNode(irr.scene.IMesh*,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
\param mesh: Pointer to the loaded static mesh to be displayed.
		\param parent: Parent of the scene node. Can be NULL if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: Position of the space relative to its parent where the
		scene node will be placed.
		\param rotation: Initial rotation of the scene node.
		\param scale: Initial scale of the scene node.
		\param alsoAddIfMeshPointerZero: Add the scene node even if a 0 pointer is passed.
		\return Pointer to the created scene node.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addAnimatedMeshSceneNode(irr.scene.IAnimatedMesh*,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
\param mesh: Pointer to the loaded animated mesh to be displayed.
		\param parent: Parent of the scene node. Can be NULL if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: Position of the space relative to its parent where the
		scene node will be placed.
		\param rotation: Initial rotation of the scene node.
		\param scale: Initial scale of the scene node.
		\param alsoAddIfMeshPointerZero: Add the scene node even if a 0 pointer is passed.
		\return Pointer to the created scene node.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addSphereSceneNode(System.Single,System.Int32,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param radius: Radius of the sphere.
		\param polyCount: The number of vertices in horizontal and
		vertical direction. The total polyCount of the sphere is
		polyCount*polyCount. This parameter must be less than 256 to
		stay within the 16-bit limit of the indices of a meshbuffer.
		\param parent: Parent of the scene node. Can be 0 if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: Position of the space relative to its parent
		where the scene node will be placed.
		\param rotation: Initial rotation of the scene node.
		\param scale: Initial scale of the scene node.
		\return Pointer to the created test scene node. This
		pointer should not be dropped. See IReferenceCounted::drop()
		for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addCubeSceneNode(System.Single,irr.scene.ISceneNode*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param size: Size of the cube, uniformly in each dimension.
		\param parent: Parent of the scene node. Can be 0 if no parent.
		\param id: Id of the node. This id can be used to identify the scene node.
		\param position: Position of the space relative to its parent
		where the scene node will be placed.
		\param rotation: Initial rotation of the scene node.
		\param scale: Initial scale of the scene node.
		\return Pointer to the created test scene node. This
		pointer should not be dropped. See IReferenceCounted::drop()
		for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.addVolumeLightSceneNode(irr.scene.ISceneNode*,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Example Usage:
			scene::IVolumeLightSceneNode * n = smgr-&gt;addVolumeLightSceneNode(0, -1,
						32, 32, //Subdivide U/V
						video::SColor(0, 180, 180, 180), //foot color
						video::SColor(0, 0, 0, 0) //tail color
						);
			if (n)
			{
				n-&gt;setScale(core::vector3df(46.0f, 45.0f, 46.0f));
				n-&gt;getMaterial(0).setTexture(0, smgr-&gt;getVideoDriver()-&gt;getTexture("lightFalloff.png"));
			}
		\return Pointer to the volumeLight if successful, otherwise NULL.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getFileSystem">
\return Pointer to the FileSystem
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getGUIEnvironment">
\return Pointer to the GUIEnvironment
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getVideoDriver">
\return Pointer to the video Driver.
		This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.ISceneManager.getMeshCache">
With this interface, it is possible to manually add new loaded
		meshes (if ISceneManager::getMesh() is not sufficient), to remove them and to iterate
		through already loaded meshes. 
</member>
        <member name="M:irr.scene.ISceneManager.getMesh(irr.io.IReadFile*)">
Works just as getMesh(const char* filename). If you want to
		remove a loaded mesh from the cache again, use removeMesh().
		\param file File handle of the mesh to load.
		\return NULL if failed and pointer to the mesh if successful.
		This pointer should not be dropped. See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="T:irr.scene.ISceneManager">
All Scene nodes can be created only here. There is a always growing
	list of scene nodes for lots of purposes: Indoor rendering scene nodes
	like the Octree (addOctreeSceneNode()) or the terrain renderer
	(addTerrainSceneNode()), different Camera scene nodes
	(addCameraSceneNode(), addCameraSceneNodeMaya()), scene nodes for Light
	(addLightSceneNode()), Billboards (addBillboardSceneNode()) and so on.
	A scene node is a node in the hierarchical scene graph. Every scene node
	may have children, which are other scene nodes. Children move relative
	the their parents position. If the parent of a node is not visible, its
	children won't be visible, too. In this way, it is for example easily
	possible to attach a light to a moving car or to place a walking
	character on a moving platform on a moving ship.
	The SceneManager is also able to load 3d mesh files of different
	formats. Take a look at getMesh() to find out what formats are
	supported. If these formats are not enough, use
	addExternalMeshLoader() to add new formats to the engine.

</member>
        <member name="T:irr.scene.E_SCENE_NODE_RENDER_PASS">
A parameter passed to the registerNodeForRendering() method of the ISceneManager,
	specifying when the node wants to be drawn in relation to the other nodes. 
</member>
        <member name="F:ESNRP_AUTOMATIC">
This value will never be returned by
		ISceneManager::getSceneNodeRenderPass(). The scene manager
		will determine by itself if an object is transparent or solid
		and register the object as ESNRT_TRANSPARENT or ESNRP_SOLID
		automatically if you call registerNodeForRendering with this
		value (which is default). Note that it will register the node
		only as ONE type. If your scene node has both solid and
		transparent material types register it twice (one time as
		ESNRP_SOLID, the other time as ESNRT_TRANSPARENT) and in the
		render() method call getSceneNodeRenderPass() to find out the
		current render pass and render only the corresponding parts of
		the node. 
</member>
        <member name="M:irr.scene.ISkinnedMesh.convertMeshToTangents">
E.g. used for bump mapping. 
</member>
        <member name="M:irr.scene.ISkinnedMesh.updateNormalsWhenAnimating(System.Boolean)">
\param on If false don't animate, which is faster.
		Else update normals, which allows for proper lighting of
		animated meshes. 
</member>
        <member name="M:irr.scene.ISkinnedMesh.useAnimationFrom(irr.scene.ISkinnedMesh!System.Runtime.CompilerServices.IsConst*)">
The animation is linked (not copied) based on joint names
		so make sure they are unique.
		\return True if all joints in this mesh were
		matched up (empty names will not be matched, and it's case
		sensitive). Unmatched joints will not be animated. 
</member>
        <member name="M:irr.scene.ISkinnedMesh.getJointNumber(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
\param name: Name of the joint.
		\return Number of the joint or -1 if not found. 
</member>
        <member name="M:irr.scene.ISkinnedMesh.getJointName(System.UInt32)">
\param number: Zero based index of joint. The last joint
		has the number getJointCount()-1;
		\return Name of joint and null if an error happened. 
</member>
        <member name="M:irr.scene.ISkinnedMesh.getJointCount">
\return Amount of joints in the skeletal animated mesh. 
</member>
        <member name="M:irr.scene.SSkinMeshBuffer.getIndexType">
\return Index type of this buffer. 
</member>
        <member name="M:irr.scene.ISceneLoader.loadScene(irr.io.IReadFile*,irr.scene.ISceneUserDataSerializer*,irr.scene.ISceneNode*)">
\param file File which contains the scene.
	\param userDataSerializer: If you want to load user data which may be attached
	to some some scene nodes in the file, implement the ISceneUserDataSerializer
	interface and provide it as parameter here. Otherwise, simply specify 0 as this
	parameter.
	\param rootNode The node to load the scene into, if none is provided then the
	scene will be loaded into the root node.
	\return Returns true on success, false on failure. Returns 0 if loading failed. 
</member>
        <member name="M:irr.scene.ISceneLoader.isALoadableFileFormat(irr.io.IReadFile*)">
This decision will be based on a quick look at the contents of the file.
	\param file The file to test.
	\return True if the extension is a recognised type. 
</member>
        <member name="M:irr.scene.ISceneLoader.isALoadableFileExtension(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This decision should be based on the file extension (e.g. ".vrml")
	only.
	\param filename Name of the file to test.
	\return True if the extension is a recognised type. 
</member>
        <member name="T:irr.scene.ISceneLoader">
If you want Irrlicht to be able to load currently unsupported
scene file formats (e.g. .vrml), then implement this and add your
new Sceneloader to the engine with ISceneManager::addExternalSceneLoader(). 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getSceneNodeAndCollisionPointFromRay(irr.core.line3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.triangle3d&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,irr.scene.ISceneNode*,System.Boolean)">
Works same as other getSceneNodeAndCollisionPointFromRay but returns less information.
		(was written before the other getSceneNodeAndCollisionPointFromRay implementation).
		\param ray: Line with which collisions are tested.
		\param outCollisionPoint: If a collision is detected, this will contain the
		position of the nearest collision.
		\param outTriangle: If a collision is detected, this will contain the triangle
		with which the ray collided.
		\param idBitMask: Only scene nodes with an id which matches at least one of the
		bits contained in this mask will be tested. However, if this parameter is 0, then
		all nodes are checked.
		\param collisionRootNode: the scene node at which to begin checking. Only this
		node and its children will be checked. If you want to check the entire scene,
		pass 0, and the root scene node will be used (this is the default).
		\param noDebugObjects: when true, debug objects are not considered viable targets.
		Debug objects are scene nodes with IsDebugObject() = true.
		\return Returns the scene node containing the hit triangle nearest to ray.start.
		If no collision is detected, then 0 is returned. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getSceneNodeAndCollisionPointFromRay(irr.scene.SCollisionHit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.line3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,irr.scene.ISceneNode*,System.Boolean)">
This checks all scene nodes under the specified one, first by ray/bounding
		box, and then by accurate ray/triangle collision, finding the nearest collision,
		and the scene node containing it.  It returns the node hit, and (via output
		parameters) the position of the collision, and the triangle that was hit.

		All scene nodes in the hierarchy tree under the specified node are checked. Only
		nodes that are visible, with an ID that matches at least one bit in the supplied
		bitmask, and which have a triangle selector are considered as candidates for being hit.
		You do not have to build a meta triangle selector; the individual triangle selectors
		of each candidate scene node are used automatically.

		\param ray: Line with which collisions are tested.
		\param outCollisionPoint: If a collision is detected, this will contain the
		position of the nearest collision.
		\param outTriangle: If a collision is detected, this will contain the triangle
		with which the ray collided.
		\param idBitMask: Only scene nodes with an id which matches at least one of the
		bits contained in this mask will be tested. However, if this parameter is 0, then
		all nodes are checked.
		\param collisionRootNode: the scene node at which to begin checking. Only this
		node and its children will be checked. If you want to check the entire scene,
		pass 0, and the root scene node will be used (this is the default).
		\param noDebugObjects: when true, debug objects are not considered viable targets.
		Debug objects are scene nodes with IsDebugObject() = true.
		\return Returns the scene node containing the hit triangle nearest to ray.start.
		If no collision is detected, then 0 is returned. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getSceneNodeFromCameraBB(irr.scene.ICameraSceneNode!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Boolean)">
A ray is simply cast from the position of the camera to
		the view target position, and all scene nodes are tested
		against this ray. The collision tests are done using a bounding
		box for each scene node.
		\param camera: Camera from which the ray is cast.
		\param idBitMask: Only scene nodes with an id which matches at least one of the
		bits contained in this mask will be tested. However, if this parameter is 0, then
		all nodes are checked.
		feature is disabled.
		Please note that the default node id of -1 will match with
		every bitmask != 0
		\param bNoDebugObjects: Doesn't take debug objects into account
		when true. These are scene nodes with IsDebugObject() = true.
		\return Scene node nearest to the camera, which collides with
		the ray and matches the idBitMask, if the mask is not null. If
		no scene node is found, 0 is returned. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getSceneNodeFromRayBB(irr.core.line3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,irr.scene.ISceneNode*)">
The collision tests are done using a bounding box for each
		scene node. The recursive search can be limited be specifying a scene node.
		\param ray Line with which collisions are tested.
		\param idBitMask Only scene nodes with an id which matches at
		least one of the bits contained in this mask will be tested.
		However, if this parameter is 0, then all nodes are checked.
		\param bNoDebugObjects: Doesn't take debug objects into account when true. These
		are scene nodes with IsDebugObject() = true.
		\param root If different from 0, the search is limited to the children of this node.
		\return Scene node nearest to ray.start, which collides with
		the ray and matches the idBitMask, if the mask is not null. If
		no scene node is found, 0 is returned. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getSceneNodeFromScreenCoordinatesBB(irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,irr.scene.ISceneNode*)">
The collision tests are done using a bounding box for each
		scene node. You can limit the recursive search so just all children of the specified root are tested.
		\param pos: Position in pixel screen coordinates, under which
		the returned scene node will be.
		\param idBitMask: Only scene nodes with an id with bits set
		like in this mask will be tested. If the BitMask is 0, this
		feature is disabled.
		Please note that the default node id of -1 will match with
		every bitmask != 0
		\param bNoDebugObjects: Doesn't take debug objects into account
		when true. These are scene nodes with IsDebugObject() = true.
		\param root If different from 0, the search is limited to the children of this node.
		\return Visible scene node under screen coordinates with
		matching bits in its id. If there is no scene node under this
		position, 0 is returned. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getScreenCoordinatesFrom3DPosition(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ICameraSceneNode!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
\param pos: 3D position in world space to be transformed
		into 2d.
		\param camera: Camera to be used. If null, the currently active
		camera is used.
		\param useViewPort: Calculate screen coordinates relative to
		the current view port. Please note that unless the driver does
		not take care of the view port, it is usually best to get the
		result in absolute screen coordinates (flag=false).
		\return 2d screen coordinates which a object in the 3d world
		would have if it would be rendered to the screen. If the 3d
		position is behind the camera, it is set to (-1000,-1000). In
		most cases you can ignore this fact, because if you use this
		method for drawing a decorator over a 3d object, it will be
		clipped by the screen borders. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getRayFromScreenCoordinates(irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ICameraSceneNode!System.Runtime.CompilerServices.IsConst*)">
\param pos: Screen coordinates in pixels.
		\param camera: Camera from which the ray starts. If null, the
		active camera is used.
		\return Ray starting from the position of the camera and ending
		at a length of the far value of the camera at a position which
		would be behind the 2d screen coordinates. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getCollisionResultPosition(irr.scene.ITriangleSelector*,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.triangle3d&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ISceneNode**!System.Runtim">
This can be used for moving a character in a 3d world: The
		character will slide at walls and is able to walk up stairs.
		The method used how to calculate the collision result position
		is based on the paper "Improved Collision detection and
		Response" by Kasper Fauerby.
		\param selector: TriangleSelector containing the triangles of
		the world. It can be created for example using
		ISceneManager::createTriangleSelector() or
		ISceneManager::createTriangleOctreeSelector().
		\param ellipsoidPosition: Position of the ellipsoid.
		\param ellipsoidRadius: Radius of the ellipsoid.
		\param ellipsoidDirectionAndSpeed: Direction and speed of the
		movement of the ellipsoid.
		\param triout: Optional parameter where the last triangle
		causing a collision is stored, if there is a collision.
		\param hitPosition: Return value for the position of the collision
		\param outFalling: Is set to true if the ellipsoid is falling
		down, caused by gravity.
		\param outNode: the node with which the ellipsoid collided (if any)
		\param slidingSpeed: DOCUMENTATION NEEDED.
		\param gravityDirectionAndSpeed: Direction and force of gravity.
		\return New position of the ellipsoid. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getCollisionPoint(irr.core.line3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ITriangleSelector*,irr.core.vector3d&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.triangle3d&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ISceneNode**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param ray: Line with which collisions are tested.
		\param selector: TriangleSelector containing the triangles. It
		can be created for example using
		ISceneManager::createTriangleSelector() or
		ISceneManager::createTriangleOctreeSelector().
		\param outCollisionPoint: If a collision is detected, this will
		contain the position of the nearest collision to the line-start.
		\param outTriangle: If a collision is detected, this will
		contain the triangle with which the ray collided.
		\param outNode: If a collision is detected, this will contain
		the scene node associated with the triangle that was hit.
		\return True if a collision was detected and false if not. 
</member>
        <member name="M:irr.scene.ISceneCollisionManager.getCollisionPoint(irr.scene.SCollisionHit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.line3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.ITriangleSelector*)">
\param hitResult: Contains collision result when there was a collision detected.
		\param ray: Line with which collisions are tested.
		\param selector: TriangleSelector to be used for the collision check.
		\return true if a collision was detected and false if not.	
</member>
        <member name="M:irr.IrrlichtDevice.isDriverSupported(irr.video.E_DRIVER_TYPE)">
Even if true is returned the driver may not be available
		for a configuration requested when creating the device. 
</member>
        <member name="M:irr.IrrlichtDevice.getType">
This allows the user to check which windowing system is currently being
		used. 
</member>
        <member name="M:irr.IrrlichtDevice.getDoubleClickTime">
When return value is 0 no double- and tripleclicks will be generated.
		\return maximal time in milliseconds for two consecutive clicks to be recognized as double click

</member>
        <member name="M:irr.IrrlichtDevice.setDoubleClickTime(System.UInt32)">
When set to 0 no double- and tripleclicks will be generated.
		\param timeMs maximal time in milliseconds for two consecutive clicks to be recognized as double click

</member>
        <member name="M:irr.IrrlichtDevice.activateJoysticks(irr.core.array&lt;irr.SJoystickInfo,irr.core.irrAllocator&lt;irr.SJoystickInfo&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Irrlicht contains support for joysticks, but does not generate joystick events by default,
		as this would consume joystick info that 3rd party libraries might rely on. Call this method to
		activate joystick support in Irrlicht and to receive irr::SJoystickEvent events.
		\param joystickInfo On return, this will contain an array of each joystick that was found and activated.
		\return true if joysticks are supported on this device and _IRR_COMPILE_WITH_JOYSTICK_EVENTS_
				is defined, false if joysticks are not supported or support is compiled out.

</member>
        <member name="M:irr.IrrlichtDevice.setWindowSize(irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This will only work in windowed mode and is not yet supported on all systems.
		It does set the drawing/clientDC size of the window, the window decorations are added to that.
		You get the current window size with IVideoDriver::getScreenSize() (might be unified in future)

</member>
        <member name="M:irr.IrrlichtDevice.setResizable(System.Boolean)">
The default is false. This method only works in windowed
		mode.
		\param resize Flag whether the window should be resizable. 
</member>
        <member name="M:irr.IrrlichtDevice.setInputReceivingSceneManager(irr.scene.ISceneManager*)">
If set to null, the main scene manager (returned by
		GetSceneManager()) will receive the input
		\param sceneManager New scene manager to be used. 
</member>
        <member name="M:irr.IrrlichtDevice.postEventFromUser(irr.SEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Is is usually not necessary to use this. However, if you
		are using an own input library for example for doing joystick
		input, you can use this to post key or mouse input events to
		the engine. Internally, this method only delegates the events
		further to the scene manager and the GUI environment. 
</member>
        <member name="M:irr.IrrlichtDevice.getEventReceiver">
\return Pointer to the current event receiver. Returns 0 if there is none. 
</member>
        <member name="M:irr.IrrlichtDevice.setEventReceiver(irr.IEventReceiver*)">
Return true in IEventReceiver::OnEvent to prevent the event from continuing along
		the chain of event receivers. The path that an event takes through the system depends
		on its type. See irr::EEVENT_TYPE for details.
		\param receiver New receiver to be used. 
</member>
        <member name="M:irr.IrrlichtDevice.getVersion">
The returned string
		will look like this: "1.2.3" or this: "1.2".
		\return String which contains the version. 
</member>
        <member name="M:irr.IrrlichtDevice.closeDevice">
IrrlichtDevice::run() will always return false after closeDevice() was called. 
</member>
        <member name="M:irr.IrrlichtDevice.getColorFormat">
\return Color format of the window. 
</member>
        <member name="M:irr.IrrlichtDevice.isFullscreen">
\return True if window is fullscreen. 
</member>
        <member name="M:irr.IrrlichtDevice.isWindowMinimized">
\return True if window is minimized. 
</member>
        <member name="M:irr.IrrlichtDevice.isWindowFocused">
\return True if window has focus. 
</member>
        <member name="M:irr.IrrlichtDevice.isWindowActive">
If the window is inactive,
		nothing needs to be drawn. So if you don't want to draw anything
		when the window is inactive, create your drawing loop this way:
		\code
		while(device-&gt;run())
		{
			if (device-&gt;isWindowActive())
			{
				// draw everything here
			}
			else
				device-&gt;yield();
		}
		\endcode
		\return True if window is active. 
</member>
        <member name="M:irr.IrrlichtDevice.setWindowCaption(System.Char!System.Runtime.CompilerServices.IsConst*)">
\param text: New text of the window caption. 
</member>
        <member name="M:irr.IrrlichtDevice.createDefaultRandomizer">
The default randomizer provides the random sequence known from previous
		Irrlicht versions and is the initial randomizer set on device creation.
		\return Pointer to the default IRandomizer object. 
</member>
        <member name="M:irr.IrrlichtDevice.setRandomizer(irr.IRandomizer*)">
\param r Pointer to the new IRandomizer object. This object is
		grab()'ed by the engine and will be released upon the next setRandomizer
		call or upon device destruction. 
</member>
        <member name="M:irr.IrrlichtDevice.getRandomizer">
\return Pointer to the IRandomizer object. 
</member>
        <member name="M:irr.IrrlichtDevice.getTimer">
The system time can be retrieved by it as
		well as the virtual time, which also can be manipulated.
		\return Pointer to the ITimer object. 
</member>
        <member name="M:irr.IrrlichtDevice.getOSOperator">
The OS operator provides methods for
		getting system specific information and doing system
		specific operations, such as exchanging data with the clipboard
		or reading the operation system version.
		\return Pointer to the OS operator. 
</member>
        <member name="M:irr.IrrlichtDevice.getVideoModeList">
You only need a null driver (ED_NULL) to access
		those video modes. So you can get the available modes
		before starting any other video driver.
		\return Pointer to a list with all video modes supported
		by the gfx adapter. 
</member>
        <member name="M:irr.IrrlichtDevice.getLogger">
\return Pointer to the logger. 
</member>
        <member name="M:irr.IrrlichtDevice.getCursorControl">
\return Pointer to the mouse cursor control interface. 
</member>
        <member name="M:irr.IrrlichtDevice.getSceneManager">
\return Pointer to the scene manager. 
</member>
        <member name="M:irr.IrrlichtDevice.getGUIEnvironment">
\return Pointer to the gui environment. 
</member>
        <member name="M:irr.IrrlichtDevice.getFileSystem">
\return Pointer to the file system. 
</member>
        <member name="M:irr.IrrlichtDevice.getVideoDriver">
\return Pointer the video driver. 
</member>
        <member name="M:irr.IrrlichtDevice.sleep(System.UInt32,System.Boolean)">
It may not wait the full given time, as sleep may be interrupted
		\param timeMs: Time to sleep for in milliseconds.
		\param pauseTimer: If true, pauses the device timer while sleeping

</member>
        <member name="M:irr.IrrlichtDevice.yield">
This should bring down processor usage without major
		performance loss for Irrlicht 
</member>
        <member name="M:irr.IrrlichtDevice.run">
Also increments the virtual timer by calling
		ITimer::tick();. You can prevent this
		by calling ITimer::stop(); before and ITimer::start() after
		calling IrrlichtDevice::run(). Returns false if device wants
		to be deleted. Use it in this way:
		\code
		while(device-&gt;run())
		{
			// draw everything here
		}
		\endcode
		If you want the device to do nothing if the window is inactive
		(recommended), use the slightly enhanced code shown at isWindowActive().

		Note if you are running Irrlicht inside an external, custom
		created window: Calling Device-&gt;run() will cause Irrlicht to
		dispatch windows messages internally.
		If you are running Irrlicht in your own custom window, you can
		also simply use your own message loop using GetMessage,
		DispatchMessage and whatever and simply don't use this method.
		But note that Irrlicht will not be able to fetch user input
		then. See irr::SIrrlichtCreationParameters::WindowId for more
		information and example code.

</member>
        <member name="T:irr.IrrlichtDevice">
This is the most important class of the Irrlicht Engine. You can
	access everything in the engine if you have a pointer to an instance of
	this class.  There should be only one instance of this class at any
	time.

</member>
        <member name="M:irr.video.IVideoModeList.getDesktopDepth">
\return Size of each pixel of the current desktop video mode in bits. 
</member>
        <member name="M:irr.video.IVideoModeList.getDesktopResolution">
\return Size of screen in pixels of the current desktop video mode. 
</member>
        <member name="M:irr.video.IVideoModeList.getVideoModeDepth(System.Int32)">
\param modeNumber: zero based index of the video mode.
		\return Size of each pixel of the specified video mode in bits. 
</member>
        <member name="M:irr.video.IVideoModeList.getVideoModeResolution(irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param minSize: Minimum dimensions required.
		\param maxSize: Maximum dimensions allowed.
		\return Size of screen in pixels which matches the requirements.
		as good as possible. 
</member>
        <member name="M:irr.video.IVideoModeList.getVideoModeResolution(System.Int32)">
\param modeNumber: zero based index of the video mode.
		\return Size of screen in pixels of the specified video mode. 
</member>
        <member name="M:irr.video.IVideoModeList.getVideoModeCount">
\return Returns amount of video modes. 
</member>
        <member name="T:irr.video.IVideoModeList">
You can get a list via IrrlichtDevice::getVideoModeList(). 
	You only need the null device (EDT_NULL) to get the video-modes. 
</member>
        <member name="M:irr.video.IRenderTarget.setTexture(irr.core.array&lt;irr.video.ITexture**,irr.core.irrAllocator&lt;irr.video.ITexture**&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.ITexture*,irr.core.array&lt;irr.video.E_CUBE_SURFACE,irr.core.irrAllocator&lt;irr.video.E_CUBE_SURFACE&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set multiple textures for the render target.
		\param texture Array of texture objects. These textures are used for a color outputs.
		\param depthStencil Depth or packed depth-stencil texture. This texture is used as depth
		or depth-stencil buffer. 
		\param cubeSurfaces When rendering to cube textures, set the surface to be used for each texture. Can be empty otherwise.

</member>
        <member name="M:irr.IRandomizer.reset(System.Int32)">
\param value Initialization value (seed) 
</member>
        <member name="M:irr.scene.IQ3LevelMesh.getBrushEntityMesh(System.Int32)">
\param num The number from the model key of the entity.

		Use this interface if you parse the entities yourself.
</member>
        <member name="M:irr.scene.IQ3LevelMesh.getShader(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
\param filename Name of the shaderfile, defaults to /scripts if fileNameIsValid is false.
		\param fileNameIsValid Specifies whether the filename is valid in the current situation. 
</member>
        <member name="T:irr.scene.IQ3LevelMesh">
The Mesh tries to load all textures of the map.
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createRotationAffector(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This affector modifies the positions of the particles and attracts
	them to a specified point at a specified speed per second.
	\param speed: Rotation in degrees per second
	\param pivotPoint: Point to rotate the particles around
	\return Pointer to the created particle affector. To add this affector
	as new affector of this particle system, just call addAffector(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createGravityAffector(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
This affector modifies the direction of the particle. It assumes
	that the particle is fired out of the emitter with huge force, but is
	loosing this after some time and is caught by the gravity then. This
	affector is ideal for creating things like fountains.
	\param gravity: Direction and force of gravity.
	\param timeForceLost: Time in milliseconds when the force of the
	emitter is totally lost and the particle does not move any more. This
	is the time where gravity fully affects the particle.
	\return Pointer to the created particle affector. To add this affector
	as new affector of this particle system, just call addAffector(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createFadeOutParticleAffector(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
This affector modifies the color of every particle and and reaches
	the final color when the particle dies. This affector looks really
	good, if the EMT_TRANSPARENT_ADD_COLOR material is used and the
	targetColor is video::SColor(0,0,0,0): Particles are fading out into
	void with this setting.
	\param targetColor: Color whereto the color of the particle is changed.
	\param timeNeededToFadeOut: How much time in milliseconds should the
	affector need to change the color to the targetColor.
	\return Pointer to the created particle affector. To add this affector
	as new affector of this particle system, just call addAffector(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createScaleParticleAffector(irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This affector scales the particle to the a multiple of its size defined
	by the scaleTo variable.
	\param scaleTo: multiple of the size which the particle will be scaled to until deletion
	\return Pointer to the created particle affector.
	To add this affector as new affector of this particle system,
	just call addAffector(). Note that you'll have to drop() the
	returned pointer, after you don't need it any more, see
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createAttractionAffector(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
This affector modifies the positions of the particles and attracts
	them to a specified point at a specified speed per second.
	\param point: Point to attract particles to.
	\param speed: Speed in units per second, to attract to the specified
	point.
	\param attract: Whether the particles attract or detract from this
	point.
	\param affectX: Whether or not this will affect the X position of the
	particle.
	\param affectY: Whether or not this will affect the Y position of the
	particle.
	\param affectZ: Whether or not this will affect the Z position of the
	particle.
	\return Pointer to the created particle affector. To add this affector
	as new affector of this particle system, just call addAffector(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createSphereEmitter(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Int32,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.di">
\param center: Center of sphere
	\param radius: Radius of sphere
	\param direction: Direction and speed of particle emission.
	\param minParticlesPerSecond: Minimal amount of particles emitted per
	second.
	\param maxParticlesPerSecond: Maximal amount of particles emitted per
	second.
	\param minStartColor: Minimal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param maxStartColor: Maximal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param lifeTimeMin: Minimal lifetime of a particle, in milliseconds.
	\param lifeTimeMax: Maximal lifetime of a particle, in milliseconds.
	\param maxAngleDegrees: Maximal angle in degrees, the emitting
	direction of the particle will differ from the original direction.
	\param minStartSize: Minimal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\param maxStartSize: Maximal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\return Pointer to the created particle emitter. To set this emitter
	as new emitter of this particle system, just call setEmitter(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createRingEmitter(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Int32,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced">
\param center: Center of ring
	\param radius: Distance of points from center, points will be rotated
	around the Y axis at a random 360 degrees and will then be shifted by
	the provided ringThickness values in each axis.
	\param ringThickness : thickness of the ring or how wide the ring is
	\param direction: Direction and speed of particle emission.
	\param minParticlesPerSecond: Minimal amount of particles emitted per
	second.
	\param maxParticlesPerSecond: Maximal amount of particles emitted per
	second.
	\param minStartColor: Minimal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param maxStartColor: Maximal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param lifeTimeMin: Minimal lifetime of a particle, in milliseconds.
	\param lifeTimeMax: Maximal lifetime of a particle, in milliseconds.
	\param maxAngleDegrees: Maximal angle in degrees, the emitting
	direction of the particle will differ from the original direction.
	\param minStartSize: Minimal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\param maxStartSize: Maximal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\return Pointer to the created particle emitter. To set this emitter
	as new emitter of this particle system, just call setEmitter(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createPointEmitter(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Int32,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param direction: Direction and speed of particle emission.
	\param minParticlesPerSecond: Minimal amount of particles emitted per
	second.
	\param maxParticlesPerSecond: Maximal amount of particles emitted per
	second.
	\param minStartColor: Minimal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param maxStartColor: Maximal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param lifeTimeMin: Minimal lifetime of a particle, in milliseconds.
	\param lifeTimeMax: Maximal lifetime of a particle, in milliseconds.
	\param maxAngleDegrees: Maximal angle in degrees, the emitting
	direction of the particle will differ from the original direction.
	\param minStartSize: Minimal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\param maxStartSize: Maximal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\return Pointer to the created particle emitter. To set this emitter
	as new emitter of this particle system, just call setEmitter(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createMeshEmitter(irr.scene.IMesh*,System.Boolean,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Int32,System.Boolean,System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Int32,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.">
\param mesh: Pointer to mesh to emit particles from
	\param useNormalDirection: If true, the direction of each particle
	created will be the normal of the vertex that it's emitting from. The
	normal is divided by the normalDirectionModifier parameter, which
	defaults to 100.0f.
	\param direction: Direction and speed of particle emission.
	\param normalDirectionModifier: If the emitter is using the normal
	direction then the normal of the vertex that is being emitted from is
	divided by this number.
	\param mbNumber: This allows you to specify a specific meshBuffer for
	the IMesh* to emit particles from. The default value is -1, which
	means a random meshBuffer picked from all of the meshes meshBuffers
	will be selected to pick a random vertex from. If the value is 0 or
	greater, it will only pick random vertices from the meshBuffer
	specified by this value.
	\param everyMeshVertex: If true, the emitter will emit between min/max
	particles every second, for every vertex in the mesh, if false, it will
	emit between min/max particles from random vertices in the mesh.
	\param minParticlesPerSecond: Minimal amount of particles emitted per
	second.
	\param maxParticlesPerSecond: Maximal amount of particles emitted per
	second.
	\param minStartColor: Minimal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param maxStartColor: Maximal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param lifeTimeMin: Minimal lifetime of a particle, in milliseconds.
	\param lifeTimeMax: Maximal lifetime of a particle, in milliseconds.
	\param maxAngleDegrees: Maximal angle in degrees, the emitting
	direction of the particle will differ from the original direction.
	\param minStartSize: Minimal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\param maxStartSize: Maximal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\return Pointer to the created particle emitter. To set this emitter
	as new emitter of this particle system, just call setEmitter(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createCylinderEmitter(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Boolean,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UIn">
\param center: The center of the circle at the base of the cylinder
	\param radius: The thickness of the cylinder
	\param normal: Direction of the length of the cylinder
	\param length: The length of the the cylinder
	\param outlineOnly: Whether or not to put points inside the cylinder or
	on the outline only
	\param direction: Direction and speed of particle emission.
	\param minParticlesPerSecond: Minimal amount of particles emitted per
	second.
	\param maxParticlesPerSecond: Maximal amount of particles emitted per
	second.
	\param minStartColor: Minimal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param maxStartColor: Maximal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param lifeTimeMin: Minimal lifetime of a particle, in milliseconds.
	\param lifeTimeMax: Maximal lifetime of a particle, in milliseconds.
	\param maxAngleDegrees: Maximal angle in degrees, the emitting
	direction of the particle will differ from the original direction.
	\param minStartSize: Minimal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\param maxStartSize: Maximal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\return Pointer to the created particle emitter. To set this emitter
	as new emitter of this particle system, just call setEmitter(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createBoxEmitter(irr.core.aabbox3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Int32,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.">
\param box: The box for the emitter.
	\param direction: Direction and speed of particle emission.
	\param minParticlesPerSecond: Minimal amount of particles emitted per
	second.
	\param maxParticlesPerSecond: Maximal amount of particles emitted per
	second.
	\param minStartColor: Minimal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param maxStartColor: Maximal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param lifeTimeMin: Minimal lifetime of a particle, in milliseconds.
	\param lifeTimeMax: Maximal lifetime of a particle, in milliseconds.
	\param maxAngleDegrees: Maximal angle in degrees, the emitting
	direction of the particle will differ from the original direction.
	\param minStartSize: Minimal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\param maxStartSize: Maximal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\return Pointer to the created particle emitter. To set this emitter
	as new emitter of this particle system, just call setEmitter(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.createAnimatedMeshSceneNodeEmitter(irr.scene.IAnimatedMeshSceneNode*,System.Boolean,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Int32,System.Boolean,System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Int32,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime">
\param node: Pointer to the animated mesh scene node to emit
	particles from
	\param useNormalDirection: If true, the direction of each particle
	created will be the normal of the vertex that it's emitting from. The
	normal is divided by the normalDirectionModifier parameter, which
	defaults to 100.0f.
	\param direction: Direction and speed of particle emission.
	\param normalDirectionModifier: If the emitter is using the normal
	direction then the normal of the vertex that is being emitted from is
	divided by this number.
	\param mbNumber: This allows you to specify a specific meshBuffer for
	the IMesh* to emit particles from. The default value is -1, which
	means a random meshBuffer picked from all of the meshes meshBuffers
	will be selected to pick a random vertex from. If the value is 0 or
	greater, it will only pick random vertices from the meshBuffer
	specified by this value.
	\param everyMeshVertex: If true, the emitter will emit between min/max
	particles every second, for every vertex in the mesh, if false, it will
	emit between min/max particles from random vertices in the mesh.
	\param minParticlesPerSecond: Minimal amount of particles emitted per
	second.
	\param maxParticlesPerSecond: Maximal amount of particles emitted per
	second.
	\param minStartColor: Minimal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param maxStartColor: Maximal initial start color of a particle. The
	real color of every particle is calculated as random interpolation
	between minStartColor and maxStartColor.
	\param lifeTimeMin: Minimal lifetime of a particle, in milliseconds.
	\param lifeTimeMax: Maximal lifetime of a particle, in milliseconds.
	\param maxAngleDegrees: Maximal angle in degrees, the emitting
	direction of the particle will differ from the original direction.
	\param minStartSize: Minimal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\param maxStartSize: Maximal initial start size of a particle. The
	real size of every particle is calculated as random interpolation
	between minStartSize and maxStartSize.
	\return Pointer to the created particle emitter. To set this emitter
	as new emitter of this particle system, just call setEmitter(). Note
	that you'll have to drop() the returned pointer, after you don't need
	it any more, see IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.getAffectors">
\return The list of particle affectors attached to this node. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.addAffector(irr.scene.IParticleAffector*)">
A particle affector modifies the particles. For example, the FadeOut
	affector lets all particles fade out after some time. It is created and
	used in this way:
	\code
	IParticleAffector* p = createFadeOutParticleAffector();
	addAffector(p);
	p-&gt;drop();
	\endcode
	Please note that an affector is not necessary for the particle system to
	work.
	\param affector: New affector. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.setEmitter(irr.scene.IParticleEmitter*)">
A particle emitter can be created using one of the createEmitter
	methods. For example to create and use a simple PointEmitter, call
	IParticleEmitter* p = createPointEmitter(); setEmitter(p); p-&gt;drop();
	\param emitter: Sets the particle emitter. You can set this to 0 for
	removing the current emitter and stopping the particle system emitting
	new particles. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.getEmitter">
\return The particle emitter. Can be 0 if none is set. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.doParticleSystem(System.UInt32)">
This should only be called when you want to render the node outside
	the scenegraph, as the node will care about this otherwise
	automatically. 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.getParticleBehavior">
\return A combination of ::EParticleBehavior flags 
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.setParticleBehavior(System.UInt32)">
\param flags A combination of ::EParticleBehavior bit-flags. Default is 0.	
</member>
        <member name="M:irr.scene.IParticleSystemSceneNode.setParticlesAreGlobal(System.Boolean)">
If they are, the particles are affected by the movement of the
	particle system scene node too, otherwise they completely ignore it.
	Default is true. 
</member>
        <member name="M:irr.scene.IParticleGravityAffector.setTimeForceLost(System.Single)">
At that point the particle does not move any more. 
</member>
        <member name="M:irr.scene.IParticleAffector.affect(System.UInt32,irr.scene.SParticle*,System.UInt32)">
\param now Current time. (Same as ITimer::getTime() would return)
	\param particlearray Array of particles.
	\param count Amount of particles in array. 
</member>
        <member name="M:irr.scene.IParticleEmitter.emitt(System.UInt32,System.UInt32,irr.scene.SParticle**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param now Current time.
	\param timeSinceLastCall Time elapsed since last call, in milliseconds.
	\param outArray Pointer which will point to the array with the new
	particles to add into the system.
	\return Amount of new particles in the array. Can be 0. 
</member>
        <member name="T:irr.scene.IParticleEmitter">
A Particle emitter emits new particles into a particle system.

</member>
        <member name="F:irr.scene.SParticle.startSize">
The scale of the particle when it was emitted. 
</member>
        <member name="F:irr.scene.SParticle.size">
The current scale of the particle. 
</member>
        <member name="F:irr.scene.SParticle.startVector">
The direction and speed the particle had when it was emitted. 
</member>
        <member name="F:irr.scene.SParticle.startColor">
That's the color of the particle it had when it was emitted. 
</member>
        <member name="M:irr.IOSOperator.getSystemMemory(System.UInt32*,System.UInt32*)">
\param totalBytes: will contain the total system memory in bytes
	\param availableBytes: will contain the available memory in bytes
	\return True if successful, false if not 
</member>
        <member name="M:irr.IOSOperator.getProcessorSpeedMHz(System.UInt32*)">
\param MHz The integer variable to store the speed in.
	\return True if successful, false if not 
</member>
        <member name="M:irr.IOSOperator.getTextFromClipboard">
\return Returns 0 if no string is in there. 
</member>
        <member name="M:irr.IOSOperator.getOperationSystemVersion">
\deprecated Use getOperatingSystemVersion instead. This method will be removed in Irrlicht 1.9. 
</member>
        <member name="M:irr.scene.IMetaTriangleSelector.removeTriangleSelector(irr.scene.ITriangleSelector*)">
\param toRemove: Pointer to an triangle selector which is in the
	list but will be removed.
	\return True if successful, false if not. 
</member>
        <member name="M:irr.scene.IMetaTriangleSelector.addTriangleSelector(irr.scene.ITriangleSelector*)">
\param toAdd: Pointer to an triangle selector to add to the list. 
</member>
        <member name="T:irr.scene.IMetaTriangleSelector">
This is nothing more than a collection of one or more triangle selectors
providing together the interface of one triangle selector. In this way,
collision tests can be done with different triangle soups in one pass.

</member>
        <member name="M:irr.scene.IColladaMeshWriter.SetParamNamesUV(irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Param names for UV's have a name. By default it's "U" and "V".
			Usually it doesn't matter as names are optional in Collada anyway.
			But unfortunately some tools insist on specific names.
			So if "U", "V" does not work then try to export by setting this to "S", "T".
			One tool which insists on "S", "T" is for example SketchUp.

</member>
        <member name="M:irr.scene.IColladaMeshWriter.findGeometryNameForNode(irr.scene.ISceneNode*)">
The name comes from IColladaMeshWriterNames::nameForMesh, but you can't access the node there.
		\return Either a pointer to the name or NULL 
</member>
        <member name="M:irr.scene.IColladaMeshWriter.toNCName(irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A tool function to help when using a custom name generator to generative valid names for collada names and id's. 
</member>
        <member name="M:irr.scene.IColladaMeshWriter.getDefaultNameGenerator">
You can use this pointer in your own generator to access and return default values. 
</member>
        <member name="M:irr.scene.IColladaMeshWriter.getDefaultProperties">
You can use this pointer in your own properties to access and return default values. 
</member>
        <member name="M:irr.scene.IColladaMeshWriter.setProperties(irr.scene.IColladaMeshWriterProperties*)">
Overloading properties with an own class allows modifying the writing process in certain ways.
		By default properties are set to the DefaultProperties. 
</member>
        <member name="M:irr.scene.IColladaMeshWriter.setExportSMaterialsOnlyOnce(System.Boolean)">
Checks before creating a collada material-name if an identical
		irr:::video::SMaterial has been exported already. If so don't export it with
		another name. This is set by default and leads to way smaller .dae files.
		Note that if you need to disable this flag for some reason you can still
		get a similar effect using the IColladaMeshWriterNames::nameForMaterial
		by returning identical names for identical materials there.

</member>
        <member name="M:irr.scene.IColladaMeshWriter.setGeometryWriting(irr.scene.E_COLLADA_GEOMETRY_WRITING)">
Optimally ECGI_PER_MESH would be always sufficient - writing geometry once per mesh.
		Unfortunately many tools (at the time of writing this nearly all of them) have trouble
		on import when different materials are used per node. So when you override materials
		per node and importing the resulting collada has materials problems in other tools try
		using other values here.
		\param writeStyle One of the E_COLLADA_GEOMETRY_WRITING settings.

</member>
        <member name="M:irr.scene.IColladaMeshWriter.setUnit(System.Single,irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param meter: Real-world meters to use per unit. Default 1 unit = 1 meter. For 1 unit = 1cm you would set to 0.01
\param name: Name to use for distance unit. Default is "meter".	
</member>
        <member name="M:irr.scene.IColladaMeshWriter.setWriteDefaultScene(System.Boolean)">
Many collada readers fail to read a mesh if the collada files doesn't contain a scene as well.
		The scene is doing an instantiation of the mesh.
		When using writeScene this flag is ignored (as we have scene there already)

</member>
        <member name="M:irr.scene.IColladaMeshWriterNames.nameForMaterial(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*,irr.scene.ISceneNode!System.Runtime.CompilerServices.IsConst*)">
There is one material created in the writer for each unique name.
		So you can use this to control the number of materials which get written.
		For example Irrlicht does by default write one material for each material
		instanced by a node. So if you know that in your application material
		instances per node are identical between different nodes you can reduce
		the number of exported materials using that knowledge by using identical
		names for such shared materials.
		Names must follow the xs:NCName standard to be valid, you can run them
		through IColladaMeshWriter::toNCName to ensure that.

</member>
        <member name="M:irr.scene.IColladaMeshWriterNames.nameForNode(irr.scene.ISceneNode!System.Runtime.CompilerServices.IsConst*)">
Note that names really must be unique here per node-pointer, so
		mostly it's a good idea to return the nameForNode from
		IColladaMeshWriter::getDefaultNameGenerator(). Also names must follow
		the xs:NCName standard to be valid, you can run them through
		IColladaMeshWriter::toNCName to ensure that.

</member>
        <member name="M:irr.scene.IColladaMeshWriterNames.nameForMesh(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Note that names really must be unique here per mesh-pointer, so
		mostly it's a good idea to return the nameForMesh from
		IColladaMeshWriter::getDefaultNameGenerator(). Also names must follow
		the xs:NCName standard to be valid, you can run them through
		IColladaMeshWriter::toNCName to ensure that.
		\param mesh Pointer to the mesh which needs a name
		\param instance When E_COLLADA_GEOMETRY_WRITING is not ECGI_PER_MESH then
		several instances of the same mesh can be written and this counts them.

</member>
        <member name="T:irr.scene.IColladaMeshWriterNames">
You can either modify names and id's written to collada or you can use
	this interface to just find out which names are used on writing.
	Names are often used later as xs:anyURI, so avoid whitespace, '#' and '%' in the names.

</member>
        <member name="M:irr.scene.IColladaMeshWriterProperties.useNodeMaterial(irr.scene.ISceneNode!System.Runtime.CompilerServices.IsConst*)">
Usually true except for mesh-nodes which have isReadOnlyMaterials set.
		This is mostly important for naming (as ISceneNode::getMaterial() already returns the correct material).
		You have to override it when exporting custom scenenodes with own materials.
		\return true =&gt; The node's own material is used, false =&gt; ignore node material and use the one from the mesh 
</member>
        <member name="M:irr.scene.IColladaMeshWriterProperties.getTransparentFx(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Not this is only about ECCS_TRANSPARENT and does not affect getTransparency. 
</member>
        <member name="M:irr.scene.IColladaMeshWriterProperties.getCustomColor(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.E_COLLADA_COLOR_SAMPLER)">
Only used when getColorMapping returns ECIC_CUSTOM for the same parameters. 
</member>
        <member name="M:irr.scene.IColladaMeshWriterProperties.getColorMapping(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.E_COLLADA_COLOR_SAMPLER)">
Note that collada allows exporting either texture or color, not both.
			So color mapping is only checked if we have no valid texture already.
			By default we try to return best fits when possible. For example ECCS_DIFFUSE is mapped to ECIC_DIFFUSE.
			When ECIC_CUSTOM is returned then the result of getCustomColor will be used. 
</member>
        <member name="M:irr.scene.IColladaMeshWriterProperties.getTextureIdx(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.E_COLLADA_COLOR_SAMPLER)">
\return the index to the texture-layer or -1 if that texture should never be exported
			Note: for ECCS_TRANSPARENT by default the alpha channel is used, if you want to use RGB you have to set
			also the ECOF_RGB_ZERO flag in getTransparentFx.  
</member>
        <member name="M:irr.scene.IOctreeSceneNode.setUseVBO(irr.scene.EOCTREENODE_VBO)">
NOTE: When there is already a mesh in the node this will rebuild
	the octree. 
</member>
        <member name="M:irr.scene.IOctreeSceneNode.#ctor(irr.scene.ISceneNode*,irr.scene.ISceneManager*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use setMesh() to set the mesh to display.

</member>
        <member name="T:irr.scene.EOCTREENODE_VBO">
VBO = Vertex buffer object = meshbuffers bound on the graphic-card instead of uploaded each frame.
	It can not be generally said which mode is optimal for drawing as this depends
	on the scene. So you have to try and experiment for your meshes which one works best.

</member>
        <member name="M:irr.scene.IMeshWriter.writeMesh(irr.io.IWriteFile*,irr.scene.IMesh*,System.Int32)">
\param file File handle to write the mesh to.
		\param mesh Pointer to mesh to be written.
		\param flags Optional flags to set properties of the writer.
		\return True if successful 
</member>
        <member name="M:irr.scene.IMeshWriter.getType">
For own implementations, use MAKE_IRR_ID as shown in the
		EMESH_WRITER_TYPE enumeration to return your own unique mesh
		type id.
		\return Type of the mesh writer. 
</member>
        <member name="M:irr.scene.IMeshSceneNode.isReadOnlyMaterials">
This flag can be set by setReadOnlyMaterials().
	\return Whether the materials are read-only. 
</member>
        <member name="M:irr.scene.IMeshSceneNode.setReadOnlyMaterials(System.Boolean)">
In this way it is possible to change the materials of a mesh
	causing all mesh scene nodes referencing this mesh to change, too.
	\param readonly Flag if the materials shall be read-only. 
</member>
        <member name="M:irr.scene.IMeshSceneNode.addShadowVolumeSceneNode(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Boolean,System.Single)">
The shadow can be rendered using the ZPass or the zfail
	method. ZPass is a little bit faster because the shadow volume
	creation is easier, but with this method there occur ugly
	looking artifacts when the camera is inside the shadow volume.
	These error do not occur with the ZFail method.
	\param shadowMesh: Optional custom mesh for shadow volume.
	\param id: Id of the shadow scene node. This id can be used to
	identify the node later.
	\param zfailmethod: If set to true, the shadow will use the
	zfail method, if not, zpass is used.
	\param infinity: Value used by the shadow volume algorithm to
	scale the shadow volume (for zfail shadow volume we support only
	finite shadows, so camera zfar must be larger than shadow back cap,
	which is depend on infinity parameter).
	\return Pointer to the created shadow scene node. This pointer
	should not be dropped. See IReferenceCounted::drop() for more
	information. 
</member>
        <member name="M:irr.scene.IMeshSceneNode.getMesh">
\return Pointer to mesh which is displayed by this node. 
</member>
        <member name="M:irr.scene.IMeshSceneNode.setMesh(irr.scene.IMesh*)">
\param mesh Mesh to display. 
</member>
        <member name="M:irr.scene.IMeshSceneNode.#ctor(irr.scene.ISceneNode*,irr.scene.ISceneManager*,System.Int32,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use setMesh() to set the mesh to display.

</member>
        <member name="M:irr.scene.IMeshManipulator.heightmapOptimizeMesh(irr.scene.IMeshBuffer*!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
		This differs from usual simplification methods in two ways:
		- it's intended to be lossless
		- it has special care for the borders, which are useful with heightmap tiles

		This function is thread-safe. Remember to weld afterward - this
		function only moves vertices, it does not weld.

		\param mb Meshbuffer to operate on.

</member>
        <member name="M:irr.scene.IMeshManipulator.heightmapOptimizeMesh(irr.scene.IMesh*!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
		This differs from usual simplification methods in two ways:
		- it's intended to be lossless
		- it has special care for the borders, which are useful with heightmap tiles

		This function is thread-safe. Remember to weld afterwards - this
		function only moves vertices, it does not weld.

		\param mesh Mesh to operate on.

</member>
        <member name="M:irr.scene.IMeshManipulator.createForsythOptimizedMesh(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*)">
More information can be found at
		http://home.comcast.net/~tom_forsyth/papers/fast_vert_cache_opt.html

		The function is thread-safe (read: you can optimize several
		meshes in different threads).

		\param mesh Source mesh for the operation.
		\return A new mesh optimized for the vertex cache. 
</member>
        <member name="M:irr.scene.IMeshManipulator.createAnimatedMesh(irr.scene.IMesh*,irr.scene.E_ANIMATED_MESH_TYPE)">
\param mesh Input mesh
		\param type The type of the animated mesh to create.
		\return Newly created animated mesh with mesh as its only
		content. When you don't need the animated mesh anymore, you
		should call IAnimatedMesh::drop(). See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IMeshManipulator.getPolyCount(irr.scene.IAnimatedMesh*)">
\param mesh Input mesh
		\return Number of polygons in mesh. 
</member>
        <member name="M:irr.scene.IMeshManipulator.getPolyCount(irr.scene.IMesh*)">
\param mesh Input mesh
		\return Number of polygons in mesh. 
</member>
        <member name="M:irr.scene.IMeshManipulator.createMeshWelded(irr.scene.IMesh*,System.Single)">
\param mesh Input mesh
		\param tolerance The threshold for vertex comparisons.
		\return Mesh without redundant vertices. If you no longer need
		the cloned mesh, you should call IMesh::drop(). See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IMeshManipulator.createMeshUniquePrimitives(irr.scene.IMesh*)">
\param mesh Input mesh
		\return Mesh consisting only of unique faces. All vertices
		which were previously shared are now duplicated. If you no
		longer need the cloned mesh, you should call IMesh::drop(). See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IMeshManipulator.createMeshWith1TCoords(irr.scene.IMesh*)">
\param mesh Input mesh
		\return Mesh consisting only of S3DVertex vertices. If
		you no longer need the cloned mesh, you should call
		IMesh::drop(). See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.scene.IMeshManipulator.createMeshWith2TCoords(irr.scene.IMesh*)">
\param mesh Input mesh
		\return Mesh consisting only of S3DVertex2TCoord vertices. If
		you no longer need the cloned mesh, you should call
		IMesh::drop(). See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.scene.IMeshManipulator.createMeshWithTangents(irr.scene.IMesh*,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
This is useful if you want to draw tangent space normal
		mapped geometry because it calculates the tangent and binormal
		data which is needed there.
		\param mesh Input mesh
		\param recalculateNormals The normals are recalculated if set,
		otherwise the original ones are kept. Note that keeping the
		normals may introduce inaccurate tangents if the normals are
		very different to those calculated from the faces.
		\param smooth The normals/tangents are smoothed across the
		meshbuffer's faces if this flag is set.
		\param angleWeighted Improved smoothing calculation used
		\param recalculateTangents Whether are actually calculated, or just the mesh with proper type is created.
		\return Mesh consisting only of S3DVertexTangents vertices. If
		you no longer need the cloned mesh, you should call
		IMesh::drop(). See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.scene.IMeshManipulator.createMeshCopy(irr.scene.IMesh*)">
All meshbuffers in the returned SMesh
		are of type SMeshBuffer or SMeshBufferLightMap.
		\param mesh Mesh to copy.
		\return Cloned mesh. If you no longer need the
		cloned mesh, you should call SMesh::drop(). See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IMeshManipulator.makePlanarTextureMapping(irr.scene.IMeshBuffer*,System.Single,System.Single,System.Byte,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method is currently implemented towards the LWO planar mapping. A more general biasing might be required.
		\param buffer Buffer on which the operation is performed.
		\param resolutionS Resolution of the planar mapping in horizontal direction. This is the ratio between object space and texture space.
		\param resolutionT Resolution of the planar mapping in vertical direction. This is the ratio between object space and texture space.
		\param axis The axis along which the texture is projected. The allowed values are 0 (X), 1(Y), and 2(Z).
		\param offset Vector added to the vertex positions (in object coordinates).

</member>
        <member name="M:irr.scene.IMeshManipulator.makePlanarTextureMapping(irr.scene.IMesh*,System.Single,System.Single,System.Byte,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method is currently implemented towards the LWO planar mapping. A more general biasing might be required.
		\param mesh Mesh on which the operation is performed.
		\param resolutionS Resolution of the planar mapping in horizontal direction. This is the ratio between object space and texture space.
		\param resolutionT Resolution of the planar mapping in vertical direction. This is the ratio between object space and texture space.
		\param axis The axis along which the texture is projected. The allowed values are 0 (X), 1(Y), and 2(Z).
		\param offset Vector added to the vertex positions (in object coordinates).

</member>
        <member name="M:irr.scene.IMeshManipulator.makePlanarTextureMapping(irr.scene.IMeshBuffer*,System.Single)">
\param meshbuffer: Buffer on which the operation is performed.
		\param resolution: resolution of the planar mapping. This is
		the value specifying which is the relation between world space
		and texture coordinate space. 
</member>
        <member name="M:irr.scene.IMeshManipulator.makePlanarTextureMapping(irr.scene.IMesh*,System.Single)">
\param mesh: Mesh on which the operation is performed.
		\param resolution: resolution of the planar mapping. This is
		the value specifying which is the relation between world space
		and texture coordinate space. 
</member>
        <member name="M:irr.scene.IMeshManipulator.transformMesh(irr.scene.IMesh*,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\deprecated Use transform() instead. This method may be removed by Irrlicht 1.9
		\param mesh Mesh on which the operation is performed.
		\param m transformation matrix. 
</member>
        <member name="M:irr.scene.IMeshManipulator.transform(irr.scene.IMeshBuffer*,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param buffer Meshbuffer on which the operation is performed.
		\param m transformation matrix. 
</member>
        <member name="M:irr.scene.IMeshManipulator.transform(irr.scene.IMesh*,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param mesh Mesh on which the operation is performed.
		\param m transformation matrix. 
</member>
        <member name="M:irr.scene.IMeshManipulator.scaleTCoords(irr.scene.IMeshBuffer*,irr.core.vector2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
\param buffer Meshbuffer on which the operation is performed.
		\param factor Vector which defines the scale for each axis.
		\param level Number of texture coord, starting from 1. Support for level 2 exists for LightMap buffers. 
</member>
        <member name="M:irr.scene.IMeshManipulator.scaleTCoords(irr.scene.IMesh*,irr.core.vector2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
\param mesh Mesh on which the operation is performed.
		\param factor Vector which defines the scale for each axis.
		\param level Number of texture coord, starting from 1. Support for level 2 exists for LightMap buffers. 
</member>
        <member name="M:irr.scene.IMeshManipulator.scaleMesh(irr.scene.IMesh*,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\deprecated Use scale() instead. This method may be removed by Irrlicht 1.9
		\param mesh Mesh on which the operation is performed.
		\param factor Scale factor for each axis. 
</member>
        <member name="M:irr.scene.IMeshManipulator.scale(irr.scene.IMeshBuffer*,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param buffer Meshbuffer on which the operation is performed.
		\param factor Scale factor for each axis. 
</member>
        <member name="M:irr.scene.IMeshManipulator.scale(irr.scene.IMesh*,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param mesh Mesh on which the operation is performed.
		\param factor Scale factor for each axis. 
</member>
        <member name="M:irr.scene.IMeshManipulator.recalculateTangents(irr.scene.IMeshBuffer*,System.Boolean,System.Boolean,System.Boolean)">
\param buffer Meshbuffer on which the operation is performed.
		\param recalculateNormals If the normals shall be recalculated, otherwise original normals of the buffer are used unchanged.
		\param smooth If the normals shall be smoothed.
		\param angleWeighted If the normals shall be smoothed in relation to their angles. More expensive, but also higher precision.

</member>
        <member name="M:irr.scene.IMeshManipulator.recalculateTangents(irr.scene.IMesh*,System.Boolean,System.Boolean,System.Boolean)">
\param mesh Mesh on which the operation is performed.
		\param recalculateNormals If the normals shall be recalculated, otherwise original normals of the mesh are used unchanged.
		\param smooth If the normals shall be smoothed.
		\param angleWeighted If the normals shall be smoothed in relation to their angles. More expensive, but also higher precision.

</member>
        <member name="M:irr.scene.IMeshManipulator.recalculateNormals(irr.scene.IMeshBuffer*,System.Boolean,System.Boolean)">
\param buffer: Mesh buffer on which the operation is performed.
		\param smooth: If the normals shall be smoothed.
		\param angleWeighted: If the normals shall be smoothed in relation to their angles. More expensive, but also higher precision. 
</member>
        <member name="M:irr.scene.IMeshManipulator.recalculateNormals(irr.scene.IMesh*,System.Boolean,System.Boolean)">
\param mesh: Mesh on which the operation is performed.
		\param smooth: If the normals shall be smoothed.
		\param angleWeighted: If the normals shall be smoothed in relation to their angles. More expensive, but also higher precision. 
</member>
        <member name="M:irr.scene.IMeshManipulator.setVertexColors(irr.scene.IMeshBuffer*,irr.video.SColor)">
\param buffer Meshbuffer on which the operation is performed.
		\param color New color. 
</member>
        <member name="M:irr.scene.IMeshManipulator.setVertexColors(irr.scene.IMesh*,irr.video.SColor)">
\param mesh Mesh on which the operation is performed.
		\param color New color. 
</member>
        <member name="M:irr.scene.IMeshManipulator.setVertexColorAlpha(irr.scene.IMeshBuffer*,System.Int32)">
\param buffer Meshbuffer on which the operation is performed.
		\param alpha New alpha value. Must be a value between 0 and 255. 
</member>
        <member name="M:irr.scene.IMeshManipulator.setVertexColorAlpha(irr.scene.IMesh*,System.Int32)">
\param mesh Mesh on which the operation is performed.
		\param alpha New alpha value. Must be a value between 0 and 255. 
</member>
        <member name="M:irr.scene.IMeshManipulator.flipSurfaces(irr.scene.IMesh*)">
Changes backfacing triangles to frontfacing
		triangles and vice versa.
		\param mesh Mesh on which the operation is performed. 
</member>
        <member name="T:irr.scene.IMeshManipulator">
Scale, set alpha value, flip surfaces, and so on. This exists for
	fixing problems with wrong imported or exported meshes quickly after
	loading. It is not intended for doing mesh modifications and/or
	animations during runtime.

</member>
        <member name="T:irr.scene.SVertexPositionScaleAlongNormalsManipulator">
This can look more pleasing than the usual Scale operator, but
	depends on the mesh geometry.

</member>
        <member name="T:irr.scene.SVertexColorInterpolateQuadraticManipulator">
Uses linear interpolation. 
</member>
        <member name="T:irr.scene.SVertexColorInterpolateLinearManipulator">
Uses linear interpolation. 
</member>
        <member name="T:irr.scene.SVertexColorDesaturateToLuminanceManipulator">
Uses the luminance value of the color. 
</member>
        <member name="T:irr.scene.SVertexColorDesaturateToAverageManipulator">
Uses the average value of the color. 
</member>
        <member name="T:irr.scene.SVertexColorDesaturateToLightnessManipulator">
Uses the lightness value of the color. 
</member>
        <member name="T:irr.scene.SVertexColorScaleManipulator">
Can e.g be used for white balance, factor would be 255.f/brightest color. 
</member>
        <member name="T:irr.scene.SVertexColorGammaManipulator">
A value over one increases brightness, one below darkens the colors. 
</member>
        <member name="T:irr.scene.SVertexColorContrastBrightnessManipulator">
Factors over 1 increase contrast, below 1 reduce it.
	A positive amount increases brightness, a negative one darkens the colors. 
</member>
        <member name="T:irr.scene.SVertexColorContrastManipulator">
Factors over 1 increase contrast, below 1 reduce it. 
</member>
        <member name="T:irr.scene.SVertexColorBrightnessManipulator">
A positive value increases brightness, a negative value darkens the colors. 
</member>
        <member name="T:irr.scene.SVertexColorThresholdManipulator">
If average of the color value is &gt;Threshold the High color is chosen, else Low. 
</member>
        <member name="T:irr.scene.IVertexManipulator">
You should derive your manipulator from this class if it shall be called for every vertex, getting as parameter just the vertex.

</member>
        <member name="M:irr.scene.IMeshLoader.getMeshTextureLoader">
NOTE: not all meshloaders support this interface so this can return NULL.

</member>
        <member name="M:irr.scene.IMeshLoader.setMeshTextureLoader(irr.scene.IMeshTextureLoader*)">
NOTE: Not all meshloaders do support this interface. Meshloaders which
	support it will return a non-null value in getMeshTextureLoader from the start. Setting a
	texture-loader to a meshloader which doesn't support it won't help.
	\param textureLoader The textureloader to use. When set to NULL the mesh will not load any textures.

</member>
        <member name="M:irr.scene.IMeshLoader.createMesh(irr.io.IReadFile*)">
\param file File handler to load the file from.
	\return Pointer to the created mesh. Returns 0 if loading failed.
	If you no longer need the mesh, you should call IAnimatedMesh::drop().
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.scene.IMeshLoader.isALoadableFileExtension(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This decision should be based on the file extension (e.g. ".cob")
	only.
	\param filename Name of the file to test.
	\return True if the file might be loaded by this class. 
</member>
        <member name="T:irr.scene.IMeshLoader">
If you want Irrlicht be able to load meshes of
currently unsupported file formats (e.g. .cob), then implement
this and add your new Meshloader with
ISceneManager::addExternalMeshLoader() to the engine. 
</member>
        <member name="M:irr.scene.IMeshTextureLoader.setMaterialFile(irr.io.IReadFile!System.Runtime.CompilerServices.IsConst*)">
Usually you do not have to use this method, it is used internally by IMeshLoader's.
	Any values you set here will likely be overwritten internally.	
</member>
        <member name="M:irr.scene.IMeshTextureLoader.setMeshFile(irr.io.IReadFile!System.Runtime.CompilerServices.IsConst*)">
Usually you do not have to use this method, it is used internally by IMeshLoader's.
		Any values you set here will likely be overwritten internally. 
</member>
        <member name="M:irr.scene.IMeshTextureLoader.getTexture(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Usually you do not have to use this method, it is used internally by IMeshLoader's.
	\param textureName Texturename as used in the mesh-format
	\return Pointer to the texture. Returns 0 if loading failed.
</member>
        <member name="M:irr.scene.IMeshTextureLoader.setTexturePath(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is the first path the texture-loader should search.  
</member>
        <member name="T:irr.scene.IMeshTextureLoader">
A texture loader can search for a texture in several paths.
For example relative to a given texture-path, relative to the current
working directory or relative to a mesh- and/or material-file.

</member>
        <member name="M:irr.scene.IMeshCache.clearUnusedMeshes">
Warning: If you have pointers to meshes that were loaded with ISceneManager::getMesh()
		and you did not grab them, then they may become invalid. 
</member>
        <member name="M:irr.scene.IMeshCache.clear">
All meshes will be reloaded completely when using ISceneManager::getMesh()
		after calling this method.
		Warning: If you have pointers to meshes that were loaded with ISceneManager::getMesh()
		and you did not grab them, then they may become invalid. 
</member>
        <member name="M:irr.scene.IMeshCache.isMeshLoaded(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param name Name of the mesh. Usually a filename.
		\return True if the mesh has been loaded, else false. 
</member>
        <member name="M:irr.scene.IMeshCache.renameMesh(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Note that renaming meshes might change the ordering of the
		meshes, and so the index of the meshes as returned by
		getMeshIndex() or taken by some methods will change.
		\param mesh Mesh to be renamed.
		\param name New name for the mesh.
		\return True if mesh was renamed. 
</member>
        <member name="M:irr.scene.IMeshCache.renameMesh(System.UInt32,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Note that renaming meshes might change the ordering of the
		meshes, and so the index of the meshes as returned by
		getMeshIndex() or taken by some methods will change.
		\param index The index of the mesh in the cache.
		\param name New name for the mesh.
		\return True if mesh was renamed. 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshName(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
\param mesh Pointer to mesh to query.
		\return The name if mesh was found and has a name, else the path is empty. 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshName(System.UInt32)">
\param index: Index of the mesh, number between 0 and getMeshCount()-1.
		\return The name if mesh was found and has a name, else the path is empty. 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshByName(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param name Name of the mesh. Usually a filename.
		\return Pointer to the mesh or 0 if there is none with this number. 
</member>
        <member name="M:irr.scene.IMeshCache.setMeshFilename(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\deprecated Use renameMesh() instead. This method may be removed by
		Irrlicht 1.9 
</member>
        <member name="M:irr.scene.IMeshCache.setMeshFilename(System.UInt32,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\deprecated Use renameMesh() instead. This method may be removed by
		Irrlicht 1.9 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshFilename(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
\deprecated Use getMeshName() instead. This method may be removed by
		Irrlicht 1.9 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshFilename(System.UInt32)">
\deprecated Use getMeshName() instead. This method may be removed by
		Irrlicht 1.9 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshByFilename(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\deprecated Use getMeshByName() instead. This method may be removed by
		Irrlicht 1.9 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshByIndex(System.UInt32)">
\param index: Index of the mesh, number between 0 and
		getMeshCount()-1.
		Note that this number is only valid until a new mesh is loaded
		or removed.
		\return Pointer to the mesh or 0 if there is none with this
		number. 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshIndex(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
\param mesh Pointer to the mesh to search for.
		\return Index of the mesh in the cache, or -1 if not found. 
</member>
        <member name="M:irr.scene.IMeshCache.getMeshCount">
You can load new meshes into the cache using getMesh() and
		addMesh(). If you ever need to access the internal mesh cache,
		you can do this using removeMesh(), getMeshNumber(),
		getMeshByIndex() and getMeshName().
		\return Number of meshes in cache. 
</member>
        <member name="M:irr.scene.IMeshCache.removeMesh(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
After loading a mesh with getMesh(), the mesh can be
		removed from the cache using this method, freeing a lot of
		memory.
		\param mesh Pointer to the mesh which shall be removed. 
</member>
        <member name="M:irr.scene.IMeshCache.addMesh(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.IAnimatedMesh*)">
Usually, ISceneManager::getMesh() is called to load a mesh
		from a file. That method searches the list of loaded meshes if
		a mesh has already been loaded and returns a pointer to if it
		is in that list and already in memory. Otherwise it loads the
		mesh. With IMeshCache::addMesh(), it is possible to pretend
		that a mesh already has been loaded. This method can be used
		for example by mesh loaders who need to load more than one mesh
		with one call. They can add additional meshes with this method
		to the scene manager. The COLLADA loader for example uses this
		method.
		\param name Name of the mesh. When calling
		ISceneManager::getMesh() with this name it will return the mesh
		set by this method.
		\param mesh Pointer to a mesh which will now be referenced by
		this name. 
</member>
        <member name="T:irr.scene.IMeshCache">
You can access it using ISceneManager::getMeshCache(). All existing
	scene managers will return a pointer to the same mesh cache, because it
	is shared between them. With this interface, it is possible to manually
	add new loaded meshes (if ISceneManager::getMesh() is not sufficient),
	to remove them and to iterate through already loaded meshes. 
</member>
        <member name="M:irr.video.IMaterialRendererServices.getVideoDriver">
\return Pointer to the IVideoDriver interface 
</member>
        <member name="M:irr.video.IMaterialRendererServices.setPixelShaderConstant(System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Can be used if you created a shader using pixel/vertex shader
	assembler or ARB_fragment_program or ARB_vertex_program.
	\param data Data to be set in the constants
	\param startRegister First register to be set.
	\param constantAmount Amount of registers to be set. One register consists of 4 floats. 
</member>
        <member name="M:irr.video.IMaterialRendererServices.setPixelShaderConstant(System.Int32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32)">
This can be used if you used a high level shader language like GLSL
	or HLSL to create a shader. See setVertexShaderConstant() for an
	example on how to use this.
	\param index Index of the variable
	\param floats Pointer to array of floats
	\param count Amount of floats in array.
	\return True if successful. 
</member>
        <member name="M:irr.video.IMaterialRendererServices.setVertexShaderConstant(System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Can be used if you created a shader using pixel/vertex shader
	assembler or ARB_fragment_program or ARB_vertex_program.
	\param data: Data to be set in the constants
	\param startRegister: First register to be set
	\param constantAmount: Amount of registers to be set. One register consists of 4 floats. 
</member>
        <member name="M:irr.video.IMaterialRendererServices.setBasicRenderStates(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Sets all basic renderstates if needed.
	Basic render states are diffuse, ambient, specular, and emissive color,
	specular power, bilinear and trilinear filtering, wireframe mode,
	grouraudshading, lighting, zbuffer, zwriteenable, backfaceculling and
	fog enabling.
	\param material The new material to be used.
	\param lastMaterial The material used until now.
	\param resetAllRenderstates Set to true if all renderstates should be
	set, regardless of their current state. 
</member>
        <member name="M:irr.video.IMaterialRenderer.getShaderConstantSetCallBack">
\returns Returns either the users provided callback or 0 when no such 
	callback exists. Non-shader materials will always return 0.	
</member>
        <member name="M:irr.video.IMaterialRenderer.getRenderCapability">
Because some more complex materials
	are implemented in multiple ways and need special hardware capabilities, it is possible
	to query how the current material renderer is performing on the current hardware with this
	function.
	\return Returns 0 if everything is running fine. Any other value is material renderer
	specific and means for example that the renderer switched back to a fall back material because
	it cannot use the latest shaders. More specific examples:
	Fixed function pipeline materials should return 0 in most cases, parallax mapped
	material will only return 0 when at least pixel shader 1.4 is available on that machine. 
</member>
        <member name="M:irr.video.IMaterialRenderer.isTransparent">
The scene management needs to know this
	for being able to sort the materials by opaque and transparent. 
</member>
        <member name="M:irr.video.IMaterialRenderer.OnUnsetMaterial">
Called during the IVideoDriver::setMaterial() call before the new
	material will get the OnSetMaterial() call. 
</member>
        <member name="M:irr.video.IMaterialRenderer.OnRender(irr.video.IMaterialRendererServices*,irr.video.E_VERTEX_TYPE)">
OnSetMaterial should normally only be called if the renderer decides
	that the renderstates should be changed, it won't be called if for
	example two drawIndexedTriangleList() will be called with the same
	material set. This method will be called every time. This is useful for
	example for materials with shaders, which don't only set new
	renderstates but also shader constants.
	\param service: Pointer to interface providing methods for setting
	constants and other things.
	\param vtxtype: Vertex type with which the next rendering will be done.
	This can be used by the material renderer to set some specific
	optimized shaders or if this is an incompatible vertex type for this
	renderer, to refuse rendering for example.
	\return Returns true if everything is OK, and false if nothing should
	be rendered. The material renderer can choose to return false for
	example if he doesn't support the specified vertex type. This is
	actually done in D3D9 when using a normal mapped material with
	a vertex type other than EVT_TANGENTS. 
</member>
        <member name="M:irr.video.IMaterialRenderer.OnSetMaterial(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,irr.video.IMaterialRendererServices*)">
This is called during the IVideoDriver::setMaterial() call.
	When overriding this, you can set some renderstates or for example a
	vertex or pixel shader if you like.
	\param material: The new material parameters to be set. The renderer
	may change the material flags in this material. For example if this
	material does not accept the zbuffer = true, it can set it to false.
	This is useful, because in the next lastMaterial will be just the
	material in this call.
	\param lastMaterial: The material parameters which have been set before
	this material.
	\param resetAllRenderstates: True if all renderstates should really be
	reset. This is usually true if the last rendering mode was not a usual
	3d rendering mode, but for example a 2d rendering mode.
	You should reset really all renderstates if this is true, no matter if
	the lastMaterial had some similar settings. This is used because in
	most cases, some common renderstates are not changed if they are
	already there, for example bilinear filtering, wireframe,
	gouraudshading, lighting, zbuffer, zwriteenable, backfaceculling and
	fogenable.
	\param services: Interface providing some methods for changing
	advanced, internal states of a IVideoDriver. 
</member>
        <member name="T:irr.video.IMaterialRenderer">
Can be used to extend the engine with new materials. Refer to
IVideoDriver::addMaterialRenderer() for more information on how to extend the
engine with new materials. 
</member>
        <member name="M:irr.scene.ILightSceneNode.getCastShadow">
\return True if light would cast shadows, else false. 
</member>
        <member name="M:irr.scene.ILightSceneNode.enableCastShadow(System.Boolean)">
Enabling this flag won't automatically cast shadows, the meshes
	will still need shadow scene nodes attached. But one can enable or
	disable distinct lights for shadow casting for performance reasons.
	\param shadow True if this light shall cast shadows. 
</member>
        <member name="M:irr.scene.ILightSceneNode.getLightType">
\return The current light type. 
</member>
        <member name="M:irr.scene.ILightSceneNode.setLightType(irr.video.E_LIGHT_TYPE)">
\param type The new type. 
</member>
        <member name="M:irr.scene.ILightSceneNode.getRadius">
\return The current radius. 
</member>
        <member name="M:irr.scene.ILightSceneNode.setRadius(System.Single)">
Outside this radius the light won't lighten geometry and cast no
	shadows. Setting the radius will also influence the attenuation, setting
	it to (0,1/radius,0). If you want to override this behavior, set the
	attenuation after the radius.
	\param radius The new radius. 
</member>
        <member name="M:irr.scene.ILightSceneNode.setVisible(System.Boolean)">
All children of this node won't be visible either, when set
	to true.
	\param isVisible If the node shall be visible. 
</member>
        <member name="M:irr.scene.ILightSceneNode.getLightData">
\return The light data. 

\return The light data. 
</member>
        <member name="M:irr.scene.ILightSceneNode.setLightData(irr.video.SLight!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param light The new light data. 
</member>
        <member name="T:irr.scene.ILightSceneNode">
You can switch the light on and off by making it visible or not. It can be
animated by ordinary scene node animators. If the light type is directional or
spot, the direction of the light source is defined by the rotation of the scene
node (assuming (0,0,1) as the local direction of the light).

</member>
        <member name="F:irr.video.SLight.Direction">
If Type is ELT_POINT, it is ignored. Changed via light scene node's rotation. 
</member>
        <member name="F:irr.video.SLight.Position">
If Type is ELT_DIRECTIONAL, it is ignored. Changed via light scene node's position. 
</member>
        <member name="F:irr.video.SLight.Attenuation">
Changes the light strength fading over distance.
	Can also be altered by setting the radius, Attenuation will change to
	(0,1.f/radius,0). Can be overridden after radius was set. 
</member>
        <member name="F:irr.video.SLight.SpecularColor">
For details how to use specular highlights, see SMaterial::Shininess 
</member>
        <member name="F:irr.video.SLight.DiffuseColor">
This is the primary color you want to set. 
</member>
        <member name="T:irr.video.SLight">
Irrlicht supports point lights, spot lights, and directional lights.

</member>
        <member name="M:irr.video.IImageWriter.writeImage(irr.io.IWriteFile*,irr.video.IImage*,System.UInt32)">
\param file File handle to write to.
	\param image Image to write into file.
	\param param Writer specific parameter, influencing e.g. quality.
	\return True if image was successfully written. 
</member>
        <member name="M:irr.video.IImageWriter.isAWriteableFileExtension(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param filename Name of the file to check.
	\return True if file extension specifies a writable type. 
</member>
        <member name="M:irr.video.IImageLoader.loadImages(irr.io.IReadFile*,irr.video.E_TEXTURE_TYPE*)">
\param file File handle to check.
	\param type Pointer to E_TEXTURE_TYPE where a recommended type of the texture will be stored.
	\return Array of pointers to newly created images. 
</member>
        <member name="M:irr.video.IImageLoader.loadImage(irr.io.IReadFile*)">
\param file File handle to check.
	\return Pointer to newly created image, or 0 upon error. 
</member>
        <member name="M:irr.video.IImageLoader.isALoadableFileFormat(irr.io.IReadFile*)">
Check might look into the file.
	\param file File handle to check.
	\return True if file seems to be loadable. 
</member>
        <member name="M:irr.video.IImageLoader.isALoadableFileExtension(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check is based on the file extension (e.g. ".tga")
	\param filename Name of file to check.
	\return True if file seems to be loadable. 
</member>
        <member name="T:irr.video.IImageLoader">
If you want the Irrlicht Engine be able to load textures of
currently unsupported file formats (e.g .gif), then implement
this and add your new Surface loader with
IVideoDriver::addExternalImageLoader() to the engine. 
</member>
        <member name="M:irr.gui.IGUIProfiler.setFrozen(System.Boolean)">
Numbers are updated once when you switch pages. 
</member>
        <member name="M:irr.gui.IGUIProfiler.isDrawBackgroundEnabled">
\return true if background drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIProfiler.getActiveFont">
Currently this is the override font when one is set and the
		font of the active skin otherwise 
</member>
        <member name="M:irr.gui.IGUIProfiler.getOverrideFont">
\return The override font (may be 0) 
</member>
        <member name="M:irr.gui.IGUIProfiler.setOverrideFont(irr.gui.IGUIFont*)">
If this is set to zero, the button uses the font of the skin.
		\param font: New font to set. 
</member>
        <member name="M:irr.gui.IGUIProfiler.setShowGroupsTogether(System.Boolean)">
\param groupsTogether When true show several groups on one page, when false show max. one group per page. Default is false. 
</member>
        <member name="M:irr.gui.IGUIProfiler.previousPage(System.Boolean)">
\param includeOverview Include the group-overview page  
</member>
        <member name="M:irr.gui.IGUIProfiler.nextPage(System.Boolean)">
\param includeOverview Include the group-overview page  
</member>
        <member name="M:irr.gui.IGUIProfiler.firstPage(System.Boolean)">
\param includeOverview When true show the group-overview page, when false show the profile data of the first group 
</member>
        <member name="M:irr.gui.IGUIProfiler.#ctor(irr.gui.IGUIEnvironment*,irr.gui.IGUIElement*,System.Int32,irr.core.rect&lt;System.Int32&gt;,irr.IProfiler*)">
\param profiler You can pass a custom profiler, but typically you can pass 0 in which cases it takes the global profiler from Irrlicht 
</member>
        <member name="M:irr.gui.IGUITreeView.getLastEventNode">
This pointer is only valid inside the OnEvent call! 
</member>
        <member name="M:irr.gui.IGUITreeView.setImageList(irr.gui.IGUIImageList*)">
The default is 0 (no images). 
</member>
        <member name="M:irr.gui.IGUITreeView.getActiveFont">
This is the override font when one is set and the
		font of the skin otherwise. 
</member>
        <member name="M:irr.gui.IGUITreeView.getOverrideFont">
\return The override font (may be 0) 
</member>
        <member name="M:irr.gui.IGUITreeView.setOverrideFont(irr.gui.IGUIFont*)">
\param font: New font to set or 0 to use the skin-font. 
</member>
        <member name="M:irr.gui.IGUITreeView.setIconFont(irr.gui.IGUIFont*)">
This font is set to the Irrlicht engine built-in-font by
		default. Icons can be displayed in front of every list item.
		An icon is a string, displayed with the icon font. When using
		the build-in-font of the Irrlicht engine as icon font, the icon
		strings defined in GUIIcons.h can be used.

</member>
        <member name="M:irr.gui.IGUITreeView.setLinesVisible(System.Boolean)">
\param visible true for visible, false for invisible 
</member>
        <member name="T:irr.gui.IGUITreeView">
Displays a windows like tree buttons to expand/collapse the child
	nodes of an node and optional tree lines. Each node consists of an
	text, an icon text and a void pointer for user data. 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.getLevel">
The root node has level 0. Direct children of the root has level 1 ... 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.moveChildDown(irr.gui.IGUITreeViewNode*)">
\return True if the node was found as a child node and was not already the last child. 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.moveChildUp(irr.gui.IGUITreeViewNode*)">
\return True if the node was found as a child node and was not already the first child. 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.deleteChild(irr.gui.IGUITreeViewNode*)">
\return Returns true if the node was found as a child and is deleted. 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.getNextVisible">
\return The next visible node from this node or 0 if this is
		the last visible node. 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.getNextSibling">
\return The next sibling node from this node or 0 if this is
		the last node from the parent node.

</member>
        <member name="M:irr.gui.IGUITreeViewNode.getPrevSibling">
\return The previous sibling node from this node or 0 if this is
		the first node from the parent node.

</member>
        <member name="M:irr.gui.IGUITreeViewNode.getLastChild">
\return The last child node or 0 if this node has no children. 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.getFirstChild">
\return The first child node or 0 if this node has no children. 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.insertChildBefore(irr.gui.IGUITreeViewNode*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Void*,irr.IReferenceCounted*)">
The other node has also to be a child node from this node.
		\param other Node to insert before
		\param text text of the new node
		\param icon icon text of the new node
		\param imageIndex index of the image for the new node (-1 = none)
		\param selectedImageIndex index of the selected image for the new node (-1 = same as imageIndex)
		\param data user data (void*) of the new node
		\param data2 user data2 (IReferenceCounted*) of the new node
		\return The new node or 0 if other is no child node from this

</member>
        <member name="M:irr.gui.IGUITreeViewNode.insertChildAfter(irr.gui.IGUITreeViewNode*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Void*,irr.IReferenceCounted*)">
The other node has also to be a child node from this node.
		\param other Node to insert after
		\param text text of the new node
		\param icon icon text of the new node
		\param imageIndex index of the image for the new node (-1 = none)
		\param selectedImageIndex index of the selected image for the new node (-1 = same as imageIndex)
		\param data user data (void*) of the new node
		\param data2 user data2 (IReferenceCounted*) of the new node
		\return The new node or 0 if other is no child node from this

</member>
        <member name="M:irr.gui.IGUITreeViewNode.addChildFront(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Void*,irr.IReferenceCounted*)">
\param text text of the new node
		\param icon icon text of the new node
		\param imageIndex index of the image for the new node (-1 = none)
		\param selectedImageIndex index of the selected image for the new node (-1 = same as imageIndex)
		\param data user data (void*) of the new node
		\param data2 user data2 (IReferenceCounted*) of the new node
		\return The new node

</member>
        <member name="M:irr.gui.IGUITreeViewNode.addChildBack(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Void*,irr.IReferenceCounted*)">
\param text text of the new node
		\param icon icon text of the new node
		\param imageIndex index of the image for the new node (-1 = none)
		\param selectedImageIndex index of the selected image for the new node (-1 = same as imageIndex)
		\param data user data (void*) of the new node
		\param data2 user data2 (IReferenceCounted*) of the new node
		\return The new node

</member>
        <member name="M:irr.gui.IGUITreeViewNode.hasChilds">
\deprecated Deprecated in 1.8, use hasChildren() instead.
		This method may be removed by Irrlicht 1.9 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.clearChilds">
\deprecated Deprecated in 1.8, use clearChildren() instead.
		This method may be removed by Irrlicht 1.9 
</member>
        <member name="M:irr.gui.IGUITreeViewNode.getParent">
For the root node this will return 0. 
</member>
        <member name="T:irr.gui.IGUITreeViewNode">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_TREEVIEW_NODE_EXPAND
	\li EGET_TREEVIEW_NODE_COLLAPS
	\li EGET_TREEVIEW_NODE_DESELECT
	\li EGET_TREEVIEW_NODE_SELECT

</member>
        <member name="M:irr.gui.IGUIWindow.getMaximizeButton">
You can hide the button by calling setVisible(false) on the result. 
</member>
        <member name="M:irr.gui.IGUIWindow.getMinimizeButton">
You can hide the button by calling setVisible(false) on the result. 
</member>
        <member name="M:irr.gui.IGUIWindow.getCloseButton">
You can hide the button by calling setVisible(false) on the result. 
</member>
        <member name="T:irr.gui.IGUIWindow">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_ELEMENT_CLOSED

</member>
        <member name="M:irr.gui.IGUITable.isDrawBackgroundEnabled">
\return true if background drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUITable.getActiveFont">
Currently this is the override font when one is set and the
		font of the active skin otherwise 
</member>
        <member name="M:irr.gui.IGUITable.getOverrideFont">
\return The override font (may be 0) 
</member>
        <member name="M:irr.gui.IGUITable.setOverrideFont(irr.gui.IGUIFont*)">
If this is set to zero, the button uses the font of the skin.
		\param font: New font to set. 
</member>
        <member name="M:irr.gui.IGUITable.orderRows(System.Int32,irr.gui.EGUI_ORDERING_MODE)">
You need to explicitly tell the table to re order the rows
		when a new row is added or the cells data is changed. This
		makes the system more flexible and doesn't make you pay the
		cost of ordering when adding a lot of rows.
		\param columnIndex: When set to -1 the active column is used.
		\param mode Ordering mode of the rows. 
</member>
        <member name="M:irr.gui.IGUITable.addRow(System.UInt32)">
\param rowIndex Zero based index of rows. The row will be
		inserted at this position, if a row already exist there, it
		will be placed after it. If the row is larger than the actual
		number of row by more than one, it won't be created.  Note that
		if you create a row that's not at the end, there might be
		performance issues.
		\return index of inserted row. 
</member>
        <member name="M:irr.gui.IGUITable.setColumnOrdering(System.UInt32,irr.gui.EGUI_COLUMN_ORDERING)">
\param columnIndex The index of the column header.
		\param mode: One of the modes defined in EGUI_COLUMN_ORDERING 
</member>
        <member name="M:irr.gui.IGUITable.setActiveColumn(System.Int32,System.Boolean)">
\param idx: The id of the column to make active or a negative number to make non active.
		\param doOrder: Do also the ordering which depending on mode for active column
		\return True when the column could be set active (aka - it did exist). 
</member>
        <member name="M:irr.gui.IGUITable.addColumn(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
If columnIndex is outside the current range, do push new column at the end 
</member>
        <member name="T:irr.gui.IGUITable">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_TABLE_CHANGED
	\li EGET_TABLE_SELECTED_AGAIN
	\li EGET_TABLE_HEADER_CHANGED

</member>
        <member name="M:irr.gui.IGUITabControl.getTabExtraWidth">
return Returns the extra width of the tabs 
</member>
        <member name="M:irr.gui.IGUITabControl.getTabVerticalAlignment">
return Returns the alignment of the tabs 
</member>
        <member name="M:irr.gui.IGUITabControl.setTabVerticalAlignment(irr.gui.EGUI_ALIGNMENT)">
Use EGUIA_UPPERLEFT or EGUIA_LOWERRIGHT 
</member>
        <member name="M:irr.gui.IGUITabControl.getTabHeight">
return Returns the height of the tabs 
</member>
        <member name="M:irr.gui.IGUITabControl.getTabAt(System.Int32,System.Int32)">
\return The id of the tab or -1 when no tab is at those coordinates
</member>
        <member name="M:irr.gui.IGUITabControl.setActiveTab(irr.gui.IGUITab*)">
\param tab: pointer to the tab.
		\return Returns true if successful. 
</member>
        <member name="M:irr.gui.IGUITabControl.setActiveTab(System.Int32)">
\param idx: number of the tab.
		\return Returns true if successful. 
</member>
        <member name="M:irr.gui.IGUITabControl.getTab(System.Int32)">
\param idx: zero based index of tab. Is a value between 0 and getTabcount()-1;
		\return Returns pointer to the Tab. Returns 0 if no tab
		is corresponding to this tab. 
</member>
        <member name="M:irr.gui.IGUITabControl.insertTab(System.Int32,System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
\return The tab on success or NULL on failure. 
</member>
        <member name="T:irr.gui.IGUITabControl">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_TAB_CHANGED

</member>
        <member name="M:irr.gui.IGUITab.getNumber">
Can be accessed later IGUITabControl::getTab() by this number.
			Note that this number can change when other tabs are inserted or removed .

</member>
        <member name="T:irr.gui.IGUITab">
IGUITab refers mostly to the page itself, but also carries some data about the tab in the tabbar of an IGUITabControl. 
</member>
        <member name="M:irr.gui.IGUIStaticText.setRightToLeft(System.Boolean)">
\note This component does not implement the Unicode bidi standard, the
		text of the component should be already RTL if you call this. The
		main difference when RTL is enabled is that the linebreaks for multiline
		elements are performed starting from the end.

</member>
        <member name="M:irr.gui.IGUIStaticText.getTextWidth">
If the text is broken, this returns the width of the widest line
		\return The width of the text, or the widest broken line. 
</member>
        <member name="M:irr.gui.IGUIStaticText.getTextHeight">
This is useful for adjusting the layout of gui elements based on the height
		of the multiline text in this element.
		\return Height of text in pixels. 
</member>
        <member name="M:irr.gui.IGUIStaticText.isWordWrapEnabled">
\return true if word wrap is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIStaticText.setWordWrap(System.Boolean)">
\param enable: If set to true, words going over one line are
		broken on to the next line. 
</member>
        <member name="M:irr.gui.IGUIStaticText.setTextAlignment(irr.gui.EGUI_ALIGNMENT,irr.gui.EGUI_ALIGNMENT)">
\param horizontal: EGUIA_UPPERLEFT for left justified (default),
		EGUIA_LOWEERRIGHT for right justified, or EGUIA_CENTER for centered text.
		\param vertical: EGUIA_UPPERLEFT to align with top edge,
		EGUIA_LOWEERRIGHT for bottom edge, or EGUIA_CENTER for centered text (default). 
</member>
        <member name="M:irr.gui.IGUIStaticText.isDrawBorderEnabled">
\return true if border drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIStaticText.getBackgroundColor">
\return: The background color 
</member>
        <member name="M:irr.gui.IGUIStaticText.isDrawBackgroundEnabled">
\return true if background drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIStaticText.isOverrideColorEnabled">
\return true if the override color is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIStaticText.enableOverrideColor(System.Boolean)">
\param enable: If set to true, the override color, which can be set
		with IGUIStaticText::setOverrideColor is used, otherwise the
		EGDC_BUTTON_TEXT color of the skin. 
</member>
        <member name="M:irr.gui.IGUIStaticText.getOverrideColor">
\return: The override color 
</member>
        <member name="M:irr.gui.IGUIStaticText.setOverrideColor(irr.video.SColor)">
If set, the static text does not use the EGDC_BUTTON_TEXT color defined
		in the skin, but the set color instead. You don't need to call
		IGUIStaticText::enableOverrrideColor(true) after this, this is done
		by this function.
		If you set a color, and you want the text displayed with the color
		of the skin again, call IGUIStaticText::enableOverrideColor(false);
		\param color: New color of the text. 
</member>
        <member name="M:irr.gui.IGUIStaticText.getActiveFont">
Currently this is the override font when one is set and the
		font of the active skin otherwise 
</member>
        <member name="M:irr.gui.IGUIStaticText.getOverrideFont">
\return The override font (may be 0) 
</member>
        <member name="M:irr.gui.IGUIStaticText.setOverrideFont(irr.gui.IGUIFont*)">
If this is set to zero, the button uses the font of the skin.
		\param font: New font to set. 
</member>
        <member name="M:irr.gui.IGUISpriteBank.draw2DSprite(System.UInt32,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.UInt32,System.Boolean)">
\param index Index of SGUISprite to draw
\param destRect The sprite will be scaled to fit this target rectangle
\param clip Clipping rectangle, can be 0 when clipping is not wanted.
\param colors Array of 4 colors denoting the color values of
the corners of the destRect
\param timeTicks Current frame for animated sprites
(same as currenttime-starttime in other draw2DSprite function)
\param loop When true animations are looped

</member>
        <member name="M:irr.gui.IGUISpriteBank.draw2DSprite(System.UInt32,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,System.Boolean)">
\param index Index of SGUISprite to draw
\param pos Target position - depending on center value either the left-top or the sprite center is used as pivot
\param clip Clipping rectangle, can be 0 when clipping is not wanted.
\param color Color with which the image is drawn.
	Note that the alpha component is used. If alpha is other than
	255, the image will be transparent.
\param starttime Tick when the first frame was drawn (only difference currenttime-starttime matters).
\param currenttime To calculate the frame of animated sprites
\param loop When true animations are looped
\param center When true pivot is set to the sprite-center. So it affects pos.

</member>
        <member name="M:irr.gui.IGUISpriteBank.addTextureAsSprite(irr.video.ITexture*)">
The texture and the corresponding rectangle and sprite will all be added to the end of each array.
	 \returns The index of the sprite or -1 on failure 
</member>
        <member name="M:irr.gui.IGUISpinBox.getValidateOn">
\return A combination of EGUI_SPINBOX_VALIDATION bit flags 
</member>
        <member name="M:irr.gui.IGUISpinBox.setValidateOn(System.UInt32)">
\param validateOn Can be any combination of EGUI_SPINBOX_VALIDATION bit flags 
</member>
        <member name="M:irr.gui.IGUISpinBox.setDecimalPlaces(System.Int32)">
\param places: The number of decimal places to display, use -1 to reset 
</member>
        <member name="M:irr.gui.IGUISpinBox.setStepSize(System.Single)">
The step size also determines the number of decimal places to display
		\param step: stepsize used for value changes when pressing spinbuttons 
</member>
        <member name="M:irr.gui.IGUISpinBox.setRange(System.Single,System.Single)">
\param min: minimum value
		\param max: maximum value 
</member>
        <member name="M:irr.gui.IGUISpinBox.setValue(System.Single)">
\param val: value to be set in the spinbox 
</member>
        <member name="T:irr.gui.IGUISpinBox">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_SPINBOX_CHANGED

</member>
        <member name="M:irr.gui.IGUIScrollBar.setLargeStep(System.Int32)">
That is the amount that the value changes by when clicking
		in the tray, or using the page up and page down keys. 
</member>
        <member name="M:irr.gui.IGUIScrollBar.setSmallStep(System.Int32)">
That is the amount that the value changes by when clicking
		on the buttons or using the cursor keys. 
</member>
        <member name="T:irr.gui.IGUIScrollBar">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_SCROLL_BAR_CHANGED

</member>
        <member name="M:irr.gui.IGUIListBox.insertItem(System.UInt32,System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
\return The index on success or -1 on failure. 
</member>
        <member name="M:irr.gui.IGUIListBox.setSpriteBank(irr.gui.IGUISpriteBank*)">
This font is set to the sprite bank of the built-in-font by
		default. A sprite can be displayed in front of every list item.
		An icon is an index within the icon sprite bank. Several
		default icons are available in the skin through getIcon. 
</member>
        <member name="M:irr.gui.IGUIListBox.getItemAt(System.Int32,System.Int32)">
\return The id of the list item or -1 when no item is at those coordinates
</member>
        <member name="M:irr.gui.IGUIListBox.addItem(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
\param text Text of list entry
		\param icon Sprite index of the Icon within the current sprite bank. Set it to -1 if you want no icon
		\return The id of the new created item 
</member>
        <member name="T:irr.gui.IGUIListBox">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_LISTBOX_CHANGED
	\li EGET_LISTBOX_SELECTED_AGAIN

</member>
        <member name="M:irr.gui.IGUIInOutFader.fadeOut(System.UInt32)">
In the beginning everything is visible, and at the end of
		the time only the set color (black by the fault) will be drawn.
		\param time: Time specifying how long it should need to fade out,
		in milliseconds. 
</member>
        <member name="M:irr.gui.IGUIInOutFader.fadeIn(System.UInt32)">
In the beginning the whole rect is drawn by the set color
		(black by default) and at the end of the overgiven time the
		color has faded out.
		\param time: Time specifying how long it should need to fade in,
		in milliseconds. 
</member>
        <member name="M:irr.gui.IGUIInOutFader.setColor(irr.video.SColor)">
\param color: Color to where it is faded out od from it is faded in. 
</member>
        <member name="T:irr.gui.IGUIInOutFader">
Here is a small example on how the class is used. In this example we fade
	in from a total red screen in the beginning. As you can see, the fader is not
	only useful for dramatic in and out fading, but also to show that the player
	is hit in a first person shooter game for example.
	\code
	gui::IGUIInOutFader* fader = device-&gt;getGUIEnvironment()-&gt;addInOutFader();
	fader-&gt;setColor(video::SColor(0,255,0,0));
	fader-&gt;fadeIn(4000);
	\endcode

</member>
        <member name="M:irr.gui.IGUIImage.isDrawBackgroundEnabled">
\return true if background drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIImage.setDrawBackground(System.Boolean)">
By default it's enabled 
</member>
        <member name="M:irr.gui.IGUIImage.setDrawBounds(irr.core.rect&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This allows for example to use the image as a progress bar.
			Base for area is the image, which means:
			-  The original clipping area when the texture is scaled or there is no texture.
			-  The source-rect for an unscaled texture (but still restricted afterward by the clipping area)
			Unlike normal clipping this does not affect the gui-children.
			\param drawBoundUVs: Coordinates between 0 and 1 where 0 are for left+top and 1 for right+bottom

</member>
        <member name="M:irr.gui.IGUIImage.getSourceRect">
By default an empty rectangle of width and height 0 is returned which means the full image is used. 
</member>
        <member name="M:irr.gui.IGUIImage.setSourceRect(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param sourceRect coordinates inside the image or an area with size 0 for using the full image (default). 
</member>
        <member name="M:irr.gui.IGUIImage.setColor(irr.video.SColor)">
\param color Color with which the image is drawn. If the color
		equals Color(255,255,255,255) it is ignored. 
</member>
        <member name="M:irr.gui.IGUIFontBitmap.getKerningWidth(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
the global kerning distance is returned.
	\param thisLetter: If this parameter is provided, the left side kerning for this letter is added
	to the global kerning value. For example, a space might only be one pixel wide, but it may
	be displayed as several pixels.
	\param previousLetter: If provided, kerning is calculated for both letters and added to the global
	kerning value. For example, EGFT_BITMAP will add the right kerning value of previousLetter to the
	left side kerning value of thisLetter, then add the global value.

</member>
        <member name="M:irr.gui.IGUIFont.setInvisibleCharacters(System.Char!System.Runtime.CompilerServices.IsConst*)">
For example " " would not draw any space which is usually blank in
	most fonts.
	\param s String of symbols which are not send down to the videodriver

</member>
        <member name="M:irr.gui.IGUIFont.getKerningWidth(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
the global kerning distance is returned.
	\param thisLetter: If this parameter is provided, the left side kerning
	for this letter is added to the global kerning value. For example, a
	space might only be one pixel wide, but it may be displayed as several
	pixels.
	\param previousLetter: If provided, kerning is calculated for both
	letters and added to the global kerning value. For example, in a font
	which supports kerning pairs a string such as 'Wo' may have the 'o'
	tucked neatly under the 'W'.

</member>
        <member name="M:irr.gui.IGUIFont.getCharacterFromPos(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
\param text: Text string.
	\param pixel_x: X pixel position of which the index of the character will be returned.
	\return Returns zero based index of the character in the text, and -1 if no no character
	is on this position. (=the text is too short). 
</member>
        <member name="M:irr.gui.IGUIFont.getDimension(System.Char!System.Runtime.CompilerServices.IsConst*)">
\return Returns width and height of the area covered by the text if
	it would be drawn. 
</member>
        <member name="M:irr.gui.IGUIFont.draw(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor,System.Boolean,System.Boolean,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
\param text: Text to draw
	\param position: Rectangle specifying position where to draw the text.
	\param color: Color of the text
	\param hcenter: Specifies if the text should be centered horizontally into the rectangle.
	\param vcenter: Specifies if the text should be centered vertically into the rectangle.
	\param clip: Optional pointer to a rectangle against which the text will be clipped.
	If the pointer is null, no clipping will be done. 
</member>
        <member name="F:EGFT_OS">
Currently not used. 
</member>
        <member name="F:EGFT_VECTOR">
These fonts reside in system memory and use no video memory
	until they are displayed. These are slower than bitmap fonts
	but can be easily scaled and rotated. 
</member>
        <member name="T:irr.gui.IGUIFileOpenDialog">
\warning When the user selects a folder this does change the current working directory

	\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_DIRECTORY_SELECTED
	\li EGET_FILE_SELECTED
	\li EGET_FILE_CHOOSE_DIALOG_CANCELLED

</member>
        <member name="M:irr.gui.IGUIElementFactory.getCreateableGUIElementTypeName(irr.gui.EGUI_ELEMENT_TYPE)">
\param type: Type of GUI element.
		\return Name of the type if this factory can create the type, otherwise 0. 
</member>
        <member name="M:irr.gui.IGUIElementFactory.getCreateableGUIElementTypeName(System.Int32)">
\param idx: Index of the type in this factory. Must be a value between 0 and
		getCreatableGUIElementTypeCount() 
</member>
        <member name="M:irr.gui.IGUIElementFactory.getCreateableGUIElementType(System.Int32)">
\param idx: Index of the element type in this factory. Must be a value between 0 and
		getCreatableGUIElementTypeCount() 
</member>
        <member name="M:irr.gui.IGUIElementFactory.addGUIElement(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.gui.IGUIElement*)">
\param typeName: Type name of the element to add.
		\param parent: Parent scene node of the new element, can be null to add it to the root.
		\return Pointer to the new element or null if not successful. 
</member>
        <member name="M:irr.gui.IGUIElementFactory.addGUIElement(irr.gui.EGUI_ELEMENT_TYPE,irr.gui.IGUIElement*)">
\param type: Type of the element to add.
		\param parent: Parent scene node of the new element, can be null to add to the root.
		\return Pointer to the new element or null if not successful. 
</member>
        <member name="T:irr.gui.IGUIElementFactory">
To be able to add custom elements to Irrlicht and to make it possible for the
	scene manager to save and load them, simply implement this interface and register it
	in your gui environment via IGUIEnvironment::registerGUIElementFactory.
	Note: When implementing your own element factory, don't call IGUIEnvironment::grab() to
	increase the reference counter of the environment. This is not necessary because the
	it will grab() the factory anyway, and otherwise cyclic references will be created.

</member>
        <member name="M:irr.gui.IGUIEditBox.setCursorChar(System.Char!System.Runtime.CompilerServices.IsConst)">
By default it's "_" 
</member>
        <member name="M:irr.gui.IGUIEditBox.setMax(System.UInt32)">
\param max: Maximum amount of characters. If 0, the character amount is
		infinity. 
</member>
        <member name="M:irr.gui.IGUIEditBox.getTextDimension">
\return The size in pixels of the text 
</member>
        <member name="M:irr.gui.IGUIEditBox.setPasswordBox(System.Boolean,System.Char)">
disable MultiLine, WordWrap and the ability to copy with ctrl+c or ctrl+x
		\param passwordBox: true to enable password, false to disable
		\param passwordChar: the character that is displayed instead of letters 
</member>
        <member name="M:irr.gui.IGUIEditBox.isAutoScrollEnabled">
\return true if automatic scrolling is enabled, false if not 
</member>
        <member name="M:irr.gui.IGUIEditBox.setAutoScroll(System.Boolean)">
\param enable: If set to true, the text will move around with the cursor position 
</member>
        <member name="M:irr.gui.IGUIEditBox.isMultiLineEnabled">
\return true if multi-line is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIEditBox.setMultiLine(System.Boolean)">
\param enable: If set to true, the EGET_EDITBOX_ENTER event will not be fired,
		instead a newline character will be inserted. 
</member>
        <member name="M:irr.gui.IGUIEditBox.isWordWrapEnabled">
\return true if word wrap is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIEditBox.setWordWrap(System.Boolean)">
\param enable: If set to true, words going over one line are
		broken to the next line. 
</member>
        <member name="M:irr.gui.IGUIEditBox.setTextAlignment(irr.gui.EGUI_ALIGNMENT,irr.gui.EGUI_ALIGNMENT)">
\param horizontal: EGUIA_UPPERLEFT for left justified (default),
		EGUIA_LOWERRIGHT for right justified, or EGUIA_CENTER for centered text.
		\param vertical: EGUIA_UPPERLEFT to align with top edge,
		EGUIA_LOWERRIGHT for bottom edge, or EGUIA_CENTER for centered text (default). 
</member>
        <member name="M:irr.gui.IGUIEditBox.isDrawBorderEnabled">
\return true if border drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIEditBox.setDrawBorder(System.Boolean)">
\param border: true if you want the border to be drawn, false if not 
</member>
        <member name="M:irr.gui.IGUIEditBox.isDrawBackgroundEnabled">
\return true if background drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIEditBox.isOverrideColorEnabled">
\return true if the override color is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIEditBox.enableOverrideColor(System.Boolean)">
\param enable: If set to true, the override color, which can be set
		with IGUIEditBox::setOverrideColor is used, otherwise the
		EGDC_BUTTON_TEXT color of the skin. 
</member>
        <member name="M:irr.gui.IGUIEditBox.setOverrideColor(irr.video.SColor)">
If set, the edit box does not use the EGDC_BUTTON_TEXT color defined
		in the skin, but the set color instead. You don't need to call
		IGUIEditBox::enableOverrrideColor(true) after this, this is done
		by this function.
		If you set a color, and you want the text displayed with the color
		of the skin again, call IGUIEditBox::enableOverrideColor(false);
		\param color: New color of the text. 
</member>
        <member name="M:irr.gui.IGUIEditBox.getActiveFont">
Currently this is the override font when one is set and the
		font of the active skin otherwise 
</member>
        <member name="M:irr.gui.IGUIEditBox.getOverrideFont">
\return The override font (may be 0) 
</member>
        <member name="M:irr.gui.IGUIEditBox.setOverrideFont(irr.gui.IGUIFont*)">
If this is set to zero, the button uses the font of the skin.
		\param font: New font to set. 
</member>
        <member name="T:irr.gui.IGUIEditBox">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_EDITBOX_ENTER
	\li EGET_EDITBOX_CHANGED
	\li EGET_EDITBOX_MARKING_CHANGED

</member>
        <member name="M:irr.gui.IGUIContextMenu.getSubMenu(System.UInt32)">
0 is returned if there is no submenu
		\param idx: Zero based index of the menu item
		\return Returns a pointer to the submenu of an item. 
</member>
        <member name="M:irr.gui.IGUIContextMenu.setItemCommandId(System.UInt32,System.Int32)">
\param idx: Zero based index of the menu item
		\param id: Command id of menu item, a simple id you may
		set to whatever you want. 
</member>
        <member name="M:irr.gui.IGUIContextMenu.getItemCommandId(System.UInt32)">
\param idx: Zero based index of the menu item 
</member>
        <member name="M:irr.gui.IGUIContextMenu.getSelectedItem">
\return Index of the selected item, -1 if none selected. 
</member>
        <member name="M:irr.gui.IGUIContextMenu.removeItem(System.UInt32)">
\param idx: Zero based index of the menu item 
</member>
        <member name="M:irr.gui.IGUIContextMenu.isItemChecked(System.UInt32)">
\param idx: Zero based index of the menu item 
</member>
        <member name="M:irr.gui.IGUIContextMenu.setItemChecked(System.UInt32,System.Boolean)">
\param idx: Zero based index of the menu item
		\param enabled: True if it is enabled, otherwise false. 
</member>
        <member name="M:irr.gui.IGUIContextMenu.setItemEnabled(System.UInt32,System.Boolean)">
\param idx: Zero based index of the menu item
		\param enabled: True if it is enabled, otherwise false. 
</member>
        <member name="M:irr.gui.IGUIContextMenu.isItemEnabled(System.UInt32)">
\param idx: Zero based index of the menu item 
</member>
        <member name="M:irr.gui.IGUIContextMenu.setItemText(System.UInt32,System.Char!System.Runtime.CompilerServices.IsConst*)">
\param idx: Zero based index of the menu item
		\param text: New text of the item. 
</member>
        <member name="M:irr.gui.IGUIContextMenu.getItemText(System.UInt32)">
\param idx: Zero based index of the menu item 
</member>
        <member name="M:irr.gui.IGUIContextMenu.findItemWithCommandId(System.Int32,System.UInt32)">
\param commandId: We are looking for the first item which has this commandID
\param idxStartSearch: Start searching from this index.
\return Returns the index of the item when found or otherwise -1. 
</member>
        <member name="M:irr.gui.IGUIContextMenu.insertItem(System.UInt32,System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
\param idx: Position to insert the new element,
		should be smaller than itemcount otherwise the item is added to the end.
		\param text: Text of menu item. Set this to 0 to create
		an separator instead of a real item, which is the same like
		calling addSeparator();
		\param commandId: Command id of menu item, a simple id you may
		set to whatever you want.
		\param enabled: Specifies if the menu item should be enabled.
		\param hasSubMenu: Set this to true if there should be a submenu
		at this item. You can access this submenu via getSubMenu().
		\param checked: Specifies if the menu item should be initially checked.
		\param autoChecking: Specifies if the item should be checked by clicking
		\return Returns the index of the new item 
</member>
        <member name="M:irr.gui.IGUIContextMenu.addItem(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
\param text: Text of menu item. Set this to 0 to create
		an separator instead of a real item, which is the same like
		calling addSeparator();
		\param commandId: Command id of menu item, a simple id you may
		set to whatever you want.
		\param enabled: Specifies if the menu item should be enabled.
		\param hasSubMenu: Set this to true if there should be a submenu
		at this item. You can access this submenu via getSubMenu().
		\param checked: Specifies if the menu item should be initially checked.
		\param autoChecking: Specifies if the item should be checked by clicking
		\return Returns the index of the new item 
</member>
        <member name="T:irr.gui.IGUIContextMenu">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_ELEMENT_CLOSED
	\li EGET_MENU_ITEM_SELECTED

</member>
        <member name="M:irr.gui.IGUIComboBox.setTextAlignment(irr.gui.EGUI_ALIGNMENT,irr.gui.EGUI_ALIGNMENT)">
\param horizontal: EGUIA_UPPERLEFT for left justified (default),
		EGUIA_LOWEERRIGHT for right justified, or EGUIA_CENTER for centered text.
		\param vertical: EGUIA_UPPERLEFT to align with top edge,
		EGUIA_LOWEERRIGHT for bottom edge, or EGUIA_CENTER for centered text (default). 
</member>
        <member name="M:irr.gui.IGUIComboBox.removeItem(System.UInt32)">
Warning. This will change the index of all following items 
</member>
        <member name="T:irr.gui.IGUIComboBox">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_COMBO_BOX_CHANGED

</member>
        <member name="M:irr.gui.IGUICheckBox.isDrawBorderEnabled">
\return true if border drawing is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUICheckBox.isDrawBackgroundEnabled">
\return true if background drawing is enabled, false otherwise 
</member>
        <member name="T:irr.gui.IGUICheckBox">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_CHECKBOX_CHANGED

</member>
        <member name="M:irr.gui.IGUIButton.getClickControlState">
Generated together with event, so info is available in the event-receiver.	
</member>
        <member name="M:irr.gui.IGUIButton.getClickShiftState">
Generated together with event, so info is available in the event-receiver.	
</member>
        <member name="M:irr.gui.IGUIButton.setIsPushButton(System.Boolean)">
Which means it can be in two states: Normal or Pressed. With a click on the button,
		the user can change the state of the button. 
</member>
        <member name="M:irr.gui.IGUIButton.setSprite(irr.gui.EGUI_BUTTON_STATE,System.Int32,irr.video.SColor,System.Boolean,System.Boolean)">
Several sprites can be drawn at the same time.
		Sprites can be animated.
		Sprites are drawn above the images.
		\param index: Number of the sprite within the sprite bank, use -1 for no sprite
		\param state: State of the button to set the sprite for
		\param index: The sprite number from the current sprite bank
		\param color: The color of the sprite
		\param loop: True if the animation should loop, false if not
		\param scale: True if the sprite should scale to button size, false if not	
</member>
        <member name="M:irr.gui.IGUIButton.setSpriteBank(irr.gui.IGUISpriteBank*)">
NOTE: The spritebank itself is _not_ serialized so far. The sprites are serialized.
		Which means after loading the gui you still have to set the spritebank manually. 
</member>
        <member name="M:irr.gui.IGUIButton.setPressedImage(irr.video.ITexture*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is identical to calling setImage(EGBIS_IMAGE_DOWN, image, sourceRect); and might be deprecated in future revisions.
		\param image: Texture containing the image to be displayed
		\param sourceRect: Position in the texture, where the image is located 
</member>
        <member name="M:irr.gui.IGUIButton.setPressedImage(irr.video.ITexture*)">
This is identical to calling setImage(EGBIS_IMAGE_DOWN, image); and might be deprecated in future revisions.
		If no images is specified for the pressed state via
		setPressedImage(), this image is also drawn in pressed state.
		\param image: Image to be displayed 
</member>
        <member name="M:irr.gui.IGUIButton.setImage(irr.video.ITexture*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is identical to calling setImage(EGBIS_IMAGE_UP, image, sourceRect); and might be deprecated in future revisions.
		\param image: Texture containing the image to be displayed
		\param sourceRect: Position in the texture, where the image is located.
		When width or height are 0 then the full texture-size is used 
</member>
        <member name="M:irr.gui.IGUIButton.setImage(irr.video.ITexture*)">
This is identical to calling setImage(EGBIS_IMAGE_UP, image); and might be deprecated in future revisions.
		\param image: Image to be displayed 
</member>
        <member name="M:irr.gui.IGUIButton.setImage(irr.gui.EGUI_BUTTON_IMAGE_STATE,irr.video.ITexture*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Only one image-state can be active at a time. Images are drawn below sprites.
		If a state is without image it will try to use images from other states as described
		in ::EGUI_BUTTON_IMAGE_STATE.
		Images are a little less flexible than sprites, but easier to use.
		\param state: One of ::EGUI_BUTTON_IMAGE_STATE
		\param image: Image to be displayed or NULL to remove the image
		\param sourceRect: Source rectangle on the image texture. When width or height are 0 then the full texture-size is used (default). 
</member>
        <member name="M:irr.gui.IGUIButton.isOverrideColorEnabled">
\return true if the override color is enabled, false otherwise 
</member>
        <member name="M:irr.gui.IGUIButton.enableOverrideColor(System.Boolean)">
\param enable: If set to true, the override color, which can be set
		with IGUIStaticText::setOverrideColor is used, otherwise the
		EGDC_BUTTON_TEXT or EGDC_GRAY_TEXT color of the skin. 
</member>
        <member name="M:irr.gui.IGUIButton.getOverrideColor">
\return: The override color 
</member>
        <member name="M:irr.gui.IGUIButton.setOverrideColor(irr.video.SColor)">
When set, this color is used instead of EGDC_BUTTON_TEXT/EGDC_GRAY_TEXT.
		You don't need to call enableOverrideColor(true), that's done by this function.
		If you want the the color of the skin back, call enableOverrideColor(false);
		\param color: New color of the text. 
</member>
        <member name="M:irr.gui.IGUIButton.getActiveFont">
Currently this is the override font when one is set and the
		font of the active skin otherwise 
</member>
        <member name="M:irr.gui.IGUIButton.getOverrideFont">
\return The override font (may be 0) 
</member>
        <member name="M:irr.gui.IGUIButton.setOverrideFont(irr.gui.IGUIFont*)">
If this is set to zero, the button uses the font of the skin.
		\param font: New font to set. 
</member>
        <member name="T:irr.gui.IGUIButton">
\par This element can create the following events of type EGUI_EVENT_TYPE:
	\li EGET_BUTTON_CLICKED

</member>
        <member name="M:irr.gui.IGUIElement.deserializeAttributes(irr.io.IAttributes*,irr.io.SAttributeReadWriteOptions*)">
Implement this to set the attributes of your scene node for
	scripting languages, editors, debuggers or xml deserialization purposes. 
</member>
        <member name="M:irr.gui.IGUIElement.serializeAttributes(irr.io.IAttributes*,irr.io.SAttributeReadWriteOptions*)">
Implement this to expose the attributes of your scene node for
	scripting languages, editors, debuggers or xml serialization purposes. 
</member>
        <member name="M:irr.gui.IGUIElement.setName(irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param name New name of the gui element. 
</member>
        <member name="M:irr.gui.IGUIElement.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
\param name New name of the gui element. 
</member>
        <member name="M:irr.gui.IGUIElement.getName">
\return Name as character string. 
</member>
        <member name="M:irr.gui.IGUIElement.getTypeName">
This is needed serializing elements. For serializing your own elements, override this function
	and return your own type name which is created by your IGUIElementFactory 
</member>
        <member name="M:irr.gui.IGUIElement.hasType(irr.gui.EGUI_ELEMENT_TYPE)">
This is mostly used to check if you can cast a gui element to the class that goes with the type.
	Most gui elements will only support their own type, but if you derive your own classes from interfaces
	you can overload this function and add a check for the type of the base-class additionally.
	This allows for checks comparable to the dynamic_cast of c++ with enabled rtti.
	Note that you can't do that by calling BaseClass::hasType(type), but you have to do an explicit
	comparison check, because otherwise the base class usually just checks for the member variable
	Type which contains the type of your derived class.

</member>
        <member name="M:irr.gui.IGUIElement.getType">
This is needed for the .NET wrapper but will be used
	later for serializing and deserializing.
	If you wrote your own GUIElements, you need to set the type for your element as first parameter
	in the constructor of IGUIElement. For own (=unknown) elements, simply use EGUIET_ELEMENT as type 
</member>
        <member name="M:irr.gui.IGUIElement.getNextElement(System.Int32,System.Boolean,System.Boolean,irr.gui.IGUIElement**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
\param startOrder: The TabOrder of the current element, -1 if none
	\param reverse: true if searching for a lower number
	\param group: true if searching for a higher one
	\param first: element with the highest/lowest known tab order depending on search direction
	\param closest: the closest match, depending on tab order and direction
	\param includeInvisible: includes invisible elements in the search (default=false)
	\param includeDisabled: includes disabled elements in the search (default=false)
	\return true if successfully found an element, false to continue searching/fail 
</member>
        <member name="M:irr.gui.IGUIElement.getElementFromId(System.Int32,System.Boolean)">
\param id: Id to search for.
	\param searchchildren: Set this to true, if also children of this
	element may contain the element with the searched id and they
	should be searched too.
	\return Returns the first element with the given id. If no element
	with this id was found, 0 is returned. 
</member>
        <member name="M:irr.gui.IGUIElement.sendToBack(irr.gui.IGUIElement*)">
\return True if successful, false if not. 
</member>
        <member name="M:irr.gui.IGUIElement.bringToFront(irr.gui.IGUIElement*)">
\return True if successful, false if not. 
</member>
        <member name="M:irr.gui.IGUIElement.isEnabled">
Currently elements do _not_ care about parent-states.
		So if you want to affect children you have to enable/disable them all.
		The only exception to this are sub-elements which also check their parent.

</member>
        <member name="M:irr.gui.IGUIElement.setTabGroup(System.Boolean)">
For example, windows are tab groups.
	Groups can be navigated using ctrl+tab, providing isTabStop is true. 
</member>
        <member name="M:irr.gui.IGUIElement.setTabOrder(System.Int32)">
See setTabGroup, isTabGroup and getTabGroup for information on tab groups.
	Elements with a lower number are focused first 
</member>
        <member name="M:irr.gui.IGUIElement.setTabStop(System.Boolean)">
If this element is a tab group (see isTabGroup/setTabGroup) then
	ctrl+tab will be used instead. 
</member>
        <member name="M:irr.gui.IGUIElement.setSubElement(System.Boolean)">
For example, it is true when a scrollbar is part of a listbox.
	SubElements are not saved to disk when calling guiEnvironment-&gt;saveGUI() 
</member>
        <member name="M:irr.gui.IGUIElement.isTrulyVisible">
\return true if the element and all its parents are visible,
	false if this or any parent element is invisible. 
</member>
        <member name="M:irr.gui.IGUIElement.isPointInside(irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Elements with a shape other than a rectangle should override this method 
</member>
        <member name="M:irr.gui.IGUIElement.getElementFromPoint(irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This will check this GUI element and all of its descendants, so it
may return this GUI element.  To check all GUI elements, call this
function on device-&gt;getGUIEnvironment()-&gt;getRootGUIElement(). Note
that the root element is the size of the screen, so doing so (with
an on-screen point) will always return the root element if no other
element is above it at that point.
\param point: The point at which to find a GUI element.
\return The topmost GUI element at that point, or 0 if there are
no candidate elements at this point.

</member>
        <member name="M:irr.gui.IGUIElement.setMaxSize(irr.core.dimension2d&lt;System.UInt32&gt;)">
If set to 0,0, there is no maximum size 
</member>
        <member name="M:irr.gui.IGUIElement.isNotClipped">
\return true if the element is not clipped by its parent's clipping rectangle. 
</member>
        <member name="M:irr.gui.IGUIElement.setNotClipped(System.Boolean)">
\param noClip If true, the element will not be clipped by its parent's clipping rectangle. 
</member>
        <member name="M:irr.gui.IGUIElement.setRelativePosition(irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param position The new relative position to set. Width and height will not be changed. 
</member>
        <member name="M:irr.gui.IGUIElement.setRelativePosition(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param r The absolute position to set 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getFocusBehavior">
\returns A bitmask which is a combination of ::EFOCUS_FLAG flags.
</member>
        <member name="M:irr.gui.IGUIEnvironment.setFocusBehavior(System.UInt32)">
The default is (EFF_SET_ON_LMOUSE_DOWN | EFF_SET_ON_TAB).
	with the left mouse button.
	This does not affect the setFocus function itself - users can still call that whenever they want on any element.
	\param flags A bitmask which is a combination of ::EFOCUS_FLAG flags.
</member>
        <member name="M:irr.gui.IGUIEnvironment.getNextElement(System.Boolean,System.Boolean)">
If you set the focus for the result you can manually force focus-changes like they
	would happen otherwise by the tab-keys.
	\param reverse When true it will search backward (toward lower TabOrder numbers, like shift+tab)
	\param group When true it will search for the next tab-group (like ctrl+tab)

</member>
        <member name="M:irr.gui.IGUIEnvironment.loadGUI(irr.io.IReadFile*,irr.gui.IGUIElement*)">
When a parent is set the elements will be added below the parent, the parent itself does not deserialize.
	When the file contains skin-settings from the gui-environment those are always serialized into the
	guienvironment independent of the parent setting.
	\param file The file to load from.
	\param parent Parent for the loaded GUI, root if 0.
	\return True if loading succeeded, else false. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.loadGUI(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*)">
When a parent is set the elements will be added below the parent, the parent itself does not deserialize.
	When the file contains skin-settings from the gui-environment those are always serialized into the
	guienvironment independent of the parent setting.
	\param filename Name of the file.
	\param parent Parent for the loaded GUI, root if 0.
	\return True if loading succeeded, else false. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.saveGUI(irr.io.IWriteFile*,irr.gui.IGUIElement*)">
\param file The file to write to.
	\param start The GUIElement to start with. Root if 0.
	\return True if saving succeeded, else false. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.saveGUI(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*)">
\param filename Name of the file.
	\param start The GUIElement to start with. Root if 0.
	\return True if saving succeeded, else false. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addGUIElement(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.gui.IGUIElement*)">
Each factory is checked if it can create an element of the given
	name. The first match will be created.
	\param elementName Name of the element to be created.
	\param parent Parent of the new element, if not 0.
	\return New GUI element, or 0 if no such element exists. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getGUIElementFactory(System.UInt32)">
\param index Index of the factory.
	\return Factory at given index, or 0 if no such factory exists. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getRegisteredGUIElementFactoryCount">
\return Amount of registered gui element factories. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.registerGUIElementFactory(irr.gui.IGUIElementFactory*)">
Use this to extend the gui environment with new element types which
	it should be able to create automatically, for example when loading
	data from xml files.
	\param factoryToAdd Pointer to new factory. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getDefaultGUIElementFactory">
\return Pointer to the factory.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addProfilerDisplay(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32)">
\param rectangle Rectangle specifying the borders of the element.
	\param parent Parent of the element. When 0 the environment itself will
	be the parent.
	\param id An identifier for the element. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addTable(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32,System.Boolean)">
\param rectangle Rectangle specifying the borders of the table.
	\param parent Parent item of the element, e.g. a window. Set it to 0
	to place the element directly in the environment.
	\param id An identifier for the table.
	\param drawBackground Flag whether the background should be drawn.
	\return Pointer to the created table. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addComboBox(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32)">
\param rectangle Rectangle specifying the borders of the combo box.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the combo box directly in the environment.
	\param id An identifier for the combo box.
	\return Pointer to the created combo box. Returns 0 if an
	error occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addToolBar(irr.gui.IGUIElement*,System.Int32)">
It is like a menu that is always placed on top of its parent, and
	contains buttons.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the tool bar directly in the environment.
	\param id An identifier for the tool bar.
	\return Pointer to the created tool bar. Returns 0 if an
	error occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addMenu(irr.gui.IGUIElement*,System.Int32)">
This is like the menu you can find on top of most windows in modern
	graphical user interfaces.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the menu directly in the environment.
	\param id An identifier for the menu.
	\return Pointer to the created menu. Returns 0 if an
	error occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addContextMenu(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32)">
\param rectangle Rectangle specifying the borders of the menu.
	Note that the menu is resizing itself based on what items you add.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the menu directly in the environment.
	\param id An identifier for the menu.
	\return Pointer to the created context menu. Returns 0 if an
	error occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addTab(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32)">
You can use this element to group other elements. This is not used
	for creating tabs on tab controls, please use IGUITabControl::addTab()
	for this instead.
	\param rectangle Rectangle specifying the borders of the tab.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the tab directly in the environment.
	\param id An identifier for the tab.
	\return Pointer to the created tab. Returns 0 if an
	error occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addTabControl(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Boolean,System.Boolean,System.Int32)">
\param rectangle Rectangle specifying the borders of the tab control.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the tab control directly in the environment.
	\param fillbackground Specifies if the background of the tab control
	should be drawn.
	\param border Specifies if a flat 3d border should be drawn. This is
	usually not necessary unless you place the control directly into
	the environment without a window as parent.
	\param id An identifier for the tab control.
	\return Pointer to the created tab control element. Returns 0 if an
	error occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addInOutFader(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.gui.IGUIElement*,System.Int32)">
\param rectangle Rectangle specifying the borders of the fader.
	If the pointer is NULL, the whole screen is used.
	\param parent Parent item of the element, e.g. a window.
	\param id An identifier for the fader.
	\return Pointer to the created in-out-fader. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addSpinBox(System.Char!System.Runtime.CompilerServices.IsConst*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,irr.gui.IGUIElement*,System.Int32)">
An edit box with up and down buttons
	\param text Text to be displayed. Can be altered after creation by setText().
	\param rectangle Rectangle specifying the borders of the spin box.
	\param border Set to true if the spin box should have a 3d border.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the spin box directly in the environment.
	\param id The ID of the element.
	\return Pointer to the created spin box. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addEditBox(System.Char!System.Runtime.CompilerServices.IsConst*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,irr.gui.IGUIElement*,System.Int32)">
Supports Unicode input from every keyboard around the world,
	scrolling, copying and pasting (exchanging data with the clipboard
	directly), maximum character amount, marking, and all shortcuts like
	ctrl+X, ctrl+V, ctrl+C, shift+Left, shift+Right, Home, End, and so on.
	\param text Text to be displayed. Can be altered after creation
	by setText().
	\param rectangle Rectangle specifying the borders of the edit box.
	\param border Set to true if the edit box should have a 3d border.
	\param parent Parent item of the element, e.g. a window.
	Set it to 0 to place the edit box directly in the environment.
	\param id The ID of the element.
	\return Pointer to the created edit box. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addStaticText(System.Char!System.Runtime.CompilerServices.IsConst*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,irr.gui.IGUIElement*,System.Int32,System.Boolean)">
\param text Text to be displayed. Can be altered after creation by SetText().
	\param rectangle Rectangle specifying the borders of the static text
	\param border Set to true if the static text should have a 3d border.
	\param wordWrap Enable if the text should wrap into multiple lines.
	\param parent Parent item of the element, e.g. a window.
	\param id The ID of the element.
	\param fillBackground Enable if the background shall be filled.
	Defaults to false.
	\return Pointer to the created static text. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addColorSelectDialog(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean,irr.gui.IGUIElement*,System.Int32)">
\param title The title of the dialog.
	\param modal Defines if the dialog is modal. This means, that all other
	gui elements which were created before the dialog cannot be used
	until it is removed.
	\param parent The parent of the dialog.
	\param id The ID of the dialog.
	\return Pointer to the created file open dialog. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addFileOpenDialog(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean,irr.gui.IGUIElement*,System.Int32,System.Boolean,System.Char*)">
\param title Text to be displayed as the title of the dialog.
	\param modal Defines if the dialog is modal. This means, that all other
	gui elements which were created before the message box cannot be used
	until this messagebox is removed.
	\param parent Parent gui element of the dialog.
	\param id Id to identify the gui element.
	\param restoreCWD If set to true, the current working directory will be
	restored after the dialog is closed in some way. Otherwise the working
	directory will be the one that the file dialog was last showing.
	\param startDir Optional path for which the file dialog will be opened.
	\return Pointer to the created file open dialog. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addMeshViewer(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32,System.Char!System.Runtime.CompilerServices.IsConst*)">
\param rectangle Rectangle specifying the borders of the mesh viewer.
	\param parent Parent gui element of the mesh viewer.
	\param id Id to identify the gui element.
	\param text Title text of the mesh viewer.
	\return Pointer to the created mesh viewer. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addTreeView(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
\param rectangle Position and dimension of list box.
	\param parent Parent gui element of the list box.
	\param id Id to identify the gui element.
	\param drawBackground Flag whether the background should be drawn.
	\param scrollBarVertical Flag whether a vertical scrollbar should be used
	\param scrollBarHorizontal Flag whether a horizontal scrollbar should be used
	\return Pointer to the created list box. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addListBox(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32,System.Boolean)">
\param rectangle Rectangle specifying the borders of the list box.
	\param parent Parent gui element of the list box.
	\param id Id to identify the gui element.
	\param drawBackground Flag whether the background should be drawn.
	\return Pointer to the created list box. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addCheckBox(System.Boolean,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32,System.Char!System.Runtime.CompilerServices.IsConst*)">
\param checked Define the initial state of the check box.
	\param rectangle Rectangle specifying the borders of the check box.
	\param parent Parent gui element of the check box.
	\param id Id to identify the gui element.
	\param text Title text of the check box.
	\return Pointer to the created check box. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addImage(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32,System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Use IGUIImage::setImage later to set the image to be displayed.
	\param rectangle Rectangle specifying the borders of the image.
	\param parent Parent gui element of the image.
	\param id Id to identify the gui element.
	\param text Title text of the image (not displayed).
	\param useAlphaChannel Sets if the image should use the alpha channel
	of the texture to draw itself.
	\return Pointer to the created image element. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addImage(irr.video.ITexture*,irr.core.vector2d&lt;System.Int32&gt;,System.Boolean,irr.gui.IGUIElement*,System.Int32,System.Char!System.Runtime.CompilerServices.IsConst*)">
\param image Image to be displayed.
	\param pos Position of the image. The width and height of the image is
	taken from the image.
	\param useAlphaChannel Sets if the image should use the alpha channel
	of the texture to draw itself.
	\param parent Parent gui element of the image.
	\param id Id to identify the gui element.
	\param text Title text of the image (not displayed).
	\return Pointer to the created image element. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addScrollBar(System.Boolean,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32)">
\param horizontal Specifies if the scroll bar is drawn horizontal
	or vertical.
	\param rectangle Rectangle specifying the borders of the scrollbar.
	\param parent Parent gui element of the scroll bar.
	\param id Id to identify the gui element.
	\return Pointer to the created scrollbar. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addMessageBox(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Int32,irr.gui.IGUIElement*,System.Int32,irr.video.ITexture*)">
\param caption Text to be displayed the title of the message box.
	\param text Text to be displayed in the body of the message box.
	\param modal Defines if the dialog is modal. This means, that all other
	gui elements which were created before the message box cannot be used
	until this messagebox is removed.
	\param flags Flags specifying the layout of the message box using ::EMESSAGE_BOX_FLAG.
	Create a message box with an OK and CANCEL button for example with (EMBF_OK | EMBF_CANCEL).
	\param parent Parent gui element of the message box.
	\param id Id with which the gui element can be identified.
	\param image Optional texture which will be displayed beside the text as an image
	\return Pointer to the created message box. Returns 0 if an error
	occurred. This pointer should not be dropped. See
	IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addModalScreen(irr.gui.IGUIElement*)">
This control stops its parent's members from being able to receive
	input until its last child is removed, it then deletes itself.
	\param parent Parent gui element of the modal.
	\return Pointer to the created modal. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addWindow(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Char!System.Runtime.CompilerServices.IsConst*,irr.gui.IGUIElement*,System.Int32)">
\param rectangle Rectangle specifying the borders of the window.
	\param modal Defines if the dialog is modal. This means, that all other
	gui elements which were created before the window cannot be used until
	it is removed.
	\param text Text displayed as the window title.
	\param parent Parent gui element of the window.
	\param id Id with which the gui element can be identified.
	\return Pointer to the created window. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addButton(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIElement*,System.Int32,System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
\param rectangle Rectangle specifying the borders of the button.
	\param parent Parent gui element of the button.
	\param id Id with which the gui element can be identified.
	\param text Text displayed on the button.
	\param tooltiptext Text displayed in the tooltip.
	\return Pointer to the created button. Returns 0 if an error occurred.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getRootGUIElement">
This is the first gui element, the (direct or indirect) parent of all
	other gui elements. It is a valid IGUIElement, with dimensions the same
	size as the screen.
	\return Pointer to the root element of the GUI. The returned pointer
	should not be dropped. See IReferenceCounted::drop() for more
	information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addEmptySpriteBank(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param name Name of the new sprite bank.
	\return Pointer to the sprite bank.
	This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getSpriteBank(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
TODO: This should load files in the future, but not implemented so far.
	\param filename Name of a spritebank added with addEmptySpriteBank
	\return Pointer to the sprite bank. Returns 0 if it could not be loaded.
	This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getBuiltInFont">
\return Pointer to the default built-in font.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.addFont(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.gui.IGUIFont*)">
This method allows to attach an already loaded font to the list of
	existing fonts. The font is grabbed if non-null and adding was successful.
	\param name Name the font should be stored as.
	\param font Pointer to font to add.
	\return Pointer to the font stored. This can differ from given parameter if the name previously existed. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getFont(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Loads the font if it was not loaded before.
	\param filename Filename of the Font.
	\return Pointer to the font. Returns 0 if the font could not be loaded.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.createImageList(irr.video.ITexture*,irr.core.dimension2d&lt;System.Int32&gt;,System.Boolean)">
\param texture Texture to split into images
	\param imageSize Dimension of each image
	\param useAlphaChannel Flag whether alpha channel of the texture should be honored.
	\return Pointer to the font. Returns 0 if the font could not be loaded.
	This pointer should not be dropped. See IReferenceCounted::drop() for
	more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.createSkin(irr.gui.EGUI_SKIN_TYPE)">
Use setSkin() to set the created skin.
	\param type The type of the new skin.
	\return Pointer to the created skin.
	If you no longer need it, you should call IGUISkin::drop().
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.setSkin(irr.gui.IGUISkin*)">
You can use this to change the appearance of the whole GUI
	Environment. You can set one of the built-in skins or implement your
	own class derived from IGUISkin and enable it using this method.
	To set for example the built-in Windows classic skin, use the following
	code:
	\code
	gui::IGUISkin* newskin = environment-&gt;createSkin(gui::EGST_WINDOWS_CLASSIC);
	environment-&gt;setSkin(newskin);
	newskin-&gt;drop();
	\endcode
	\param skin New skin to use.

</member>
        <member name="M:irr.gui.IGUIEnvironment.getSkin">
\return Pointer to the GUI skin. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.setUserEventReceiver(irr.IEventReceiver*)">
Usually you do not have to
	use this method, it is used by the engine internally.
	\param evr Pointer to the new receiver. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.postEventFromUser(irr.SEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Usually you do not have to
	use this method, it is used by the engine internally.
	\param event The event to post.
	\return True if succeeded, else false. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getOSOperator">
\return Pointer to the OS operator. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getFileSystem">
\return Pointer to the file system. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getVideoDriver">
\return Pointer to the video driver. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.hasFocus(irr.gui.IGUIElement!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
\param element Pointer to the element which is tested.
	\param checkSubElements When true and focus is on a sub-element of element then it will still count as focused and return true
	\return True if the element has focus, else false. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.removeFocus(irr.gui.IGUIElement*)">
Causes a EGET_ELEMENT_FOCUS_LOST event. If the event is absorbed
	then the focus will not be changed.
	\param element Pointer to the element which shall lose the focus.
	\return True on success, false on failure 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getHovered">
NOTE: This information is updated _after_ the user-eventreceiver
	received it's mouse-events. To find the hovered element while catching
	mouse events you have to use instead:
	IGUIEnvironment::getRootGUIElement()-&gt;getElementFromPoint(mousePos);
	\return Pointer to the element under the mouse. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.getFocus">
\return Pointer to the element with focus. 
</member>
        <member name="M:irr.gui.IGUIEnvironment.setFocus(irr.gui.IGUIElement*)">
Causes a EGET_ELEMENT_FOCUS_LOST event followed by a
	EGET_ELEMENT_FOCUSED event. If someone absorbed either of the events,
	then the focus will not be changed.
	\param element Pointer to the element which shall get the focus.
	\return True on success, false on failure 
</member>
        <member name="T:irr.gui.IGUIEnvironment">
\par This element can create the following events of type EGUI_EVENT_TYPE (which are passed on to focused sub-elements):
\li EGET_ELEMENT_FOCUS_LOST
\li EGET_ELEMENT_FOCUSED
\li EGET_ELEMENT_LEFT
\li EGET_ELEMENT_HOVERED

</member>
        <member name="M:irr.gui.IGUISkin.draw2DRectangle(irr.gui.IGUIElement*,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
\param element: Pointer to the element which wishes to draw this icon.
		This parameter is usually not used by IGUISkin, but can be used for example
		by more complex implementations to find out how to draw the part exactly.
		\param color: Color of the rectangle to draw. The alpha component specifies how
		transparent the rectangle will be.
		\param pos: Position of the rectangle.
		\param clip: Pointer to rectangle against which the rectangle will be clipped.
		If the pointer is null, no clipping will be performed. 
</member>
        <member name="M:irr.gui.IGUISkin.drawIcon(irr.gui.IGUIElement*,irr.gui.EGUI_DEFAULT_ICON,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst,System.UInt32,System.UInt32,System.Boolean,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
\param element: Pointer to the element which wishes to draw this icon.
		This parameter is usually not used by IGUISkin, but can be used for example
		by more complex implementations to find out how to draw the part exactly.
		\param icon: Specifies the icon to be drawn.
		\param position: The position to draw the icon
		\param starttime: The time at the start of the animation
		\param currenttime: The present time, used to calculate the frame number
		\param loop: Whether the animation should loop or not
		\param clip: Clip area. 
</member>
        <member name="M:irr.gui.IGUISkin.draw3DTabBody(irr.gui.IGUIElement*,System.Boolean,System.Boolean,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,System.Int32,irr.gui.EGUI_ALIGNMENT)">
\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param border: Specifies if the border should be drawn.
		\param background: Specifies if the background should be drawn.
		\param rect: Defining area where to draw.
		\param clip: Clip area.
		\param tabHeight Height of tab.
		\param alignment Alignment of GUI element. 
</member>
        <member name="M:irr.gui.IGUISkin.draw3DTabButton(irr.gui.IGUIElement*,System.Boolean,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.gui.EGUI_ALIGNMENT)">
Used for drawing for tab buttons on top of tabs.
		\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param active: Specifies if the tab is currently active.
		\param rect: Defining area where to draw.
		\param clip: Clip area.
		\param alignment Alignment of GUI element. 
</member>
        <member name="M:irr.gui.IGUISkin.draw3DToolBar(irr.gui.IGUIElement*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
Used for drawing for toolbars and menus.
		\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param rect: Defining area where to draw.
		\param clip: Clip area. 
</member>
        <member name="M:irr.gui.IGUISkin.draw3DMenuPane(irr.gui.IGUIElement*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
Used for drawing for menus and context menus.
		It uses the colors EGDC_3D_DARK_SHADOW, EGDC_3D_HIGH_LIGHT, EGDC_3D_SHADOW and
		EGDC_3D_FACE for this. See EGUI_DEFAULT_COLOR for details.
		\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param rect: Defining area where to draw.
		\param clip: Clip area. 
</member>
        <member name="M:irr.gui.IGUISkin.draw3DWindowBackground(irr.gui.IGUIElement*,System.Boolean,irr.video.SColor,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.core.rect&lt;System.Int32&gt;*)">
Used for drawing the background of dialogs and windows.
		\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param titleBarColor: Title color.
		\param drawTitleBar: True to enable title drawing.
		\param rect: Defining area where to draw.
		\param clip: Clip area.
		\param checkClientArea: When set to non-null the function will not draw anything,
		but will instead return the clientArea which can be used for drawing by the calling window.
		That is the area without borders and without titlebar.
		\return Returns rect where it would be good to draw title bar text. This will
		work even when checkClientArea is set to a non-null value.
</member>
        <member name="M:irr.gui.IGUISkin.draw3DSunkenPane(irr.gui.IGUIElement*,irr.video.SColor,System.Boolean,System.Boolean,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
Used for drawing the background of edit, combo or check boxes.
		\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param bgcolor: Background color.
		\param flat: Specifies if the sunken pane should be flat or displayed as sunken
		deep into the ground.
		\param fillBackGround: Specifies if the background should be filled with the background
		color or not be drawn at all.
		\param rect: Defining area where to draw.
		\param clip: Clip area. 
</member>
        <member name="M:irr.gui.IGUISkin.draw3DButtonPanePressed(irr.gui.IGUIElement*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
Used for drawing for example buttons in pressed state.
		It uses the colors EGDC_3D_DARK_SHADOW, EGDC_3D_HIGH_LIGHT, EGDC_3D_SHADOW and
		EGDC_3D_FACE for this. See EGUI_DEFAULT_COLOR for details.
		\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param rect: Defining area where to draw.
		\param clip: Clip area. 
</member>
        <member name="M:irr.gui.IGUISkin.draw3DButtonPaneStandard(irr.gui.IGUIElement*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
Used for drawing for example buttons in normal state.
		It uses the colors EGDC_3D_DARK_SHADOW, EGDC_3D_HIGH_LIGHT, EGDC_3D_SHADOW and
		EGDC_3D_FACE for this. See EGUI_DEFAULT_COLOR for details.
		\param element: Pointer to the element which wishes to draw this. This parameter
		is usually not used by IGUISkin, but can be used for example by more complex
		implementations to find out how to draw the part exactly.
		\param rect: Defining area where to draw.
		\param clip: Clip area. 
</member>
        <member name="M:irr.gui.IGUISkin.setIcon(irr.gui.EGUI_DEFAULT_ICON,System.UInt32)">
Sets the sprite index used for drawing icons like arrows,
		close buttons and ticks in checkboxes
		\param icon: Enum specifying which icon to change
		\param index: The sprite index used to draw this icon 
</member>
        <member name="M:irr.gui.IGUISkin.getIcon(irr.gui.EGUI_DEFAULT_ICON)">
Returns the sprite index within the sprite bank 
</member>
        <member name="M:irr.gui.IGUISkin.setDefaultText(irr.gui.EGUI_DEFAULT_TEXT,System.Char!System.Runtime.CompilerServices.IsConst*)">
For example for Message box button captions:
		"OK", "Cancel", "Yes", "No" and so on. 
</member>
        <member name="M:irr.gui.IGUISkin.getDefaultText(irr.gui.EGUI_DEFAULT_TEXT)">
For example for Message box button captions:
		"OK", "Cancel", "Yes", "No" and so on. 
</member>
        <member name="T:irr.gui.EGUI_SKIN_TYPE">
To set one of the skins, use the following code, for example to set
	the Windows classic skin:
	\code
	gui::IGUISkin* newskin = environment-&gt;createSkin(gui::EGST_WINDOWS_CLASSIC);
	environment-&gt;setSkin(newskin);
	newskin-&gt;drop();
	\endcode

</member>
        <member name="M:irr.video.IGPUProgrammingServices.addShaderMaterialFromFiles(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32)">
\param vertexShaderProgramFileName Text file name containing the
	source of the vertex shader program. Set to 0 if no shader shall be
	created.
	\param pixelShaderProgramFileName Text file name containing the source
	of the pixel shader program. Set to 0 if no shader shall be created.
	\param callback Pointer to an IShaderConstantSetCallback object on
	which the OnSetConstants function is called.
	\param baseMaterial baseMaterial
	\param userData a user data int. This int can be set to any value and
	will be set as parameter in the callback method when calling
	OnSetConstants(). In this way it is easily possible to use the same
	callback method for multiple materials and distinguish between them
	during the call.
	\return Returns the number of the material type which can be set in
	SMaterial::MaterialType to use the renderer. -1 is returned if an
	error occurred. -1 is returned for example if a vertex or pixel shader
	program could not be compiled, the error strings are then printed out
	into the error log, and can be caught with a custom event receiver. 
</member>
        <member name="M:irr.video.IGPUProgrammingServices.addShaderMaterialFromFiles(irr.io.IReadFile*,irr.io.IReadFile*,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32)">
\param vertexShaderProgram Text file containing the source of the
	vertex shader program. Set to 0 if no shader shall be created.
	\param pixelShaderProgram Text file containing the source of the pixel
	shader program. Set to 0 if no shader shall be created.
	\param callback Pointer to an IShaderConstantSetCallback object to
	which the OnSetConstants function is called.
	\param baseMaterial baseMaterial
	\param userData a user data int. This int can be set to any value and
	will be set as parameter in the callback method when calling
	OnSetConstants(). In this way it is easily possible to use the same
	callback method for multiple materials and distinguish between them
	during the call.
	\return Returns the number of the material type which can be set in
	SMaterial::MaterialType to use the renderer. -1 is returned if an
	error occurred. -1 is returned for example if a vertex or pixel shader
	program could not be compiled, the error strings are then printed out
	into the error log, and can be caught with a custom event receiver. 
</member>
        <member name="M:irr.video.IGPUProgrammingServices.addShaderMaterial(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32)">
Note that it is a good idea to call IVideoDriver::queryFeature() in
	advance to check if the IVideoDriver supports the vertex and/or pixel
	shader version your are using.

	The material is added to the VideoDriver like with
	IVideoDriver::addMaterialRenderer() and can be used like it had been
	added with that method.
	\param vertexShaderProgram String containing the source of the vertex
	shader program. This can be 0 if no vertex program shall be used.

	For DX8 programs, the will always input registers look like this: v0:
	position, v1: normal, v2: color, v3: texture coordinates, v4: texture
	coordinates 2 if available.

	For DX9 programs, you can manually set the registers using the dcl_
	statements.
	\param pixelShaderProgram String containing the source of the pixel
	shader program. This can be 0 if you don't want to use a pixel shader.
	\param callback Pointer to an implementation of
	IShaderConstantSetCallBack in which you can set the needed vertex and
	pixel shader program constants. Set this to 0 if you don't need this.
	\param baseMaterial Base material which renderstates will be used to
	shade the material.
	\param userData a user data int. This int can be set to any value and
	will be set as parameter in the callback method when calling
	OnSetConstants(). In this way it is easily possible to use the same
	callback method for multiple materials and distinguish between them
	during the call.
	\return Returns the number of the material type which can be set in
	SMaterial::MaterialType to use the renderer. -1 is returned if an
	error occurred. -1 is returned for example if a vertex or pixel shader
	program could not be compiled, the error strings are then printed out
	into the error log, and can be caught with a custom event receiver. 
</member>
        <member name="M:irr.video.IGPUProgrammingServices.addHighLevelShaderMaterialFromFiles(irr.io.IReadFile*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.E_VERTEX_SHADER_TYPE,irr.io.IReadFile*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.E_PIXEL_SHADER_TYPE,irr.io.IReadFile*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.E_GEOMETRY_SHADER_TYPE,irr.scene.E_PRIMITIVE_TYPE,irr.scene.E_PRIMITIVE_TYPE,System.UInt32,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32,irr.video.E_GPU_SHADING_LANGUAGE)">
\param vertexShaderProgram Text file handle containing the source
	of the vertex shader program. Set to 0 if no vertex shader shall be
	created.
	\param vertexShaderEntryPointName Name of the entry function of the
	vertexShaderProgram
	\param vsCompileTarget Vertex shader version the high level shader
	shall be compiled to.
	\param pixelShaderProgram Text file handle containing the source of
	the pixel shader program. Set to 0 if no pixel shader shall be created.
	\param pixelShaderEntryPointName Entry name of the function of the
	pixelShaderProgram (p.e. "main")
	\param psCompileTarget Pixel shader version the high level shader
	shall be compiled to.
	\param geometryShaderProgram Text file handle containing the source of
	the geometry shader program. Set to 0 if no geometry shader shall be
	created.
	\param geometryShaderEntryPointName Entry name of the function of the
	geometryShaderProgram (p.e. "main")
	\param gsCompileTarget Geometry shader version the high level shader
	shall be compiled to.
	\param inType Type of vertices passed to geometry shader
	\param outType Type of vertices created by geometry shader
	\param verticesOut Maximal number of vertices created by geometry
	shader. If 0, maximal number supported is assumed.
	\param callback Pointer to an implementation of
	IShaderConstantSetCallBack in which you can set the needed vertex and
	pixel shader program constants. Set this to 0 if you don't need this.
	\param baseMaterial Base material which renderstates will be used to
	shade the material.
	\param userData a user data int. This int can be set to any value and
	will be set as parameter in the callback method when calling
	OnSetConstants(). In this way it is easily possible to use the same
	callback method for multiple materials and distinguish between them
	during the call.
	\param shaderLang a type of shading language used in current shader.
	\return Number of the material type which can be set in
	SMaterial::MaterialType to use the renderer. -1 is returned if an
	error occurred, e.g. if a shader program could not be compiled or a
	compile target is not reachable. The error strings are then printed to
	the error log and can be caught with a custom event receiver. 
</member>
        <member name="M:irr.video.IGPUProgrammingServices.addHighLevelShaderMaterialFromFiles(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.scene.E_PRIMITIVE_TYPE,irr.scene.E_PRIMITIVE_TYPE,System.UInt32,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32)">
All shader names are set to "main" and compile targets are shader
	type 1.1 and geometry shader 4.0.

</member>
        <member name="M:irr.video.IGPUProgrammingServices.addHighLevelShaderMaterialFromFiles(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32)">
All shader names are set to "main" and compile targets are shader
	type 1.1.

</member>
        <member name="M:irr.video.IGPUProgrammingServices.addHighLevelShaderMaterialFromFiles(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.E_VERTEX_SHADER_TYPE,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.E_PIXEL_SHADER_TYPE,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*">
\param vertexShaderProgramFileName Text file containing the source
	of the vertex shader program. Set to empty string if no vertex shader
	shall be created.
	\param vertexShaderEntryPointName Name of the entry function of the
	vertexShaderProgram  (p.e. "main")
	\param vsCompileTarget Vertex shader version the high level shader
	shall be compiled to.
	\param pixelShaderProgramFileName Text file containing the source of
	the pixel shader program. Set to empty string if no pixel shader shall
	be created.
	\param pixelShaderEntryPointName Entry name of the function of the
	pixelShaderProgram (p.e. "main")
	\param psCompileTarget Pixel shader version the high level shader
	shall be compiled to.
	\param geometryShaderProgramFileName Name of the source of
	the geometry shader program. Set to empty string if no geometry shader
	shall be created.
	\param geometryShaderEntryPointName Entry name of the function of the
	geometryShaderProgram (p.e. "main")
	\param gsCompileTarget Geometry shader version the high level shader
	shall be compiled to.
	\param inType Type of vertices passed to geometry shader
	\param outType Type of vertices created by geometry shader
	\param verticesOut Maximal number of vertices created by geometry
	shader. If 0, maximal number supported is assumed.
	\param callback Pointer to an implementation of
	IShaderConstantSetCallBack in which you can set the needed vertex,
	pixel, and geometry shader program constants. Set this to 0 if you
	don't need this.
	\param baseMaterial Base material which renderstates will be used to
	shade the material.
	\param userData a user data int. This int can be set to any value and
	will be set as parameter in the callback method when calling
	OnSetConstants(). In this way it is easily possible to use the same
	callback method for multiple materials and distinguish between them
	during the call.
	\param shaderLang a type of shading language used in current shader.
	\return Number of the material type which can be set in
	SMaterial::MaterialType to use the renderer. -1 is returned if an error
	occurred, e.g. if a shader program could not be compiled or a compile
	target is not reachable. The error strings are then printed to the
	error log and can be caught with a custom event receiver. 
</member>
        <member name="M:irr.video.IGPUProgrammingServices.addHighLevelShaderMaterial(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.scene.E_PRIMITIVE_TYPE,irr.scene.E_PRIMITIVE_TYPE,System.UInt32,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32)">
All shader names are set to "main" and compile targets are shader
	type 1.1 and geometry shader 4.0.

</member>
        <member name="M:irr.video.IGPUProgrammingServices.addHighLevelShaderMaterial(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.IShaderConstantSetCallBack*,irr.video.E_MATERIAL_TYPE,System.Int32)">
All shader names are set to "main" and compile targets are shader
	type 1.1.

</member>
        <member name="M:irr.video.IGPUProgrammingServices.addHighLevelShaderMaterial(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.E_VERTEX_SHADER_TYPE,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.video.E_PIXEL_SHADER_TYPE,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.v">
Currently only HLSL/D3D9 and GLSL/OpenGL are supported.
	\param vertexShaderProgram String containing the source of the vertex
	shader program. This can be 0 if no vertex program shall be used.
	\param vertexShaderEntryPointName Name of the entry function of the
	vertexShaderProgram (p.e. "main")
	\param vsCompileTarget Vertex shader version the high level shader
	shall be compiled to.
	\param pixelShaderProgram String containing the source of the pixel
	shader program. This can be 0 if no pixel shader shall be used.
	\param pixelShaderEntryPointName Entry name of the function of the
	pixelShaderProgram (p.e. "main")
	\param psCompileTarget Pixel shader version the high level shader
	shall be compiled to.
	\param geometryShaderProgram String containing the source of the
	geometry shader program. This can be 0 if no geometry shader shall be
	used.
	\param geometryShaderEntryPointName Entry name of the function of the
	geometryShaderProgram (p.e. "main")
	\param gsCompileTarget Geometry shader version the high level shader
	shall be compiled to.
	\param inType Type of vertices passed to geometry shader
	\param outType Type of vertices created by geometry shader
	\param verticesOut Maximal number of vertices created by geometry
	shader. If 0, maximal number supported is assumed.
	\param callback Pointer to an implementation of
	IShaderConstantSetCallBack in which you can set the needed vertex,
	pixel, and geometry shader program constants. Set this to 0 if you
	don't need this.
	\param baseMaterial Base material which renderstates will be used to
	shade the material.
	\param userData a user data int. This int can be set to any value and
	will be set as parameter in the callback method when calling
	OnSetConstants(). In this way it is easily possible to use the same
	callback method for multiple materials and distinguish between them
	during the call.
	\param shaderLang a type of shading language used in current shader.
	\return Number of the material type which can be set in
	SMaterial::MaterialType to use the renderer. -1 is returned if an error
	occurred, e.g. if a shader program could not be compiled or a compile
	target is not reachable. The error strings are then printed to the
	error log and can be caught with a custom event receiver. 
</member>
        <member name="M:irr.scene.IGeometryCreator.createVolumeLightMesh(System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param subdivideU Horizontal patch count.
\param subdivideV Vertical patch count.
\param footColor Color at the bottom of the light.
\param tailColor Color at the mid of the light.
\param lpDistance Virtual distance of the light point for normals.
\param lightDim Dimensions of the light.
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createConeMesh(System.Single,System.Single,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\param radius Radius of the cone.
\param length Length of the cone.
\param tesselation Number of quads around the circumference of the cone.
\param colorTop The color of the top of the cone.
\param colorBottom The color of the bottom of the cone.
\param oblique (to be documented)
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createCylinderMesh(System.Single,System.Single,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Single)">
\param radius Radius of the cylinder.
\param length Length of the cylinder.
\param tesselation Number of quads around the circumference of the cylinder.
\param color The color of the cylinder.
\param closeTop If true, close the ends of the cylinder, otherwise leave them open.
\param oblique (to be documented)
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createSphereMesh(System.Single,System.UInt32,System.UInt32)">
\param radius Radius of the sphere
\param polyCountX Number of quads used for the horizontal tiling
\param polyCountY Number of quads used for the vertical tiling
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createArrowMesh(System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst,irr.video.SColor!System.Runtime.CompilerServices.IsConst)">
\param tesselationCylinder Number of quads composing the cylinder.
\param tesselationCone Number of triangles composing the cone's roof.
\param height Total height of the arrow
\param cylinderHeight Total height of the cylinder, should be lesser
than total height
\param widthCylinder Diameter of the cylinder
\param widthCone Diameter of the cone's base, should be not smaller
than the cylinder's diameter
\param colorCylinder color of the cylinder
\param colorCone color of the cone
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createTerrainMesh(irr.video.IImage*,irr.video.IImage*,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,irr.video.IVideoDriver*,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
\param texture The texture to apply to the terrain.
\param heightmap An image that will be interpreted as a heightmap. The
brightness (average color) of each pixel is interpreted as a height,
with a 255 brightness pixel producing the maximum height.
\param stretchSize The size that each pixel will produce, i.e. a
512x512 heightmap
and a stretchSize of (10.f, 20.f) will produce a mesh of size
5120.f x 10240.f
\param maxHeight The maximum height of the terrain.
\param driver The current video driver.
\param defaultVertexBlockSize (to be documented)
\param debugBorders (to be documented)
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createGeoplaneMesh(System.Single,System.UInt32,System.UInt32)">
\param radius Radius of the plane
\param rows How many rows to place
\param columns How many columns to place
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createPlaneMesh(irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SMaterial*,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param tileSize The size of each tile.
\param tileCount The number of tiles in each dimension.
\param material The material to apply to the mesh.
\param textureRepeatCount The number of times to repeat the material texture along each dimension.
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createHillPlaneMesh(irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SMaterial*,System.Single,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param tileSize The size of each tile.
\param tileCount The number of tiles in each dimension.
\param material The material to apply to the mesh.
\param hillHeight The maximum height of the hills.
\param countHills The number of hills along each dimension.
\param textureRepeatCount The number of times to repeat the material texture along each dimension.
\return Generated mesh.

</member>
        <member name="M:irr.scene.IGeometryCreator.createCubeMesh(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param size Dimensions of the cube.
\return Generated mesh.

</member>
        <member name="T:irr.scene.IGeometryCreator">
You can get an instance of this class through ISceneManager::getGeometryCreator() 
</member>
        <member name="M:irr.scene.IDummyTransformationSceneNode.getRelativeTransformationMatrix">
This is the matrix, this scene node uses instead of scale, translation
	and rotation. 
</member>
        <member name="T:irr.scene.IDummyTransformationSceneNode">
This scene node does not render itself, and does not respond to set/getPosition,
set/getRotation and set/getScale. Its just a simple scene node that takes a
matrix as relative transformation, making it possible to insert any transformation
anywhere into the scene graph.
This scene node is for example used by the IAnimatedMeshSceneNode for emulating
joint scene nodes when playing skeletal animations.

</member>
        <member name="M:irr.gui.ICursorControl.getPlatformBehavior">
\return Behavior set by setPlatformBehavior or ECPB_NONE for platforms not implementing specific behaviors.

</member>
        <member name="M:irr.gui.ICursorControl.changeIcon(irr.gui.ECURSOR_ICON,irr.gui.SCursorSprite!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Changing cursor icons is so far only supported on Win32 and Linux
			Note that this only changes the icons within your application, system cursors outside your
			application will not be affected.

</member>
        <member name="M:irr.gui.ICursorControl.addIcon(irr.gui.SCursorSprite!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\return Identification for the icon 
</member>
        <member name="M:irr.gui.ICursorControl.setActiveIcon(irr.gui.ECURSOR_ICON)">
Setting cursor icons is so far only supported on Win32 and Linux 
</member>
        <member name="M:irr.gui.ICursorControl.setReferenceRect(irr.core.rect&lt;System.Int32&gt;*)">
If this rect is set, the cursor position is not being calculated relative to
		the rendering window but to this rect. You can set the rect pointer to 0 to disable
		this feature again. This feature is useful when rendering into parts of foreign windows
		for example in an editor.
		\param rect: A pointer to an reference rectangle or 0 to disable the reference rectangle.
</member>
        <member name="M:irr.gui.ICursorControl.getRelativePosition">
\return Returns the current position of the cursor. The returned position
		is a value between (0.0f, 0.0f) and (1.0f, 1.0f), where (0.0f, 0.0f) is
		the top left corner and (1.0f, 1.0f) is the bottom right corner of the
		render window. 
</member>
        <member name="M:irr.gui.ICursorControl.getPosition">
\return Returns the current position of the cursor. The returned position
		is the position of the mouse cursor in pixel units. 
</member>
        <member name="M:irr.gui.ICursorControl.setPosition(System.Int32,System.Int32)">
\param x New x-coord of the cursor. The coordinates are pixel units.
		\param y New y-coord of the cursor. The coordinates are pixel units. 
</member>
        <member name="M:irr.gui.ICursorControl.setPosition(irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param pos: New position of the cursor. The coordinates are pixel units. 
</member>
        <member name="M:irr.gui.ICursorControl.setPosition(System.Single,System.Single)">
The position must be
		between (0.0f, 0.0f) and (1.0f, 1.0f), where (0.0f, 0.0f) is
		the top left corner and (1.0f, 1.0f) is the bottom right corner of the
		render window.
		\param x New x-coord of the cursor.
		\param y New x-coord of the cursor. 
</member>
        <member name="M:irr.gui.ICursorControl.setPosition(irr.core.vector2d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The position must be
		between (0.0f, 0.0f) and (1.0f, 1.0f), where (0.0f, 0.0f) is
		the top left corner and (1.0f, 1.0f) is the bottom right corner of the
		render window.
		\param pos New position of the cursor. 
</member>
        <member name="M:irr.gui.ICursorControl.isVisible">
\return True if the cursor is visible, false if not. 
</member>
        <member name="M:irr.gui.ICursorControl.setVisible(System.Boolean)">
\param visible: The new visible state. If true, the cursor will be visible,
		if false, it will be invisible. 
</member>
        <member name="M:irr.video.IContextManager.activateContext(irr.video.SExposedVideoData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
This is mostly used internally by IVideoDriver::beginScene().
			But if you want to switch threads which access your OpenGL driver you will have to
			call this function as follows:
			Old thread gives up context with: activateContext(irr::video::SExposedVideoData());
			New thread takes over context with: activateContext(videoDriver-&gt;getExposedVideoData());
			Note that only 1 thread at a time may access an OpenGL context.	
</member>
        <member name="F:irr.SIrrlichtCreationParameters.SDK_version_do_not_use">
Always set it to IRRLICHT_SDK_VERSION, which is done by default.
		This is needed for sdk version checks. 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.UsePerformanceTimer">
When performance timers are not used, standard GetTickCount()
		is used instead which usually has worse resolution, but also less
		problems with speed stepping and other techniques.

</member>
        <member name="F:irr.SIrrlichtCreationParameters.DriverMultithreaded">
Default is false. Enabling this can slow down your application.
			Note that this does _not_ make Irrlicht threadsafe, but only the underlying driver-API for the graphiccard.
			So far only supported on D3D. 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.DisplayAdapter">
So far only supported on D3D 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.LoggingLevel">
The default value is ELL_INFORMATION. You can access the ILogger interface
		later on from the IrrlichtDevice with getLogger() and set another level.
		But if you need more or less logging information already from device creation,
		then you have to change it here.

</member>
        <member name="F:irr.SIrrlichtCreationParameters.HighPrecisionFPU">
This is only relevant for DirectX Devices, which switch to
		low FPU precision by default for performance reasons. However,
		this may lead to problems with the other computations of the
		application. In this case setting this flag to true should help
		- on the expense of performance loss, though.
		Default value: false 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.Stereobuffer">
Some high-end gfx cards support two framebuffers for direct
		support of stereoscopic output devices. If this flag is set the
		device tries to create a stereo context.
		Currently only supported by OpenGL.
		Default value: false 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.IgnoreInput">
This is only relevant when using external I/O handlers.
		External windows need to take care of this themselves.
		Currently only supported by X11.
		Default value: false 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.Doublebuffer">
This should be usually enabled, in order to avoid render
		artifacts on the visible framebuffer. However, it might be
		useful to use only one buffer on very small devices. If no
		doublebuffering is available, the drivers will fall back to
		single buffers. Default value: true 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.WithAlphaChannel">
In some situations it might be desirable to get a color
		buffer with an alpha channel, e.g. when rendering into a
		transparent window or overlay. If this flag is set the device
		tries to create a framebuffer with alpha channel.
		If this flag is set, only color buffers with alpha channel
		are considered. Otherwise, it depends on the actual hardware
		if the colorbuffer has an alpha channel or not.
		Default value: false 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.HandleSRGB">
In most situations, it is desirable to have the color handling in
		non-linear sRGB color space, and only do the intermediate color
		calculations in linear RGB space. If this flag is enabled, the device and
		driver try to assure that all color input and output are color corrected
		and only the internal color representation is linear. This means, that
		the color output is properly gamma-adjusted to provide the brighter
		colors for monitor display. And that blending and lighting give a more
		natural look, due to proper conversion from non-linear colors into linear
		color space for blend operations. If this flag is enabled, all texture colors
		(which are usually in sRGB space) are correctly displayed. However vertex colors
		and other explicitly set values have to be manually encoded in linear color space.
		Default value: false. 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.AntiAlias">
Makes sharp/pixelated edges softer, but requires more
		performance. Also, 2D elements might look blurred with this
		switched on. The resulting rendering quality also depends on
		the hardware and driver you are using, your program might look
		different on different hardware with this. So if you are
		writing a game/application with AntiAlias switched on, it would
		be a good idea to make it possible to switch this option off
		again by the user.
		The value is the maximal antialiasing factor requested for
		the device. The creation method will automatically try smaller
		values if no window can be created with the given value.
		Value one is usually the same as 0 (disabled), but might be a
		special value on some platforms. On D3D devices it maps to
		NONMASKABLE.
		Default value: 0 - disabled 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.Vsync">
If set to true, the driver will wait for the vertical
		retrace period, otherwise not. May be silently ignored.
		Default: false 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.Stencilbuffer">
Set this to true, if you want the engine be able to draw
		stencil buffer shadows. Note that not all drivers are able to
		use the stencil buffer, hence it can be ignored during device
		creation. Without the stencil buffer no shadows will be drawn.
		Default: true. 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.Fullscreen">
Otherwise the device runs in windowed mode. Default: false. 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.DriverType">
This can currently be video::EDT_NULL, video::EDT_SOFTWARE,
		video::EDT_BURNINGSVIDEO, video::EDT_DIRECT3D9, and video::EDT_OPENGL.
		Default: EDT_BURNINGSVIDEO. 
</member>
        <member name="F:irr.SIrrlichtCreationParameters.DeviceType">
This setting decides the windowing system used by the device, most device types are native
		to a specific operating system and so may not be available.
		EIDT_WIN32 is only available on Windows desktops,
		EIDT_WINCE is only available on Windows mobile devices,
		EIDT_COCOA is only available on Mac OSX,
		EIDT_X11 is available on Linux, Solaris, BSD and other operating systems which use X11,
		EIDT_SDL is available on most systems if compiled in,
		EIDT_CONSOLE is usually available but can only render to text,
		EIDT_BEST will select the best available device for your operating system.
		Default: EIDT_BEST. 
</member>
        <member name="T:irr.SIrrlichtCreationParameters">
This structure is used in the createDeviceEx() function. 
</member>
        <member name="F:EIDT_BEST">
If this selection is chosen then Irrlicht will try to use the IrrlichtDevice native
		to your operating system. If this is unavailable then the X11, SDL and then console device
		will be tried. This ensures that Irrlicht will run even if your platform is unsupported,
		although it may not be able to render anything. 
</member>
        <member name="F:EIDT_CONSOLE">
This device allows applications to run from the command line without opening a window.
		It can render the output of the software drivers to the console as ASCII. It only supports
		mouse and keyboard in Windows operating systems. 
</member>
        <member name="F:EIDT_FRAMEBUFFER">
Best used with embedded devices and mobile systems.
		Does not need X11 or other graphical subsystems.
		May support hw-acceleration via OpenGL-ES for FBDirect 
</member>
        <member name="F:EIDT_SDL">
The SDL device works under all platforms supported by SDL but first must be compiled
		in by defining the _IRR_COMPILE_WITH_SDL_DEVICE_ macro in IrrCompileConfig.h 
</member>
        <member name="F:EIDT_OSX">
This device uses Apple's Cocoa API and works in Mac OSX 10.2 and above. 
</member>
        <member name="F:EIDT_X11">
This device uses the X11 windowing system and works in Linux, Solaris, FreeBSD, OSX and
		other operating systems which support X11. 
</member>
        <member name="F:EIDT_WINCE">
This device works on Windows Mobile, Pocket PC and Microsoft SmartPhone devices 
</member>
        <member name="F:EIDT_WIN32">
This device uses the Win32 API and works in all versions of Windows. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getTargetAndRotationBinding">
@see bindTargetAndRotation() 
</member>
        <member name="M:irr.scene.ICameraSceneNode.bindTargetAndRotation(System.Boolean)">
When bound, calling setRotation() will update the camera's
		target position to be along its +Z axis, and likewise calling
		setTarget() will update its rotation so that its +Z axis will
		point at the target point. FPS camera use this binding by
		default; other cameras do not.
		\param bound True to bind the camera's scene node rotation
		and targeting, false to unbind them.
		@see getTargetAndRotationBinding() 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setInputReceiverEnabled(System.Boolean)">
If this is set to true, the camera will respond to key
		inputs otherwise not. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getViewFrustum">
\return The current view frustum. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setFOV(System.Single)">
\param fovy: New field of view in radians. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setAspectRatio(System.Single)">
\param aspect: New aspect ratio. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setFarValue(System.Single)">
\param zf: New z far value. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setNearValue(System.Single)">
\param zn: New z near value. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getFOV">
\return The field of view of the camera in radians. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getAspectRatio">
\return The aspect ratio of the camera. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getFarValue">
\return The value of the far plane of the camera. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getNearValue">
\return The value of the near plane of the camera. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getUpVector">
\return The up vector of the camera, in world space. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setUpVector(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param pos: New upvector of the camera. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getTarget">
\return The current look at target of the camera, in world co-ordinates 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setRotation(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This only modifies the relative rotation of the node.
		If the camera's target and rotation are bound ( @see
		bindTargetAndRotation() ) then calling this will also change
		the camera's target to match the rotation.
		\param rotation New rotation of the node in degrees. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setTarget(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
If the camera's target and rotation are bound ( @see
		bindTargetAndRotation() ) then calling this will also change
		the camera's scene node rotation to match the target.
		Note that setTarget uses the current absolute position
		internally, so if you changed setPosition since last rendering you must
		call updateAbsolutePosition before using this function.
		\param pos Look at target of the camera, in world co-ordinates. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.OnEvent(irr.SEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Most cameras may ignore this input, but camera scene nodes
		which are created for example with
		ISceneManager::addCameraSceneNodeMaya or
		ISceneManager::addCameraSceneNodeFPS, may want to get
		this input for changing their position, look at target or
		whatever. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getViewMatrixAffector">
\return The affector matrix. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setViewMatrixAffector(irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The matrix passed here, will be multiplied with the view
		matrix when it gets updated. This allows for custom camera
		setups like, for example, a reflection camera.
		\param affector The affector matrix. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getViewMatrix">
\return The current view matrix of the camera. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.getProjectionMatrix">
\return The current projection matrix of the camera. 
</member>
        <member name="M:irr.scene.ICameraSceneNode.setProjectionMatrix(irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
The core::matrix4 class has some methods to build a
		projection matrix. e.g:
		core::matrix4::buildProjectionMatrixPerspectiveFovLH.
		Note that the matrix will only stay as set by this method until
		one of the following Methods are called: setNearValue,
		setFarValue, setAspectRatio, setFOV.
		\param projection The new projection matrix of the camera.
		\param isOrthogonal Set this to true if the matrix is an
		orthogonal one (e.g. from matrix4::buildProjectionMatrixOrtho).

</member>
        <member name="T:irr.scene.ICameraSceneNode">
The whole scene will be rendered from the cameras point of view.
	Because the ICameraSceneNode is a SceneNode, it can be attached to any
	other scene node, and will follow its parents movement, rotation and so
	on.

</member>
        <member name="M:irr.scene.IBillboardTextSceneNode.getColor(irr.video.SColor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param topColor: stores the color of the top vertices
	\param bottomColor: stores the color of the bottom vertices 
</member>
        <member name="M:irr.scene.IBillboardTextSceneNode.setColor(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param topColor: the color to set the top vertices
	\param bottomColor: the color to set the bottom vertices 
</member>
        <member name="M:irr.scene.IBillboardTextSceneNode.setColor(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param overallColor: the color to set 
</member>
        <member name="T:irr.scene.IBillboardTextSceneNode">
Acts like a billboard which displays the currently set text.
  Due to the exclusion of RTTI in Irrlicht we have to avoid multiple
  inheritance. Hence, changes to the ITextSceneNode interface have
  to be copied here manually.

</member>
        <member name="M:irr.scene.IBillboardSceneNode.getTransformedBillboardBoundingBox(irr.scene.ICameraSceneNode!System.Runtime.CompilerServices.IsConst*)">
The boundingbox returned will use absolute coordinates.
		The billboard orients itself toward the camera and some only update in render().
	    So we don't know the real boundingboxes before that. Which would be too late for culling.
	    That is why the usual getBoundingBox will return a "safe" boundingbox which is guaranteed
	    to contain the billboard. While this function can return the real one. 
</member>
        <member name="M:irr.scene.IBillboardSceneNode.getColor(irr.video.SColor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param[out] topColor Stores the color of the top vertices
	\param[out] bottomColor Stores the color of the bottom vertices 
</member>
        <member name="M:irr.scene.IBillboardSceneNode.setColor(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param[in] topColor Color to set the top vertices
	\param[in] bottomColor Color to set the bottom vertices 
</member>
        <member name="M:irr.scene.IBillboardSceneNode.setColor(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param[in] overallColor Color to set 
</member>
        <member name="M:irr.scene.IBillboardSceneNode.getSize(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param[out] height The height of the billboard.
	\param[out] bottomEdgeWidth The width of the bottom edge of the billboard.
	\param[out] topEdgeWidth The width of the top edge of the billboard.

</member>
        <member name="M:irr.scene.IBillboardSceneNode.getSize">
This will return the width of the bottom edge of the billboard.
	Use getWidths() to retrieve the bottom and top edges independently.
	\return Size of the billboard.

</member>
        <member name="M:irr.scene.IBillboardSceneNode.setSize(System.Single,System.Single,System.Single)">
\param[in] height The height of the billboard.
	\param[in] bottomEdgeWidth The width of the bottom edge of the billboard.
	\param[in] topEdgeWidth The width of the top edge of the billboard.

</member>
        <member name="T:irr.scene.IBillboardSceneNode">
A billboard is like a 3d sprite: A 2d element,
which always looks to the camera. It is usually used for explosions, fire,
lensflares, particles and things like that.

</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.clone(irr.scene.ISceneNode*,irr.scene.ISceneManager*)">
\param newParent An optional new parent.
		\param newManager An optional new scene manager.
		\return The newly created clone of this node. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setRenderFromIdentity(System.Boolean)">
Culling is unaffected. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.animateJoints(System.Boolean)">
Also takes in to account transitions. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setTransitionTime(System.Single)">
Note: This needs to enable joints, and setJointmode set to
		EJUOR_CONTROL. You must call animateJoints(), or the mesh will
		not animate. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setReadOnlyMaterials(System.Boolean)">
In this way it is possible to change the materials a mesh
		causing all mesh scene nodes referencing this mesh to change
		too. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setAnimationEndCallback(irr.scene.IAnimationEndCallBack*)">
Set this to 0 to disable the callback again.
		Please note that this will only be called when in non looped
		mode, see IAnimatedMeshSceneNode::setLoopMode(). 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.getLoopMode">
When true the animations are played looped 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setLoopMode(System.Boolean)">
If set to false, animations will not be played looped. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setMD2Animation(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
With this method it is easily possible to start a Run,
		Attack, Die or whatever animation, if the mesh contained in
		this scene node is an md2 mesh. Otherwise, nothing happens.
		This method uses a character string to identify the animation.
		If the animation is a standard md2 animation, you might want to
		start this animation with the EMD2_ANIMATION_TYPE enumeration
		instead.
		\param animationName: Name of the animation which should be
		played.
		\return Returns true if successful, and false if not, for
		example if the mesh in the scene node is not an md2 mesh, or no
		animation with this name could be found. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setMD2Animation(irr.scene.EMD2_ANIMATION_TYPE)">
With this method it is easily possible to start a Run,
		Attack, Die or whatever animation, if the mesh contained in
		this scene node is an md2 mesh. Otherwise, nothing happens.
		\param anim: An MD2 animation type, which should be played, for
		example EMAT_STAND for the standing animation.
		\return True if successful, and false if not, for example if
		the mesh in the scene node is not a md2 mesh. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.getJointCount">
\return Amount of joints in the mesh. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.getJointNode(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
With this method it is possible to attach scene nodes to
		joints for example possible to attach a weapon to the left hand
		of an animated model. This example shows how:
		\code
		ISceneNode* hand =
			yourAnimatedMeshSceneNode-&gt;getJointNode("LeftHand");
		hand-&gt;addChild(weaponSceneNode);
		\endcode
		Please note that the joint returned by this method may not exist
		before this call and the joints in the node were created by it.
		\param jointName: Name of the joint.
		\return Pointer to the scene node which represents the joint
		with the specified name. Returns 0 if the contained mesh is not
		an skinned mesh or the name of the joint could not be found. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.addShadowVolumeSceneNode(irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Boolean,System.Single)">
The shadow can be rendered using the ZPass or the zfail
		method. ZPass is a little bit faster because the shadow volume
		creation is easier, but with this method there occur ugly
		looking artifacts when the camera is inside the shadow volume.
		These error do not occur with the ZFail method.
		\param shadowMesh: Optional custom mesh for shadow volume.
		\param id: Id of the shadow scene node. This id can be used to
		identify the node later.
		\param zfailmethod: If set to true, the shadow will use the
		zfail method, if not, zpass is used.
		\param infinity: Value used by the shadow volume algorithm to
		scale the shadow volume (for zfail shadow volume we support only
		finite shadows, so camera zfar must be larger than shadow back cap,
		which is depend on infinity parameter).
		\return Pointer to the created shadow scene node. This pointer
		should not be dropped. See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.getAnimationSpeed">
\return Frames per second played. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setAnimationSpeed(System.Single)">
\param framesPerSecond: Frames per second played. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setFrameLoop(System.Int32,System.Int32)">
The default is 0 to getFrameCount()-1 of the mesh.
		Number of played frames is end-start.
		It interpolates toward the last frame but stops when it is reached.
		It does not interpolate back to start even when looping.
		Looping animations should ensure last and first frame-key are identical.
		\param begin: Start frame number of the loop.
		\param end: End frame number of the loop.
		\return True if successful, false if not. 
</member>
        <member name="M:irr.scene.IAnimatedMeshSceneNode.setCurrentFrame(System.Single)">
From now on the animation is played from this frame.
		\param frame: Number of the frame to let the animation be started from.
		The frame number must be a valid frame number of the IMesh used by this
		scene node. Set IAnimatedMesh::getMesh() for details. 
</member>
        <member name="T:irr.scene.IAnimatedMeshSceneNode">
The shadow is optional: If a shadow should be displayed too, just
	invoke the IAnimatedMeshSceneNode::createShadowVolumeSceneNode().
</member>
        <member name="M:irr.scene.IAnimationEndCallBack.OnAnimationEnd(irr.scene.IAnimatedMeshSceneNode*)">
See IAnimatedMeshSceneNode::setAnimationEndCallback for
		more information.
		\param node: Node of which the animation has ended. 
</member>
        <member name="T:irr.scene.IAnimationEndCallBack">
Implement this interface and use
	IAnimatedMeshSceneNode::setAnimationEndCallback to be able to
	be notified if an animation playback has ended.
	*
</member>
        <member name="M:irr.scene.IBoneSceneNode.render">
Does nothing as bones are not visible. 
</member>
        <member name="M:irr.scene.IBoneSceneNode.setAnimationMode(irr.scene.E_BONE_ANIMATION_MODE)">
\return True if successful. (Unused) 
</member>
        <member name="M:irr.scene.IBoneSceneNode.getBoneName">
\deprecated Use getName instead. This method may be removed by Irrlicht 1.9 
</member>
        <member name="T:irr.scene.IBoneSceneNode">
Used with ISkinnedMesh and IAnimatedMeshSceneNode. 
</member>
        <member name="M:irr.scene.ISceneNode.cloneMembers(irr.scene.ISceneNode*,irr.scene.ISceneManager*)">
This method can be used by clone() implementations of
		derived classes
		\param toCopyFrom The node from which the values are copied
		\param newManager The new scene manager. 
</member>
        <member name="M:irr.scene.ISceneNode.getSceneManager">
\return The node's scene manager. 
</member>
        <member name="M:irr.scene.ISceneNode.clone(irr.scene.ISceneNode*,irr.scene.ISceneManager*)">
\param newParent An optional new parent.
		\param newManager An optional new scene manager.
		\return The newly created clone of this node. 
</member>
        <member name="M:irr.scene.ISceneNode.deserializeAttributes(irr.io.IAttributes*,irr.io.SAttributeReadWriteOptions*)">
Implement this to set the attributes of your scene node for
		scripting languages, editors, debuggers or xml deserialization
		purposes.
		\param in The attribute container to read from.
		\param options Additional options which might influence the
		deserialization. 
</member>
        <member name="M:irr.scene.ISceneNode.serializeAttributes(irr.io.IAttributes*,irr.io.SAttributeReadWriteOptions*)">
Implement this to expose the attributes of your scene node
		for scripting languages, editors, debuggers or xml
		serialization purposes.
		\param out The attribute container to write into.
		\param options Additional options which might influence the
		serialization. 
</member>
        <member name="M:irr.scene.ISceneNode.getType">
\return The type of this node. 
</member>
        <member name="M:irr.scene.ISceneNode.getParent">
\return A pointer to the parent. 
</member>
        <member name="M:irr.scene.ISceneNode.updateAbsolutePosition">
Note: This does not recursively update the parents absolute positions, so if you have a deeper
			hierarchy you might want to update the parents first.
</member>
        <member name="M:irr.scene.ISceneNode.setTriangleSelector(irr.scene.ITriangleSelector*)">
The Selector can be used by the engine for doing collision
		detection. You can create a TriangleSelector with
		ISceneManager::createTriangleSelector() or
		ISceneManager::createOctreeTriangleSelector(). Some nodes may
		create their own selector by default, so it would be good to
		check if there is already a selector in this node by calling
		ISceneNode::getTriangleSelector().
		\param selector New triangle selector for this scene node. 
</member>
        <member name="M:irr.scene.ISceneNode.getTriangleSelector">
The Selector can be used by the engine for doing collision
		detection. You can create a TriangleSelector with
		ISceneManager::createTriangleSelector() or
		ISceneManager::createOctreeTriangleSelector and set it with
		ISceneNode::setTriangleSelector(). If a scene node got no triangle
		selector, but collision tests should be done with it, a triangle
		selector is created using the bounding box of the scene node.
		\return A pointer to the TriangleSelector or 0, if there
		is none. 
</member>
        <member name="M:irr.scene.ISceneNode.setParent(irr.scene.ISceneNode*)">
\param newParent The new parent to be used. 
</member>
        <member name="M:irr.scene.ISceneNode.getChildren">
\return The list of all children of this node. 
</member>
        <member name="M:irr.scene.ISceneNode.isDebugObject">
Debug objects have some special properties, for example they can be easily
		excluded from collision detection or from serialization, etc.
		\return If this node is a debug object, true is returned. 
</member>
        <member name="M:irr.scene.ISceneNode.setIsDebugObject(System.Boolean)">
Debug objects have some special properties, for example they can be easily
		excluded from collision detection or from serialization, etc. 
</member>
        <member name="M:irr.scene.ISceneNode.isDebugDataVisible">
\return A bitwise OR of the debug data values from
		@ref irr::scene::E_DEBUG_SCENE_TYPE that are currently visible. 
</member>
        <member name="M:irr.scene.ISceneNode.setDebugDataVisible(System.UInt32)">
A bitwise OR of the types from @ref irr::scene::E_DEBUG_SCENE_TYPE.
		Please note that not all scene nodes support all debug data types.
		\param state The debug data visibility state to be used. 
</member>
        <member name="M:irr.scene.ISceneNode.getAutomaticCulling">
\return The automatic culling state. 
</member>
        <member name="M:irr.scene.ISceneNode.setAutomaticCulling(System.UInt32)">
Box cullling (EAC_BOX) is set by default. Note that not
		all SceneNodes support culling and that some nodes always cull
		their geometry because it is their only reason for existence,
		for example the OctreeSceneNode.
		\param state The culling state to be used. Check E_CULLING_TYPE for possible values.
</member>
        <member name="M:irr.scene.ISceneNode.getAbsolutePosition">
If you want the position of the node relative to its parent,
		use getPosition() instead.
		NOTE: For speed reasons the absolute position is not
		automatically recalculated on each change of the relative
		position or by a position change of an parent. Instead the
		update usually happens once per frame in OnAnimate. You can enforce
		an update with updateAbsolutePosition().
		\return The current absolute position of the scene node (updated on last call of updateAbsolutePosition). 
</member>
        <member name="M:irr.scene.ISceneNode.setPosition(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Note that the position is relative to the parent.
		\param newpos New relative position of the scene node. 
</member>
        <member name="M:irr.scene.ISceneNode.getPosition">
Note that the position is relative to the parent. If you want
		the position in world coordinates, use getAbsolutePosition() instead.
		\return The current position of the node relative to the parent. 
</member>
        <member name="M:irr.scene.ISceneNode.setRotation(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This only modifies the relative rotation of the node.
		\param rotation New rotation of the node in degrees. 
</member>
        <member name="M:irr.scene.ISceneNode.getRotation">
Note that this is the relative rotation of the node.
		If you want the absolute rotation, use
		getAbsoluteTransformation().getRotation()
		\return Current relative rotation of the scene node. 
</member>
        <member name="M:irr.scene.ISceneNode.setScale(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param scale New scale of the node, relative to its parent. 
</member>
        <member name="M:irr.scene.ISceneNode.getScale">
This is the scale of this node relative to its parent.
		If you want the absolute scale, use
		getAbsoluteTransformation().getScale()
		\return The scale of the scene node. 
</member>
        <member name="M:irr.scene.ISceneNode.setMaterialType(irr.video.E_MATERIAL_TYPE)">
\param newType New type of material to be set. 
</member>
        <member name="M:irr.scene.ISceneNode.setMaterialTexture(System.UInt32,irr.video.ITexture*)">
\param textureLayer Layer of texture to be set. Must be a
		value smaller than MATERIAL_MAX_TEXTURES.
		\param texture New texture to be used. 
</member>
        <member name="M:irr.scene.ISceneNode.setMaterialFlag(irr.video.E_MATERIAL_FLAG,System.Boolean)">
Useful, for example, if you want the whole mesh to be
		affected by light.
		\param flag Which flag of all materials to be set.
		\param newvalue New value of that flag. 
</member>
        <member name="M:irr.scene.ISceneNode.getMaterialCount">
\return Current amount of materials of this scene node. 
</member>
        <member name="M:irr.scene.ISceneNode.getMaterial(System.UInt32)">
To get the amount of materials used by this scene node, use
		getMaterialCount(). This function is needed for inserting the
		node into the scene hierarchy at an optimal position for
		minimizing renderstate changes, but can also be used to
		directly modify the material of a scene node.
		\param num Zero based index. The maximal value is getMaterialCount() - 1.
		\return The material at that index. 
</member>
        <member name="M:irr.scene.ISceneNode.removeAnimators">
The animators might also be deleted if no other grab exists
		for them. 
</member>
        <member name="M:irr.scene.ISceneNode.removeAnimator(irr.scene.ISceneNodeAnimator*)">
If the animator is found, it is also dropped and might be
		deleted if not other grab exists for it.
		\param animator A pointer to the animator to be deleted. 
</member>
        <member name="M:irr.scene.ISceneNode.getAnimators">
\return The list of animators attached to this node. 
</member>
        <member name="M:irr.scene.ISceneNode.addAnimator(irr.scene.ISceneNodeAnimator*)">
\param animator A pointer to the new animator. 
</member>
        <member name="M:irr.scene.ISceneNode.remove">
If no other grab exists for this node, it will be deleted.

</member>
        <member name="M:irr.scene.ISceneNode.removeAll">
The scene nodes found in the children list are also dropped
		and might be deleted if no other grab exists on them.

</member>
        <member name="M:irr.scene.ISceneNode.removeChild(irr.scene.ISceneNode*)">
If found in the children list, the child pointer is also
		dropped and might be deleted if no other grab exists.
		\param child A pointer to the child which shall be removed.
		\return True if the child was removed, and false if not,
		e.g. because it couldn't be found in the children list. 
</member>
        <member name="M:irr.scene.ISceneNode.addChild(irr.scene.ISceneNode*)">
If the scene node already has a parent it is first removed
		from the other parent.
		\param child A pointer to the new child. 
</member>
        <member name="M:irr.scene.ISceneNode.setID(System.Int32)">
This id can be used to identify the node.
		\param id The new id. 
</member>
        <member name="M:irr.scene.ISceneNode.getID">
This id can be used to identify the node.
		\return The id. 
</member>
        <member name="M:irr.scene.ISceneNode.setVisible(System.Boolean)">
All children of this node won't be visible either, when set
		to false. Invisible nodes are not valid candidates for selection by
		collision manager bounding box methods.
		\param isVisible If the node shall be visible. 
</member>
        <member name="M:irr.scene.ISceneNode.isTrulyVisible">
\return true if the node and all its parents are visible,
		false if this or any parent node is invisible. 
</member>
        <member name="M:irr.scene.ISceneNode.isVisible">
This is only an option set by the user, but has nothing to
		do with geometry culling
		\return The requested visibility of the node, true means
		visible (if all parents are also visible). 
</member>
        <member name="M:irr.scene.ISceneNode.getRelativeTransformation">
The relative transformation is stored internally as 3
		vectors: translation, rotation and scale. To get the relative
		transformation matrix, it is calculated from these values.
		\return The relative transformation matrix. 
</member>
        <member name="M:irr.scene.ISceneNode.getAbsoluteTransformation">
NOTE: For speed reasons the absolute transformation is not
		automatically recalculated on each change of the relative
		transformation or by a transformation change of an parent. Instead the
		update usually happens once per frame in OnAnimate. You can enforce
		an update with updateAbsolutePosition().
		\return The absolute transformation matrix. 
</member>
        <member name="M:irr.scene.ISceneNode.getTransformedBoundingBoxEdges(irr.core.array&lt;irr.core.vector3d&lt;System.Single&gt;,irr.core.irrAllocator&lt;irr.core.vector3d&lt;System.Single&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Note: The result is _not_ identical to getTransformedBoundingBox().getEdges(),
		but getting an aabbox3d of these edges would then be identical.
		\param edges Receives an array with the transformed edges 
</member>
        <member name="M:irr.scene.ISceneNode.getTransformedBoundingBox">
Note: The result is still an axis-aligned bounding box, so it's size
		changes with rotation.
		\return The transformed bounding box. 
</member>
        <member name="M:irr.scene.ISceneNode.getBoundingBox">
This means that if this node is an animated 3d character,
		moving in a room, the bounding box will always be around the
		origin. To get the box in real world coordinates, just
		transform it with the matrix you receive with
		getAbsoluteTransformation() or simply use
		getTransformedBoundingBox(), which does the same.
		\return The non-transformed bounding box. 
</member>
        <member name="M:irr.scene.ISceneNode.setName(irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param name New name of the scene node. 
</member>
        <member name="M:irr.scene.ISceneNode.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
\param name New name of the scene node. 
</member>
        <member name="M:irr.scene.ISceneNode.getName">
\return Name as character string. 
</member>
        <member name="M:irr.scene.ISceneNode.OnAnimate(System.UInt32)">
Nodes may calculate or store animations here, and may do other useful things,
		depending on what they are. Also, OnAnimate() should be called for all
		child scene nodes here. This method will be called once per frame, independent
		of whether the scene node is visible or not.
		\param timeMs Current time in milliseconds. 
</member>
        <member name="M:irr.scene.ISceneNode.OnRegisterSceneNode">
Nodes may register themselves in the render pipeline during this call,
		precalculate the geometry which should be renderered, and prevent their
		children from being able to register themselves if they are clipped by simply
		not calling their OnRegisterSceneNode method.
		If you are implementing your own scene node, you should overwrite this method
		with an implementation code looking like this:
		\code
		if (IsVisible)
			SceneManager-&gt;registerNodeForRendering(this);

		ISceneNode::OnRegisterSceneNode();
		\endcode

</member>
        <member name="T:irr.scene.ISceneNode">
A scene node is a node in the hierarchical scene graph. Every scene
	node may have children, which are also scene nodes. Children move
	relative to their parent's position. If the parent of a node is not
	visible, its children won't be visible either. In this way, it is for
	example easily possible to attach a light to a moving car, or to place
	a walking character on a moving platform on a moving ship.

</member>
        <member name="M:irr.scene.ITriangleSelector.getSceneNodeForTriangle(System.UInt32)">
With CMetaTriangleSelector-selectors it's possible to find out a node
	belonging to a certain triangle index.
	NOTE: triangleIndex has nothing to do with the order of triangles returned by getTriangles functions!
	So you can _not_ use this function to find out anything about to which node returned triangles belong.
	Use STriangleCollisionInfo struct for that.
	\param triangleIndex: the index of the triangle for which you want to find.
	\return The scene node associated with that triangle.

</member>
        <member name="M:irr.scene.ITriangleSelector.getSelector(System.UInt32)">
Only useful for MetaTriangleSelector, others return 'this' or 0


Only useful for MetaTriangleSelector, others return 'this' or 0

</member>
        <member name="M:irr.scene.ITriangleSelector.getSelectorCount">
Only useful for MetaTriangleSelector, others return 1

</member>
        <member name="M:irr.scene.ITriangleSelector.getTriangles(irr.core.triangle3d&lt;System.Single&gt;*,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.line3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*,System.Boolean,irr.core.array&lt;irr.scene.SCollisionTriangleRange,irr.core.irrAllocator&lt;irr.scene.SCollisionTriangleRange&gt;&gt;*)">
	This returns all triangles for one scene node associated with this
	selector.  If there is more than one scene node associated (e.g. for
	an IMetaTriangleSelector) this this function may be called multiple
	times to retrieve all triangles.

	Please note that unoptimized triangle selectors also may return
	triangles which are not in contact at all with the 3d line.
	\param triangles Array where the resulting triangles will be written
	to.
	\param arraySize Size of the target array.
	\param outTriangleCount Amount of triangles which have been written
	into the array.
	\param line Only triangles which may be in contact with this 3d line
	will be written into the array.
	\param transform Pointer to matrix for transforming the triangles
	before they are returned. Useful for example to scale all triangles
	down into an ellipsoid space.
	\param useNodeTransform When the selector has a node then transform the
	triangles by that node's transformation matrix.
	\param outTriangleInfo When a pointer to an array is passed then that
	array is filled with additional information about the returned triangles.
	One element of SCollisionTriangleRange added for each range of triangles which
	has distinguishable information. For example one range per meshbuffer. 
</member>
        <member name="M:irr.scene.ITriangleSelector.getTriangles(irr.core.triangle3d&lt;System.Single&gt;*,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.aabbox3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*,System.Boolean,irr.core.array&lt;irr.scene.SCollisionTriangleRange,irr.core.irrAllocator&lt;irr.scene.SCollisionTriangleRange&gt;&gt;*)">
	This returns all triangles for one scene node associated with this
	selector.  If there is more than one scene node associated (e.g. for
	an IMetaTriangleSelector) this this function may be called multiple
	times to retrieve all triangles.

	This method will return at least the triangles that intersect the box,
	but may return other triangles as well.
	\param triangles Array where the resulting triangles will be written
	to.
	\param arraySize Size of the target array.
	\param outTriangleCount Amount of triangles which have been written
	into the array.
	\param box Only triangles which are in this axis aligned bounding box
	will be written into the array.
	\param transform Pointer to matrix for transforming the triangles
	before they are returned. Useful for example to scale all triangles
	down into an ellipsoid space.
	\param useNodeTransform When the selector has a node then transform the
	triangles by that node's transformation matrix.
	\param outTriangleInfo When a pointer to an array is passed then that
	array is filled with additional information about the returned triangles.
	One element of SCollisionTriangleRange added for each range of triangles which
	has distinguishable information. For example one range per meshbuffer. 
</member>
        <member name="M:irr.scene.ITriangleSelector.getTriangles(irr.core.triangle3d&lt;System.Single&gt;*,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*,System.Boolean,irr.core.array&lt;irr.scene.SCollisionTriangleRange,irr.core.irrAllocator&lt;irr.scene.SCollisionTriangleRange&gt;&gt;*)">
This returns all triangles for one scene node associated with this
selector.  If there is more than one scene node associated (e.g. for
an IMetaTriangleSelector) this this function may be called multiple
times to retrieve all triangles.
\param triangles Array where the resulting triangles will be
written to.
\param arraySize Size of the target array.
\param outTriangleCount: Amount of triangles which have been written
into the array.
\param transform Pointer to matrix for transforming the triangles
before they are returned. Useful for example to scale all triangles
down into an ellipsoid space.
\param useNodeTransform When the selector has a node then transform the
triangles by that node's transformation matrix.
\param outTriangleInfo When a pointer to an array is passed then that
array is filled with additional information about the returned triangles.
One element of SCollisionTriangleRange added for each range of triangles which
has distinguishable information. For example one range per meshbuffer.

</member>
        <member name="T:irr.scene.ITriangleSelector">
Every ISceneNode may have a triangle selector, available with
ISceneNode::getTriangleSelector() or ISceneManager::createTriangleSelector.
This is used for doing collision detection: For example if you know, that a
collision may have happened in the area between (1,1,1) and (10,10,10), you
can get all triangles of the scene node in this area with the
ITriangleSelector easily and check every triangle if it collided. 
</member>
        <member name="M:irr.scene.SCollisionTriangleRange.isIndexInRange(System.UInt32)">
\param triangleIndex Index to an element inside the array of triangles returned by ITriangleSelector::getTriangles

</member>
        <member name="T:irr.scene.SCollisionTriangleRange">
ITriangleSelector are free to fill out this information fully, partly or ignore it.
    Usually they will try to fill it when they can and set values to 0 otherwise.

</member>
        <member name="M:irr.scene.ISceneNodeAnimator.cloneMembers(irr.scene.ISceneNodeAnimator!System.Runtime.CompilerServices.IsConst*)">
This method can be used by clone() implementations of
		derived classes
		\param toCopyFrom The animator from which the values are copied 
</member>
        <member name="M:irr.scene.ISceneNodeAnimator.setEnabled(System.Boolean,System.UInt32)">
\param enabled When set to false ISceneNodes will not update the animator anymore.
       Animators themselves usually don't care. So manual calls to animateNode still work.
\param timeNow When set to values &gt; 0 on enabling and disabling an internal timer will be increased by the time disabled time.
	   Animator decide themselves how to handle that timer, but generally setting it will allow you to pause an animator, so it
	   will continue at the same position when you enable it again. To use that pass irr::ITimer::getTime() as value.
	   Animators with no timers will just ignore this.

</member>
        <member name="M:irr.scene.ISceneNodeAnimator.getStartTime">
This will return 0 for by animators which don't work with a starttime unless a starttime was manually set 
</member>
        <member name="M:irr.scene.ISceneNodeAnimator.setStartTime(System.UInt32,System.Boolean)">
By default most animators start on object creation.
			This value is ignored by animators which don't work with a starttime.
			Known problems: CSceneNodeAnimatorRotation currently overwrites this value constantly (might be changed in the future).
			\param time Commonly you will use irr::ITimer::getTime().
			\param resetPauseTime Reset internal pause time for enabling/diabling animators as well

</member>
        <member name="M:irr.scene.ISceneNodeAnimator.hasFinished">
This is only valid for non-looping animators with a discrete end state.
		\return true if the animator has finished, false if it is still running. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimator.isEventReceiverEnabled">
When attached to an active camera, this animator will be
		able to respond to events such as mouse and keyboard events. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimator.createClone(irr.scene.ISceneNode*,irr.scene.ISceneManager*)">
Please note that you will have to drop
		(IReferenceCounted::drop()) the returned pointer after calling this. 
</member>
        <member name="M:irr.scene.ISceneNodeAnimator.animateNode(irr.scene.ISceneNode*,System.UInt32)">
\param node Node to animate.
		\param timeMs Current time in milliseconds. 
</member>
        <member name="T:irr.scene.ISceneNodeAnimator">
A scene node animator is able to animate a scene node in a very simple way. It may
	change its position, rotation, scale and/or material. There are lots of animators
	to choose from. You can create scene node animators with the ISceneManager interface.

</member>
        <member name="F:irr.SJoystickInfo.Axes">
Note: with a Linux device, the POV hat (if any) will use two axes. These
	 *  will be included in this count. 
</member>
        <member name="F:irr.SJoystickInfo.Joystick">
This is an internal Irrlicht index; it does not map directly
	 * to any particular hardware joystick. It corresponds to the
	 * irr::SJoystickEvent Joystick ID. 
</member>
        <member name="M:irr.IEventReceiver.OnEvent(irr.SEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Please take care that you should only return 'true' when you want to _prevent_ Irrlicht
	* from processing the event any further. So 'true' does mean that an event is completely done.
	* Therefore your return value for all unprocessed events should be 'false'.
	\return True if the event was processed.

</member>
        <member name="T:irr.IEventReceiver">
Many of the engine's classes inherit IEventReceiver so they are able to
process events. Events usually start at a postEventFromUser function and are
passed down through a chain of event receivers until OnEvent returns true. See
irr::EEVENT_TYPE for a description of where each type of event starts, and the
path it takes through the system. 
</member>
        <member name="F:irr.SEvent.SJoystickEvent.Joystick">
This is an internal Irrlicht index; it does not map directly
		 * to any particular hardware joystick. 
</member>
        <member name="F:irr.SEvent.SJoystickEvent.POV">
The POV represents the angle of the POV hat in degrees * 100,
		 * from 0 to 35,900.  A value of 65535 indicates that the POV hat
		 * is centered (or not present).
		 * This value is only supported on Windows.  On Linux, the POV hat
		 * will be sent as 2 axes instead. 
</member>
        <member name="F:irr.SEvent.SJoystickEvent.Axis">
For AXIS_X, AXIS_Y, AXIS_Z, AXIS_R, AXIS_U and AXIS_V
		 * Values are in the range -32768 to 32767, with 0 representing
		 * the center position.  You will receive the raw value from the
		 * joystick, and so will usually want to implement a dead zone around
		 * the center of the range. Axes not supported by this joystick will
		 * always have a value of 0. On Linux, POV hats are represented as axes,
		 * usually the last two active axis.

</member>
        <member name="F:irr.SEvent.SJoystickEvent.ButtonStates">
A bitmap of button states.  You can use IsButtonPressed() to
		 ( check the state of each button from 0 to (NUMBER_OF_BUTTONS - 1) 
</member>
        <member name="T:irr.SEvent.SJoystickEvent">
Unlike other events, joystick events represent the result of polling
	 * each connected joystick once per run() of the device. Joystick events will
	 * not be generated by default.  If joystick support is available for the
	 * active device, _IRR_COMPILE_WITH_JOYSTICK_EVENTS_ is defined, and
	 * @ref irr::IrrlichtDevice::activateJoysticks() has been called, an event of
	 * this type will be generated once per joystick per @ref IrrlichtDevice::run()
	 * regardless of whether the state of the joystick has actually changed. 
</member>
        <member name="F:irr.SEvent.SMouseInput.Wheel">
Only valid if event was EMIE_MOUSE_WHEEL 
</member>
        <member name="F:EGET_LISTBOX_SELECTED_AGAIN">
NOTE: You get the event currently only if the item was clicked again within 500 ms or selected by "enter" or "space". 
</member>
        <member name="F:EGET_LISTBOX_CHANGED">
NOTE: You also get this event currently when the same item was clicked again after more than 500 ms. 
</member>
        <member name="F:EGET_ELEMENT_CLOSED">
Windows and context menus use this event when they would like to close,
			this can be canceled by absorbing the event. 
</member>
        <member name="F:EGET_ELEMENT_LEFT">
If an element has sub-elements you also get this message for the subelements 
</member>
        <member name="F:EGET_ELEMENT_HOVERED">
If an element has sub-elements you also get this message for the subelements 
</member>
        <member name="F:EGET_ELEMENT_FOCUSED">
If the event is absorbed then the focus will not be changed. 
</member>
        <member name="F:EGET_ELEMENT_FOCUS_LOST">
GUIEvent.Caller is losing the focus to GUIEvent.Element.
			If the event is absorbed then the focus will not be changed. 
</member>
        <member name="F:EET_USER_EVENT">
This is not used by Irrlicht and can be used to send user
		specific data though the system. The Irrlicht 'window handle'
		can be obtained from IrrlichtDevice::getExposedVideoData()
		The usage and behavior depends on the operating system:
		Windows: send a WM_USER message to the Irrlicht Window; the
			wParam and lParam will be used to populate the
			UserData1 and UserData2 members of the SUserEvent.
		Linux: send a ClientMessage via XSendEvent to the Irrlicht
			Window; the data.l[0] and data.l[1] members will be
			cast to s32 and used as UserData1 and UserData2.
		MacOS: Not yet implemented

</member>
        <member name="F:EET_LOG_TEXT_EVENT">
Log events are only passed to the user receiver if there is one. If they are absorbed by the
		user receiver then no text will be sent to the console. 
</member>
        <member name="F:EET_JOYSTICK_INPUT_EVENT">
Joystick events are created by polling all connected joysticks once per
		device run() and then passing the events to IrrlichtDevice::postEventFromUser.
		They take the same path as mouse events.
		Windows, SDL: Implemented.
		Linux: Implemented, with POV hat issues.
		MacOS / Other: Not yet implemented.

</member>
        <member name="F:EET_KEY_INPUT_EVENT">
Like mouse events, keyboard events are created by the device and passed to
		IrrlichtDevice::postEventFromUser. They take the same path as mouse events. 
</member>
        <member name="F:EET_MOUSE_INPUT_EVENT">
Mouse events are created by the device and passed to IrrlichtDevice::postEventFromUser
		in response to mouse input received from the operating system.
		Mouse events are first passed to the user receiver, then to the GUI environment and its elements,
		then finally the input receiving scene manager where it is passed to the active camera.

</member>
        <member name="F:EET_GUI_EVENT">
GUI events are created by the GUI environment or the GUI elements in response
		to mouse or keyboard events. When a GUI element receives an event it will either
		process it and return true, or pass the event to its parent. If an event is not absorbed
		before it reaches the root element then it will then be passed to the user receiver. 
</member>
        <member name="M:irr.ILogger.log(System.Char!System.Runtime.CompilerServices.IsConst*,irr.ELOG_LEVEL)">
\param text: Text to print out.
	\param ll: Log level of the text. If the text is an error, set
	it to ELL_ERROR, if it is warning set it to ELL_WARNING, and if it
	is just an informational text, set it to ELL_INFORMATION. Texts are
	filtered with these levels. If you want to be a text displayed,
	independent on what level filter is set, use ELL_NONE. 
</member>
        <member name="M:irr.ILogger.log(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,irr.ELOG_LEVEL)">
\param text: Text to print out.
	\param hint: Additional info. This string is added after a " :" to the
	string.
	\param ll: Log level of the text. If the text is an error, set
	it to ELL_ERROR, if it is warning set it to ELL_WARNING, and if it
	is just an informational text, set it to ELL_INFORMATION. Texts are
	filtered with these levels. If you want to be a text displayed,
	independent on what level filter is set, use ELL_NONE. 
</member>
        <member name="M:irr.ILogger.log(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.ELOG_LEVEL)">
\param text: Text to print out.
	\param hint: Additional info. This string is added after a " :" to the
	string.
	\param ll: Log level of the text. If the text is an error, set
	it to ELL_ERROR, if it is warning set it to ELL_WARNING, and if it
	is just an informational text, set it to ELL_INFORMATION. Texts are
	filtered with these levels. If you want to be a text displayed,
	independent on what level filter is set, use ELL_NONE. 
</member>
        <member name="M:irr.ILogger.log(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,irr.ELOG_LEVEL)">
\param text: Text to print out.
	\param ll: Log level of the text. If the text is an error, set
	it to ELL_ERROR, if it is warning set it to ELL_WARNING, and if it
	is just an informational text, set it to ELL_INFORMATION. Texts are
	filtered with these levels. If you want to be a text displayed,
	independent on what level filter is set, use ELL_NONE. 
</member>
        <member name="M:irr.ILogger.setLogLevel(irr.ELOG_LEVEL)">
With this value, texts which are sent to the logger are filtered
	out. For example setting this value to ELL_WARNING, only warnings and
	errors are printed out. Setting it to ELL_INFORMATION, which is the
	default setting, warnings, errors and informational texts are printed
	out.
	\param ll: new log level filter value. 
</member>
        <member name="M:irr.io.IAttributes.getAttributeAsEnumeration(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.Int32)">
\param index: Index value, must be between 0 and getAttributeCount()-1.
	\param enumerationLiteralsToUse: Use these enumeration literals to get
	the index value instead of the set ones. This is useful when the
	attribute list maybe was read from an xml file, and only contains the
	enumeration string, but no information about its index.
	\param defaultNotFound Value returned when the attribute referenced by the index was not found.
	\return Returns value of the attribute previously set by setAttribute()

</member>
        <member name="M:irr.io.IAttributes.getAttributeAsEnumeration(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.Int32)">
\param attributeName: Name of the attribute to get.
	\param enumerationLiteralsToUse: Use these enumeration literals to get
	the index value instead of the set ones. This is useful when the
	attribute list maybe was read from an xml file, and only contains the
	enumeration string, but no information about its index.
	\return Returns value of the attribute previously set by setAttribute()

</member>
        <member name="M:irr.io.IAttributes.getAttributeAsBinaryData(System.Int32,System.Void*,System.Int32)">
\param index: Index value, must be between 0 and getAttributeCount()-1.
	\param outData Pointer to buffer where data shall be stored.
	\param maxSizeInBytes Maximum number of bytes to write into outData.

</member>
        <member name="M:irr.io.IAttributes.getAttributeAsBinaryData(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
\param attributeName: Name of the attribute to get.
	\param outData Pointer to buffer where data shall be stored.
	\param maxSizeInBytes Maximum number of bytes to write into outData.

</member>
        <member name="M:irr.io.IAttributeExchangingObject.deserializeAttributes(irr.io.IAttributes*,irr.io.SAttributeReadWriteOptions*)">
Implement this to set the attributes of your scene node animator for
	scripting languages, editors, debuggers or xml deserialization purposes. 
</member>
        <member name="M:irr.io.IAttributeExchangingObject.serializeAttributes(irr.io.IAttributes*,irr.io.SAttributeReadWriteOptions*)">
Implement this to expose the attributes of your scene node animator for
	scripting languages, editors, debuggers or xml serialization purposes. 
</member>
        <member name="T:irr.scene.SMD3QuaternionTag">
Basically its an alternate way to describe a transformation. 
</member>
        <member name="M:irr.core.quaternion.fromAngleAxis(System.Single,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Axis must be unit length.
		The quaternion representing the rotation is
		q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k).
		\param angle Rotation Angle in radians.
		\param axis Rotation axis. 
</member>
        <member name="M:irr.core.quaternion.slerp(irr.core.quaternion,irr.core.quaternion,System.Single,System.Single)">
\param q1 First quaternion to be interpolated.
		\param q2 Second quaternion to be interpolated.
		\param time Progress of interpolation. For time=0 the result is
		q1, for time=1 the result is q2. Otherwise interpolation
		between q1 and q2.
		\param threshold To avoid inaccuracies at the end (time=1) the
		interpolation switches to linear interpolation at some point.
		This value defines how much of the remaining interpolation will
		be calculated with lerp. Everything from 1-threshold up will be
		linear interpolation.

</member>
        <member name="M:irr.core.quaternion.lerp(irr.core.quaternion,irr.core.quaternion,System.Single)">
\param q1 First quaternion to be interpolated.
		\param q2 Second quaternion to be interpolated.
		\param time Progress of interpolation. For time=0 the result is
		q1, for time=1 the result is q2. Otherwise interpolation
		between q1 and q2.

</member>
        <member name="T:irr.core.quaternion">
It provides cheap combinations and avoids gimbal locks.
Also useful for interpolations. 
</member>
        <member name="M:irr.video.IVideoDriver.queryTextureFormat(irr.video.ECOLOR_FORMAT)">
\return True if the format is available, false if not. 
</member>
        <member name="M:irr.video.IVideoDriver.convertColor(System.Void!System.Runtime.CompilerServices.IsConst*,irr.video.ECOLOR_FORMAT,System.Int32,System.Void*,irr.video.ECOLOR_FORMAT)">
Convert an image (as array of pixels) from source to destination
		array, thereby converting the color format. The pixel size is
		determined by the color formats.
		\param sP Pointer to source
		\param sF Color format of source
		\param sN Number of pixels to convert, both array must be large enough
		\param dP Pointer to destination
		\param dF Color format of destination

</member>
        <member name="M:irr.video.IVideoDriver.setAllowZWriteOnTransparent(System.Boolean)">
Passes the global material flag AllowZWriteOnTransparent.
		Use the SceneManager attribute to set this value from your app.
		\param flag Default behavior is to disable ZWrite, i.e. false. 
</member>
        <member name="M:irr.video.IVideoDriver.setAmbientLight(irr.video.SColorf!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The ambient color is set in the scene manager, see
		scene::ISceneManager::setAmbientLight().
		\param color New color of the ambient light. 
</member>
        <member name="M:irr.video.IVideoDriver.enableMaterial2D(System.Boolean)">
\param enable Flag which tells whether the material shall be
		enabled or disabled. 
</member>
        <member name="M:irr.video.IVideoDriver.getMaterial2D">
The 2d override material allows to alter certain render
		states of the 2d methods. Not all members of SMaterial are
		honored, especially not MaterialType and Textures. Moreover,
		the zbuffer is always ignored, and lighting is always off. All
		other flags can be changed, though some might have to effect
		in most cases.
		Please note that you have to enable/disable this effect with
		enableInitMaterial2D(). This effect is costly, as it increases
		the number of state changes considerably. Always reset the
		values when done.
		\return Material reference which should be altered to reflect
		the new settings.

</member>
        <member name="M:irr.video.IVideoDriver.getOverrideMaterial">
Depending on the enable flags, values from this Material
		are used to override those of local materials of some
		meshbuffer being rendered.
		\return Reference to the Override Material. 
</member>
        <member name="M:irr.video.IVideoDriver.setMinHardwareBufferVertexCount(System.UInt32)">
\param count Number of vertices to set as minimum. 
</member>
        <member name="M:irr.video.IVideoDriver.enableClipPlane(System.UInt32,System.Boolean)">
There are at least 6 clipping planes available for the user
		to set at will.
		\param index The plane index. Must be between 0 and
		MaxUserClipPlanes.
		\param enable If true, enable the clipping plane else disable
		it. 
</member>
        <member name="M:irr.video.IVideoDriver.setClipPlane(System.UInt32,irr.core.plane3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
There are at least 6 clipping planes available for the user
		to set at will.
		\param index The plane index. Must be between 0 and
		MaxUserClipPlanes.
		\param plane The plane itself.
		\param enable If true, enable the clipping plane else disable
		it.
		\return True if the clipping plane is usable. 
</member>
        <member name="M:irr.video.IVideoDriver.findTexture(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Works similar to getTexture(), but does not load the texture
		if it is not currently loaded.
		\param filename Name of the texture.
		\return Pointer to loaded texture, or 0 if not found. 
</member>
        <member name="M:irr.video.IVideoDriver.createScreenShot(irr.video.ECOLOR_FORMAT,irr.video.E_RENDER_TARGET)">
\return An image created from the last rendered frame. 
</member>
        <member name="M:irr.video.IVideoDriver.clearZBuffer">
Note that you usually need not to call this method, as it
		is automatically done in IVideoDriver::beginScene() or
		IVideoDriver::setRenderTarget() if you enable zBuffer. But if
		you have to render some special things, you can clear the
		zbuffer during the rendering process with this method any time.

</member>
        <member name="M:irr.video.IVideoDriver.getGPUProgrammingServices">
\return Pointer to the IGPUProgrammingServices. Returns 0
		if the video driver does not support this. For example the
		Software driver and the Null driver will always return 0. 
</member>
        <member name="M:irr.video.IVideoDriver.getDriverType">
\return Type of driver. 
</member>
        <member name="M:irr.video.IVideoDriver.getExposedVideoData">
This method should only be used if the engine should be
		extended without having to modify the source of the engine.
		\return Collection of device dependent pointers. 
</member>
        <member name="M:irr.video.IVideoDriver.fillMaterialStructureFromAttributes(irr.video.SMaterial*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.io.IAttributes*)">
Please note that for setting material types of the
		material, the video driver will need to query the material
		renderers for their names, so all non built-in materials must
		have been created before calling this method.
		\param outMaterial The material to set the properties for.
		\param attributes The attributes to read from. 
</member>
        <member name="M:irr.video.IVideoDriver.createAttributesFromMaterial(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.io.SAttributeReadWriteOptions*)">
This method is useful for serialization and more.
		Please note that the video driver will use the material
		renderer names from getMaterialRendererName() to write out the
		material type name, so they should be set before.
		\param material The material to serialize.
		\param options Additional options which might influence the
		serialization.
		\return The io::IAttributes container holding the material
		properties. 
</member>
        <member name="M:irr.video.IVideoDriver.swapMaterialRenderers(System.UInt32,System.UInt32,System.Boolean)">
Swap the IMaterialRenderers responsible for rendering specific
		 material-id's. This means every SMaterial using a MaterialType
		 with one of the indices involved here will now render differently.
		 \param idx1 First material index to swap. It must already exist or nothing happens.
		 \param idx2 Second material index to swap. It must already exist or nothing happens.
		 \param swapNames When true the renderer names also swap
		                  When false the names will stay at the original index 
</member>
        <member name="M:irr.video.IVideoDriver.setMaterialRendererName(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Will have no effect on built-in material renderers.
		\param idx: Id of the material renderer. Can be a value of the
		E_MATERIAL_TYPE enum or a value which was returned by
		addMaterialRenderer().
		\param name: New name of the material renderer. 
</member>
        <member name="M:irr.video.IVideoDriver.getMaterialRendererName(System.UInt32)">
This string can, e.g., be used to test if a specific
		renderer already has been registered/created, or use this
		string to store data about materials: This returned name will
		be also used when serializing materials.
		\param idx Id of the material renderer. Can be a value of the
		E_MATERIAL_TYPE enum or a value which was returned by
		addMaterialRenderer().
		\return String with the name of the renderer, or 0 if not
		exisiting 
</member>
        <member name="M:irr.video.IVideoDriver.getMaterialRendererCount">
\return Amount of currently available material renderers. 
</member>
        <member name="M:irr.video.IVideoDriver.getMaterialRenderer(System.UInt32)">
\param idx Id of the material renderer. Can be a value of
		the E_MATERIAL_TYPE enum or a value which was returned by
		addMaterialRenderer().
		\return Pointer to material renderer or null if not existing. 
</member>
        <member name="M:irr.video.IVideoDriver.addMaterialRenderer(irr.video.IMaterialRenderer*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Use this method to extend the VideoDriver with new material
		types. To extend the engine using this method do the following:
		Derive a class from IMaterialRenderer and override the methods
		you need. For setting the right renderstates, you can try to
		get a pointer to the real rendering device using
		IVideoDriver::getExposedVideoData(). Add your class with
		IVideoDriver::addMaterialRenderer(). To use an object being
		displayed with your new material, set the MaterialType member of
		the SMaterial struct to the value returned by this method.
		If you simply want to create a new material using vertex and/or
		pixel shaders it would be easier to use the
		video::IGPUProgrammingServices interface which you can get
		using the getGPUProgrammingServices() method.
		\param renderer A pointer to the new renderer.
		\param name Optional name for the material renderer entry.
		\return The number of the material type which can be set in
		SMaterial::MaterialType to use the renderer. -1 is returned if
		an error occurred. For example if you tried to add an material
		renderer to the software renderer or the null device, which do
		not accept material renderers. 
</member>
        <member name="M:irr.video.IVideoDriver.OnResize(irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Used to notify the driver that the window was resized.
		Usually, there is no need to call this method. 
</member>
        <member name="M:irr.video.IVideoDriver.createImage(irr.video.ITexture*,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param texture Texture to copy to the new image in part.
\param pos Position of rectangle to copy.
\param size Extents of rectangle to copy.
\return The created image.
If you no longer need the image, you should call IImage::drop().
See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.createImage(irr.video.IImage*,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\deprecated Create an empty image and use copyTo(). This method may be removed by Irrlicht 1.9.
		\param imageToCopy Image to copy to the new image in part.
		\param pos Position of rectangle to copy.
		\param size Extents of rectangle to copy.
		\return The created image.
		If you no longer need the image, you should call IImage::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.createImage(irr.video.ECOLOR_FORMAT,irr.video.IImage*)">
\deprecated Create an empty image and use copyTo(). This method may be removed by Irrlicht 1.9.
		\param format Desired color format of the image.
		\param imageToCopy Image to copy to the new image.
		\return The created image.
		If you no longer need the image, you should call IImage::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.createImage(irr.video.ECOLOR_FORMAT,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param format Desired color format of the image.
\param size Size of the image to create.
\return The created image.
If you no longer need the image, you should call IImage::drop().
See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.createImageFromData(irr.video.ECOLOR_FORMAT,irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.Boolean)">
No hardware texture will be created for this image. This
		method is useful for example if you want to read a heightmap
		for a terrain renderer.
		\param format Desired color format of the texture
		\param size Desired size of the image
		\param data A byte array with pixel color information
		\param ownForeignMemory If true, the image will use the data
		pointer directly and own it afterward. If false, the memory
		will by copied internally.
		\param deleteMemory Whether the memory is deallocated upon
		destruction.
		\return The created image.
		If you no longer need the image, you should call IImage::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.writeImageToFile(irr.video.IImage*,irr.io.IWriteFile*,System.UInt32)">
Requires that there is a suitable image writer registered
		for writing the image.
		\param image Image to write.
		\param file  An already open io::IWriteFile object. The name
		will be used to determine the appropriate image writer to use.
		\param param Control parameter for the backend (e.g. compression
		level).
		\return True on successful write. 
</member>
        <member name="M:irr.video.IVideoDriver.writeImageToFile(irr.video.IImage*,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Requires that there is a suitable image writer registered
		for writing the image.
		\param image Image to write.
		\param filename Name of the file to write.
		\param param Control parameter for the backend (e.g. compression
		level).
		\return True on successful write. 
</member>
        <member name="M:irr.video.IVideoDriver.createImageFromFile(irr.io.IReadFile*)">
No hardware texture will be created for this image. This
		method is useful for example if you want to read a heightmap
		for a terrain renderer.
		\param file File from which the image is created.
		\return The created image.
		If you no longer need the image, you should call IImage::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.createImageFromFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
No hardware texture will be created for this image. This
		method is useful for example if you want to read a heightmap
		for a terrain renderer.
		\param filename Name of the file from which the image is
		created.
		\return The created image.
		If you no longer need the image, you should call IImage::drop().
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.createImagesFromFile(irr.io.IReadFile*,irr.video.E_TEXTURE_TYPE*)">
No hardware texture will be created for those images. This
		method is useful for example if you want to read a heightmap
		for a terrain renderer.
		\param file File from which the image is created.
		\param type Pointer to E_TEXTURE_TYPE where a recommended type of the texture will be stored.
		\return The array of created images.
		If you no longer need those images, you should call IImage::drop() on each of them.
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.createImagesFromFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.E_TEXTURE_TYPE*)">
No hardware texture will be created for those images. This
		method is useful for example if you want to read a heightmap
		for a terrain renderer.
		\param filename Name of the file from which the images are created.
		\param type Pointer to E_TEXTURE_TYPE where a recommended type of the texture will be stored.
		\return The array of created images.
		If you no longer need those images, you should call IImage::drop() on each of them.
		See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.getTextureCreationFlag(irr.video.E_TEXTURE_CREATION_FLAG)">
You can change this value using setTextureCreationFlag().
		\param flag Texture creation flag.
		\return The current texture creation flag enabled mode. 
</member>
        <member name="M:irr.video.IVideoDriver.setTextureCreationFlag(irr.video.E_TEXTURE_CREATION_FLAG,System.Boolean)">
These flags define how textures should be created. By
		changing this value, you can influence for example the speed of
		rendering a lot. But please note that the video drivers take
		this value only as recommendation. It could happen that you
		enable the ETCF_ALWAYS_16_BIT mode, but the driver still creates
		32 bit textures.
		\param flag Texture creation flag.
		\param enabled Specifies if the given flag should be enabled or
		disabled. 
</member>
        <member name="M:irr.video.IVideoDriver.getMaximalPrimitiveCount">
(mostly vertices) which the device is able to render with
		one drawVertexPrimitiveList call.
		\return Maximum amount of primitives. 
</member>
        <member name="M:irr.video.IVideoDriver.addExternalImageWriter(irr.video.IImageWriter*)">
This is useful if the Irrlicht Engine should be able to
		write textures of currently unsupported file formats (e.g
		.gif). The IImageWriter only needs to be implemented for
		writing this file format. A pointer to the implementation can
		be passed to the engine using this method.
		\param writer: Pointer to the external writer created. 
</member>
        <member name="M:irr.video.IVideoDriver.addExternalImageLoader(irr.video.IImageLoader*)">
This is useful if the Irrlicht Engine should be able to load
		textures of currently unsupported file formats (e.g. gif). The
		IImageLoader only needs to be implemented for loading this file
		format. A pointer to the implementation can be passed to the
		engine using this method.
		\param loader Pointer to the external loader created. 
</member>
        <member name="M:irr.video.IVideoDriver.getName">
\return Returns the name of the video driver, e.g. in case
		of the Direct3D8 driver, it would return "Direct3D 8.1". 
</member>
        <member name="M:irr.video.IVideoDriver.getDynamicLight(System.UInt32)">
\param idx Zero based index of the light. Must be 0 or
		greater and smaller than IVideoDriver::getDynamicLightCount.
		\return Light data. 
</member>
        <member name="M:irr.video.IVideoDriver.getDynamicLightCount">
\return Amount of dynamic lights currently set 
</member>
        <member name="M:irr.video.IVideoDriver.getMaximalDynamicLightAmount">
\return Maximal amount of dynamic lights. 
</member>
        <member name="M:irr.video.IVideoDriver.getPrimitiveCountDrawn(System.UInt32)">
Together with getFPS() very useful method for statistics.
		\param mode Defines if the primitives drawn are accumulated or
		counted per frame.
		\return Amount of primitives drawn in the last frame. 
</member>
        <member name="M:irr.video.IVideoDriver.getFPS">
This value is updated approximately every 1.5 seconds and
		is only intended to provide a rough guide to the average frame
		rate. It is not suitable for use in performing timing
		calculations or framerate independent movement.
		\return Approximate amount of frames per second drawn. 
</member>
        <member name="M:irr.video.IVideoDriver.getCurrentRenderTargetSize">
This method will return the screen size if the driver
		doesn't support render to texture, or if the current render
		target is the screen.
		\return Size of render target or screen/window 
</member>
        <member name="M:irr.video.IVideoDriver.getScreenSize">
\return Size of screen or render window. 
</member>
        <member name="M:irr.video.IVideoDriver.getColorFormat">
\return Color format of the color buffer. 
</member>
        <member name="M:irr.video.IVideoDriver.setFog(irr.video.SColor,irr.video.E_FOG_TYPE,System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
These are global values attached to each 3d object rendered,
		which has the fog flag enabled in its material.
		\param color Color of the fog
		\param fogType Type of fog used
		\param start Only used in linear fog mode (linearFog=true).
		Specifies where fog starts.
		\param end Only used in linear fog mode (linearFog=true).
		Specifies where fog ends.
		\param density Only used in exponential fog mode
		(linearFog=false). Must be a value between 0 and 1.
		\param pixelFog Set this to false for vertex fog, and true if
		you want per-pixel fog.
		\param rangeFog Set this to true to enable range-based vertex
		fog. The distance from the viewer is used to compute the fog,
		not the z-coordinate. This is better, but slower. This might not
		be available with all drivers and fog settings. 
</member>
        <member name="M:irr.video.IVideoDriver.drawMeshBufferNormals(irr.scene.IMeshBuffer!System.Runtime.CompilerServices.IsConst*,System.Single,irr.video.SColor)">
\param mb Buffer to draw the normals of
		\param length length scale factor of the normals
		\param color Color the normals are rendered with

</member>
        <member name="M:irr.video.IVideoDriver.drawMeshBuffer(irr.scene.IMeshBuffer!System.Runtime.CompilerServices.IsConst*)">
\param mb Buffer to draw 
</member>
        <member name="M:irr.video.IVideoDriver.drawStencilShadow(System.Boolean,irr.video.SColor,irr.video.SColor,irr.video.SColor,irr.video.SColor)">
After the shadow volume has been drawn into the stencil
		buffer using IVideoDriver::drawStencilShadowVolume(), use this
		to draw the color of the shadow.
		Please note that the code for the opengl version of the method
		is based on free code sent in by Philipp Dortmann, lots of
		thanks go to him!
		\param clearStencilBuffer Set this to false, if you want to
		draw every shadow with the same color, and only want to call
		drawStencilShadow() once after all shadow volumes have been
		drawn. Set this to true, if you want to paint every shadow with
		its own color.
		\param leftUpEdge Color of the shadow in the upper left corner
		of screen.
		\param rightUpEdge Color of the shadow in the upper right
		corner of screen.
		\param leftDownEdge Color of the shadow in the lower left
		corner of screen.
		\param rightDownEdge Color of the shadow in the lower right
		corner of screen. 
</member>
        <member name="M:irr.video.IVideoDriver.drawStencilShadowVolume(irr.core.array&lt;irr.core.vector3d&lt;System.Single&gt;,irr.core.irrAllocator&lt;irr.core.vector3d&lt;System.Single&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.UInt32)">
To draw a stencil shadow, do this: First, draw all geometry.
		Then use this method, to draw the shadow volume. Then, use
		IVideoDriver::drawStencilShadow() to visualize the shadow.
		Please note that the code for the opengl version of the method
		is based on free code sent in by Philipp Dortmann, lots of
		thanks go to him!
		\param triangles Array of 3d vectors, specifying the shadow
		volume.
		\param zfail If set to true, zfail method is used, otherwise
		zpass.
		\param debugDataVisible The debug data that is enabled for this
		shadow node

</member>
        <member name="M:irr.video.IVideoDriver.draw2DPolygon(irr.core.vector2d&lt;System.Int32&gt;,System.Single,irr.video.SColor,System.Int32)">
This method can be used to draw circles, but also
		triangles, tetragons, pentagons, hexagons, heptagons, octagons,
		enneagons, decagons, hendecagons, dodecagon, triskaidecagons,
		etc. I think you'll got it now. And all this by simply
		specifying the vertex count. Welcome to the wonders of
		geometry.
		\param center Position of center of circle (pixels).
		\param radius Radius of circle in pixels.
		\param color Color of the circle.
		\param vertexCount Amount of vertices of the polygon. Specify 2
		to draw a line, 3 to draw a triangle, 4 for tetragons and a lot
		(&gt;10) for nearly a circle. 
</member>
        <member name="M:irr.video.IVideoDriver.drawPixel(System.UInt32,System.UInt32,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param x The x-position of the pixel.
		\param y The y-position of the pixel.
		\param color Color of the pixel to draw. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DLine(irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor)">
In theory both start and end will be included in coloring.
		BUG: Currently hardware drivers (d3d/opengl) ignore the last pixel
		(they use the so called "diamond exit rule" for drawing lines).
		\param start Screen coordinates of the start of the line
		in pixels.
		\param end Screen coordinates of the start of the line in
		pixels.
		\param color Color of the line to draw. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DRectangleOutline(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor)">
\param pos Position of the rectangle.
		\param color Color of the rectangle to draw. The alpha component
		specifies how transparent the rectangle outline will be. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DRectangle(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor,irr.video.SColor,irr.video.SColor,irr.video.SColor,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
\param colorLeftUp Color of the upper left corner to draw.
		The alpha component will not be ignored and specifies how
		transparent the rectangle will be.
		\param colorRightUp Color of the upper right corner to draw.
		The alpha component will not be ignored and specifies how
		transparent the rectangle will be.
		\param colorLeftDown Color of the lower left corner to draw.
		The alpha component will not be ignored and specifies how
		transparent the rectangle will be.
		\param colorRightDown Color of the lower right corner to draw.
		The alpha component will not be ignored and specifies how
		transparent the rectangle will be.
		\param pos Position of the rectangle.
		\param clip Pointer to rectangle against which the rectangle
		will be clipped. If the pointer is null, no clipping will be
		performed. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DRectangle(irr.video.SColor,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*)">
\param color Color of the rectangle to draw. The alpha
		component will not be ignored and specifies how transparent the
		rectangle will be.
		\param pos Position of the rectangle.
		\param clip Pointer to rectangle against which the rectangle
		will be clipped. If the pointer is null, no clipping will be
		performed. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DImage(irr.video.ITexture!System.Runtime.CompilerServices.IsConst*,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Boolean)">
Suggested and first implemented by zola.
		\param texture The texture to draw from
		\param destRect The rectangle to draw into
		\param sourceRect The rectangle denoting a part of the texture
		\param clipRect Clips the destination rectangle (may be 0)
		\param colors Array of 4 colors denoting the color values of
		the corners of the destRect
		\param useAlphaChannelOfTexture True if alpha channel will be
		blended. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DImageBatch(irr.video.ITexture!System.Runtime.CompilerServices.IsConst*,irr.core.array&lt;irr.core.vector2d&lt;System.Int32&gt;,irr.core.irrAllocator&lt;irr.core.vector2d&lt;System.Int32&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.array&lt;irr.core.rect&lt;System.Int32&gt;,irr.core.irrAllocator&lt;irr.core.rect&lt;System.Int32&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.video.SColor,System.Boolean)">
All drawings are clipped against clipRect (if != 0).
		The subtextures are defined by the array of sourceRects and are
		positioned using the array of positions.
		\param texture Texture to be drawn.
		\param positions Array of upper left 2d destinations where the
		images will be drawn.
		\param sourceRects Source rectangles of the image.
		\param clipRect Pointer to rectangle on the screen where the
		images are clipped to.
		If this pointer is 0 then the image is not clipped.
		\param color Color with which the image is drawn.
		Note that the alpha component is used. If alpha is other than
		255, the image will be transparent.
		\param useAlphaChannelOfTexture: If true, the alpha channel of
		the texture is used to draw the image. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DImageBatch(irr.video.ITexture!System.Runtime.CompilerServices.IsConst*,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.array&lt;irr.core.rect&lt;System.Int32&gt;,irr.core.irrAllocator&lt;irr.core.rect&lt;System.Int32&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.array&lt;System.Int32,irr.core.irrAllocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.video.SColor,System.Boolean)">
The images are drawn beginning at pos and concatenated in
		one line. All drawings are clipped against clipRect (if != 0).
		The subtextures are defined by the array of sourceRects and are
		chosen by the indices given.
		\param texture Texture to be drawn.
		\param pos Upper left 2d destination position where the image
		will be drawn.
		\param sourceRects Source rectangles of the image.
		\param indices List of indices which choose the actual
		rectangle used each time.
		\param kerningWidth Offset to Position on X
		\param clipRect Pointer to rectangle on the screen where the
		image is clipped to.
		If this pointer is 0 then the image is not clipped.
		\param color Color with which the image is drawn.
		Note that the alpha component is used. If alpha is other than
		255, the image will be transparent.
		\param useAlphaChannelOfTexture: If true, the alpha channel of
		the texture is used to draw the image. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DImage(irr.video.ITexture!System.Runtime.CompilerServices.IsConst*,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,irr.video.SColor,System.Boolean)">
(if color is other than
		Color(255,255,255,255)) and the alpha channel of the texture.
		\param texture Texture to be drawn.
		\param destPos Upper left 2d destination position where the
		image will be drawn.
		\param sourceRect Source rectangle in the image.
		\param clipRect Pointer to rectangle on the screen where the
		image is clipped to.
		If this pointer is NULL the image is not clipped.
		\param color Color with which the image is drawn. If the color
		equals Color(255,255,255,255) it is ignored. Note that the
		alpha component is used: If alpha is other than 255, the image
		will be transparent.
		\param useAlphaChannelOfTexture: If true, the alpha channel of
		the texture is used to draw the image.
</member>
        <member name="M:irr.video.IVideoDriver.draw2DImage(irr.video.ITexture!System.Runtime.CompilerServices.IsConst*,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param texture Pointer to texture to use.
		\param destPos Upper left 2d destination position where the
		image will be drawn. 
</member>
        <member name="M:irr.video.IVideoDriver.draw3DBox(irr.core.aabbox3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor)">
This method simply calls draw3DLine for the edges of the
		box. Note that the box is drawn using the current transformation
		matrix and material. So if you need to draw it independently of
		the current transformation, use
		\code
		driver-&gt;setMaterial(someMaterial);
		driver-&gt;setTransform(video::ETS_WORLD, core::IdentityMatrix);
		\endcode
		for some properly set up material before drawing the box.
		\param box The axis aligned box to draw
		\param color Color to use while drawing the box. 
</member>
        <member name="M:irr.video.IVideoDriver.draw3DTriangle(irr.core.triangle3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor)">
This method calls drawVertexPrimitiveList for some triangles.
		This method works with all drivers because it simply calls
		drawVertexPrimitiveList, but it is hence not very fast.
		Note that the triangle is drawn using the current
		transformation matrix and material. So if you need to draw it
		independently of the current transformation, use
		\code
		driver-&gt;setMaterial(someMaterial);
		driver-&gt;setTransform(video::ETS_WORLD, core::IdentityMatrix);
		\endcode
		for some properly set up material before drawing the triangle.
		\param triangle The triangle to draw.
		\param color Color of the line. 
</member>
        <member name="M:irr.video.IVideoDriver.draw3DLine(irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor)">
For some implementations, this method simply calls
		drawVertexPrimitiveList for some triangles.
		Note that the line is drawn using the current transformation
		matrix and material. So if you need to draw the 3D line
		independently of the current transformation, use
		\code
		driver-&gt;setMaterial(someMaterial);
		driver-&gt;setTransform(video::ETS_WORLD, core::IdentityMatrix);
		\endcode
		for some properly set up material before drawing the line.
		Some drivers support line thickness set in the material.
		\param start Start of the 3d line.
		\param end End of the 3d line.
		\param color Color of the line. 
</member>
        <member name="M:irr.video.IVideoDriver.drawIndexedTriangleFan(irr.video.S3DVertexTangents!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Note that there may be at maximum 65536 vertices, because
		the index list is an array of 16 bit values each with a maximum
		value of 65536. If there are more than 65536 vertices in the
		list, results of this operation are not defined.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices.
		\param triangleCount Amount of Triangles. Usually amount of indices - 2. 
</member>
        <member name="M:irr.video.IVideoDriver.drawIndexedTriangleFan(irr.video.S3DVertex2TCoords!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Note that there may be at maximum 65536 vertices, because
		the index list is an array of 16 bit values each with a maximum
		value of 65536. If there are more than 65536 vertices in the
		list, results of this operation are not defined.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices.
		\param triangleCount Amount of Triangles. Usually amount of indices - 2. 
</member>
        <member name="M:irr.video.IVideoDriver.drawIndexedTriangleFan(irr.video.S3DVertex!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Note that there may be at maximum 65536 vertices, because
		the index list is an array of 16 bit values each with a maximum
		value of 65536. If there are more than 65536 vertices in the
		list, results of this operation are not defined.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices.
		\param triangleCount Amount of Triangles. Usually amount of indices - 2. 
</member>
        <member name="M:irr.video.IVideoDriver.drawIndexedTriangleList(irr.video.S3DVertexTangents!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Note that there may be at maximum 65536 vertices, because
		the index list is an array of 16 bit values each with a maximum
		value of 65536. If there are more than 65536 vertices in the
		list, results of this operation are not defined.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices.
		\param triangleCount Amount of Triangles. Usually amount of indices / 3. 
</member>
        <member name="M:irr.video.IVideoDriver.drawIndexedTriangleList(irr.video.S3DVertex2TCoords!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Note that there may be at maximum 65536 vertices, because
		the index list is an array of 16 bit values each with a maximum
		value of 65536. If there are more than 65536 vertices in the
		list, results of this operation are not defined.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices.
		\param triangleCount Amount of Triangles. Usually amount of indices / 3. 
</member>
        <member name="M:irr.video.IVideoDriver.drawIndexedTriangleList(irr.video.S3DVertex!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Note that there may be at maximum 65536 vertices, because
		the index list is an array of 16 bit values each with a maximum
		value of 65536. If there are more than 65536 vertices in the
		list, results of this operation are not defined.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices.
		\param triangleCount Amount of Triangles. Usually amount of indices / 3. 
</member>
        <member name="M:irr.video.IVideoDriver.draw2DVertexPrimitiveList(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,irr.video.E_VERTEX_TYPE,irr.scene.E_PRIMITIVE_TYPE,irr.video.E_INDEX_TYPE)">
Compared to the general (3d) version of this method, this
		one sets up a 2d render mode, and uses only x and y of vectors.
		Note that, depending on the index type, some vertices might be
		not accessible through the index list. The limit is at 65535
		vertices for 16bit indices. Please note that currently not all
		primitives are available for all drivers, and some might be
		emulated via triangle renders. This function is not available
		for the sw drivers.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices. These define the
		vertices used for each primitive. Depending on the pType,
		indices are interpreted as single objects (for point like
		primitives), pairs (for lines), triplets (for triangles), or
		quads.
		\param primCount Amount of Primitives
		\param vType Vertex type, e.g. video::EVT_STANDARD for S3DVertex.
		\param pType Primitive type, e.g. scene::EPT_TRIANGLE_FAN for a triangle fan.
		\param iType Index type, e.g. video::EIT_16BIT for 16bit indices. 
</member>
        <member name="M:irr.video.IVideoDriver.drawVertexPrimitiveList(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,irr.video.E_VERTEX_TYPE,irr.scene.E_PRIMITIVE_TYPE,irr.video.E_INDEX_TYPE)">
Note that, depending on the index type, some vertices might be not
		accessible through the index list. The limit is at 65535 vertices for 16bit
		indices. Please note that currently not all primitives are available for
		all drivers, and some might be emulated via triangle renders.
		\param vertices Pointer to array of vertices.
		\param vertexCount Amount of vertices in the array.
		\param indexList Pointer to array of indices. These define the vertices used
		for each primitive. Depending on the pType, indices are interpreted as single
		objects (for point like primitives), pairs (for lines), triplets (for
		triangles), or quads.
		\param primCount Amount of Primitives
		\param vType Vertex type, e.g. video::EVT_STANDARD for S3DVertex.
		\param pType Primitive type, e.g. scene::EPT_TRIANGLE_FAN for a triangle fan.
		\param iType Index type, e.g. video::EIT_16BIT for 16bit indices. 
</member>
        <member name="M:irr.video.IVideoDriver.getViewPort">
\return Rectangle of the current viewport. 
</member>
        <member name="M:irr.video.IVideoDriver.setViewPort(irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Every rendering operation is done into this new area.
		\param area: Rectangle defining the new area of rendering
		operations. 
</member>
        <member name="M:irr.video.IVideoDriver.setRenderTargetEx(irr.video.IRenderTarget*,System.UInt16,irr.video.SColor,System.Single,System.Byte)">
This will only work if the driver supports the
		EVDF_RENDER_TO_TARGET feature, which can be queried with
		queryFeature(). Please note that you cannot render 3D or 2D
		geometry with a render target as texture on it when you are rendering
		the scene into this render target at the same time. It is usually only
		possible to render into a texture between the
		IVideoDriver::beginScene() and endScene() method calls. If you need the
		best performance use this method instead of setRenderTarget.
		\param target Render target object.
		\param clearFlag A combination of the E_CLEAR_BUFFER_FLAG bit-flags.
		\param clearColor The clear color for the color buffer.
		\param clearDepth The clear value for the depth buffer.
		\param clearStencil The clear value for the stencil buffer.
		\return True if successful and false if not. 
</member>
        <member name="M:irr.video.IVideoDriver.makeNormalMapTexture(irr.video.ITexture*,System.Single)">
As input is considered to be a height map the texture is read like:
		- For a 32-bit texture only the red channel is regarded
		- For a 16-bit texture the rgb-values are averaged.
		Output channels red/green for X/Y and blue for up (Z).
		For a 32-bit texture we store additionally the height value in the 
		alpha channel. This value is used by the video::EMT_PARALLAX_MAP_SOLID 
		material and similar materials.
		On the borders the texture is considered to repeat.
		\param texture Height map texture which is converted to a normal map.
		\param amplitude Constant value by which the height
		information is multiplied.
</member>
        <member name="M:irr.video.IVideoDriver.makeColorKeyTexture(irr.video.ITexture*,irr.core.vector2d&lt;System.Int32&gt;,System.Boolean)">
This makes the texture fully transparent at the texels where
		the color key can be found when using for example draw2DImage
		with useAlphachannel==true.  The alpha of other texels is not modified.
		\param texture Texture whose alpha channel is modified.
		\param colorKeyPixelPos Position of a pixel with the color key
		color. Every texel with this color will become fully transparent as
		described above.
		\param zeroTexels \deprecated If set to true, then any texels that match
		the color key will have their color, as well as their alpha, set to zero
		(i.e. black). This behavior matches the legacy (buggy) behavior prior
		to release 1.5 and is provided for backwards compatibility only.
		This parameter may be removed by Irrlicht 1.9. 
</member>
        <member name="M:irr.video.IVideoDriver.makeColorKeyTexture(irr.video.ITexture*,irr.video.SColor,System.Boolean)">
This makes the texture fully transparent at the texels where
		this color key can be found when using for example draw2DImage
		with useAlphachannel==true.  The alpha of other texels is not modified.
		\param texture Texture whose alpha channel is modified.
		\param color Color key color. Every texel with this color will
		become fully transparent as described above. Please note that the
		colors of a texture may be converted when loading it, so the
		color values may not be exactly the same in the engine and for
		example in picture edit programs. To avoid this problem, you
		could use the makeColorKeyTexture method, which takes the
		position of a pixel instead a color value.
		\param zeroTexels \deprecated If set to true, then any texels that match
		the color key will have their color, as well as their alpha, set to zero
		(i.e. black). This behavior matches the legacy (buggy) behavior prior
		to release 1.5 and is provided for backwards compatibility only.
		This parameter may be removed by Irrlicht 1.9. 
</member>
        <member name="M:irr.video.IVideoDriver.getOcclusionQueryResult(irr.scene.ISceneNode*)">
Return value is the number of visible pixels/fragments.
		The value is a safe approximation, i.e. can be larger than the
		actual value of pixels. 
</member>
        <member name="M:irr.video.IVideoDriver.updateAllOcclusionQueries(System.Boolean)">
If the query shall not block, set the flag to false.
		Update might not occur in this case, though 
</member>
        <member name="M:irr.video.IVideoDriver.updateOcclusionQuery(irr.scene.ISceneNode*,System.Boolean)">
If the query shall not block, set the flag to false.
		Update might not occur in this case, though 
</member>
        <member name="M:irr.video.IVideoDriver.runAllOcclusionQueries(System.Boolean)">
If the meshes shall not be rendered visible, use
		overrideMaterial to disable the color and depth buffer. 
</member>
        <member name="M:irr.video.IVideoDriver.runOcclusionQuery(irr.scene.ISceneNode*,System.Boolean)">
If the mesh shall not be rendered visible, use
		overrideMaterial to disable the color and depth buffer. 
</member>
        <member name="M:irr.video.IVideoDriver.addOcclusionQuery(irr.scene.ISceneNode*,irr.scene.IMesh!System.Runtime.CompilerServices.IsConst*)">
Use node for identification and mesh for occlusion test. 
</member>
        <member name="M:irr.video.IVideoDriver.removeAllTextures">
This method can free a lot of memory!
		Please note that after calling this, the pointer to the
		ITexture may no longer be valid, if it was not grabbed before
		by other parts of the engine for storing it longer. So it is a
		good idea to set all materials which are using this texture to
		0 or another texture first. 
</member>
        <member name="M:irr.video.IVideoDriver.removeTexture(irr.video.ITexture*)">
This method can free a lot of memory!
		Please note that after calling this, the pointer to the
		ITexture may no longer be valid, if it was not grabbed before
		by other parts of the engine for storing it longer. So it is a
		good idea to set all materials which are using this texture to
		0 or another texture first.
		\param texture Texture to delete from the engine cache. 
</member>
        <member name="M:irr.video.IVideoDriver.addRenderTargetTextureCubemap(System.UInt32!System.Runtime.CompilerServices.IsConst,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.ECOLOR_FORMAT!System.Runtime.CompilerServices.IsConst)">
NOTE: Only supported on D3D9 so far.
		\param sideLen Length of one cubemap side.
		\param name A name for the texture. Later calls of getTexture() with this name will return this texture.
		The name can _not_ be empty.
		\param format The color format of the render target. Floating point formats are supported.
		\return Pointer to the created texture or 0 if the texture
		could not be created. This pointer should not be dropped. See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.addRenderTargetTexture(irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.ECOLOR_FORMAT!System.Runtime.CompilerServices.IsConst)">
\param size Size of the texture, in pixels. Width and
		height should be a power of two (e.g. 64, 128, 256, 512, ...)
		and it should not be bigger than the backbuffer, because it
		shares the zbuffer with the screen buffer.
		\param name A name for the texture. Later calls of getTexture() with this name will return this texture.
		The name can _not_ be empty.
		\param format The color format of the render target. Floating point formats are supported.
		\return Pointer to the created texture or 0 if the texture
		could not be created. This pointer should not be dropped. See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.addTextureCubemap(System.UInt32!System.Runtime.CompilerServices.IsConst,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.ECOLOR_FORMAT)">
\param sideLen diameter of one side of the cube
		\param name A name for the texture. Later calls of
		getTexture() with this name will return this texture.
		The name can _not_ be empty.
		\param format Desired color format of the texture. Please note
		that the driver may choose to create the texture in another
		color format.
		\return Pointer to the newly created texture. 	
</member>
        <member name="M:irr.video.IVideoDriver.addTextureCubemap(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.IImage*,irr.video.IImage*,irr.video.IImage*,irr.video.IImage*,irr.video.IImage*,irr.video.IImage*)">
\param name A name for the texture. Later calls of getTexture() with this name will return this texture.
		The name can _not_ be empty.
		\param imagePosX Image (positive X) the texture is created from.
		\param imageNegX Image (negative X) the texture is created from.
		\param imagePosY Image (positive Y) the texture is created from.
		\param imageNegY Image (negative Y) the texture is created from.
		\param imagePosZ Image (positive Z) the texture is created from.
		\param imageNegZ Image (negative Z) the texture is created from.
		\return Pointer to the newly created texture. This pointer should not be dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.addTexture(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.IImage*)">
\param name A name for the texture. Later calls of
		getTexture() with this name will return this texture.
		The name can _not_ be empty.
		\param image Image the texture is created from.
		\return Pointer to the newly created texture. This pointer
		should not be dropped. See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.video.IVideoDriver.addTexture(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.IImage*,System.Void*)">
\param name A name for the texture. Later calls of
		getTexture() with this name will return this texture.
		The name can _not_ be empty.
		\param image Image the texture is created from.
		\param mipmapData Optional pointer to a mipmaps data.
		If this parameter is not given, the mipmaps are derived from image.
		\return Pointer to the newly created texture. This pointer
		should not be dropped. See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.video.IVideoDriver.addTexture(irr.core.dimension2d&lt;System.UInt32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.ECOLOR_FORMAT)">
\param size: Size of the texture.
		\param name A name for the texture. Later calls to
		getTexture() with this name will return this texture.
		The name can _not_ be empty.
		\param format Desired color format of the texture. Please note
		that the driver may choose to create the texture in another
		color format.
		\return Pointer to the newly created texture. This pointer
		should not be dropped. See IReferenceCounted::drop() for more
		information. 
</member>
        <member name="M:irr.video.IVideoDriver.renameTexture(irr.video.ITexture*,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param texture Pointer to the texture to rename.
		\param newName New name for the texture. This should be a unique name. 
</member>
        <member name="M:irr.video.IVideoDriver.getTextureCount">
\return Amount of textures currently loaded 
</member>
        <member name="M:irr.video.IVideoDriver.getTextureByIndex(System.UInt32)">
\param index: Index of the texture, must be smaller than
		getTextureCount() Please note that this index might change when
		adding or removing textures
		\return Pointer to the texture, or 0 if the texture was not
		set or index is out of bounds. This pointer should not be
		dropped. See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.getTexture(irr.io.IReadFile*)">
Loads the texture from disk if it is not
		already loaded and generates mipmap levels if desired.
		Texture loading can be influenced using the
		setTextureCreationFlag() method. The texture can be in several
		imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD.
		\param file Pointer to an already opened file.
		\return Pointer to the texture, or 0 if the texture
		could not be loaded. This pointer should not be dropped. See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.getTexture(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Loads the texture from disk if it is not
		already loaded and generates mipmap levels if desired.
		Texture loading can be influenced using the
		setTextureCreationFlag() method. The texture can be in several
		imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD.
		\param filename Filename of the texture to be loaded.
		\return Pointer to the texture, or 0 if the texture
		could not be loaded. This pointer should not be dropped. See
		IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.video.IVideoDriver.setMaterial(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
All 3d drawing functions will draw geometry using this material thereafter.
		\param material: Material to be used from now on. 
</member>
        <member name="M:irr.video.IVideoDriver.getImageWriter(System.UInt32)">
\param n The index of the writer to retrieve. This parameter is an 0-based
		array index.
		\return A pointer to the specified writer, 0 if the index is incorrect. 
</member>
        <member name="M:irr.video.IVideoDriver.getImageWriterCount">
\return Number of image writers 
</member>
        <member name="M:irr.video.IVideoDriver.getImageLoader(System.UInt32)">
\param n The index of the loader to retrieve. This parameter is an 0-based
		array index.
		\return A pointer to the specified loader, 0 if the index is incorrect. 
</member>
        <member name="M:irr.video.IVideoDriver.getImageLoaderCount">
\return Number of image loaders 
</member>
        <member name="M:irr.video.IVideoDriver.getTransform(irr.video.E_TRANSFORMATION_STATE)">
\param state Transformation type to query
		\return Matrix describing the transformation. 
</member>
        <member name="M:irr.video.IVideoDriver.setTransform(irr.video.E_TRANSFORMATION_STATE,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param state Transformation type to be set, e.g. view,
		world, or projection.
		\param mat Matrix describing the transformation. 
</member>
        <member name="M:irr.video.IVideoDriver.checkDriverReset">
For d3d devices you will need to recreate the RTTs if the
		driver was reset. Should be queried right after beginScene().

</member>
        <member name="M:irr.video.IVideoDriver.getDriverAttributes">
The following names can be queried for the given types:
		MaxTextures (int) The maximum number of simultaneous textures supported by the driver. This can be less than the supported number of textures of the driver. Use _IRR_MATERIAL_MAX_TEXTURES_ to adapt the number.
		MaxSupportedTextures (int) The maximum number of simultaneous textures supported by the fixed function pipeline of the (hw) driver. The actual supported number of textures supported by the engine can be lower.
		MaxLights (int) Number of hardware lights supported in the fixed function pipeline of the driver, typically 6-8. Use light manager or deferred shading for more.
		MaxAnisotropy (int) Number of anisotropy levels supported for filtering. At least 1, max is typically at 16 or 32.
		MaxUserClipPlanes (int) Number of additional clip planes, which can be set by the user via dedicated driver methods.
		MaxAuxBuffers (int) Special render buffers, which are currently not really usable inside Irrlicht. Only supported by OpenGL
		MaxMultipleRenderTargets (int) Number of render targets which can be bound simultaneously. Rendering to MRTs is done via shaders.
		MaxIndices (int) Number of indices which can be used in one render call (i.e. one mesh buffer).
		MaxTextureSize (int) Dimension that a texture may have, both in width and height.
		MaxGeometryVerticesOut (int) Number of vertices the geometry shader can output in one pass. Only OpenGL so far.
		MaxTextureLODBias (float) Maximum value for LOD bias. Is usually at around 16, but can be lower on some systems.
		Version (int) Version of the driver. Should be Major*100+Minor
		ShaderLanguageVersion (int) Version of the high level shader language. Should be Major*100+Minor.
		AntiAlias (int) Number of Samples the driver uses for each pixel. 0 and 1 means anti aliasing is off, typical values are 2,4,8,16,32

</member>
        <member name="M:irr.video.IVideoDriver.disableFeature(irr.video.E_VIDEO_DRIVER_FEATURE,System.Boolean)">
Can also be used to enable the features again. It is not
		possible to enable unsupported features this way, though.
		\param feature Feature to disable.
		\param flag When true the feature is disabled, otherwise it is enabled. 
</member>
        <member name="M:irr.video.IVideoDriver.queryFeature(irr.video.E_VIDEO_DRIVER_FEATURE)">
Returns true if a feature is available
		\param feature Feature to query.
		\return True if the feature is available, false if not. 
</member>
        <member name="M:irr.video.IVideoDriver.endScene">
Applications must call this method after performing any
		rendering.
		\return False if failed and true if succeeded. 
</member>
        <member name="M:irr.video.IVideoDriver.beginScene(System.UInt16,irr.video.SColor,System.Single,System.Byte,irr.video.SExposedVideoData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;*)">
This method can clear the back- and the z-buffer.
		\param clearFlag A combination of the E_CLEAR_BUFFER_FLAG bit-flags.
		\param clearColor The clear color for the color buffer.
		\param clearDepth The clear value for the depth buffer.
		\param clearStencil The clear value for the stencil buffer.
		\param videoData Handle of another window, if you want the
		bitmap to be displayed on another window. If this is an empty
		element, everything will be displayed in the default window.
		Note: This feature is not fully implemented for all devices.
		\param sourceRect Pointer to a rectangle defining the source
		rectangle of the area to be presented. Set to null to present
		everything. Note: not implemented in all devices.
		\return False if failed. 
</member>
        <member name="T:irr.video.IVideoDriver">
This interface is one of the most important interfaces of
	the Irrlicht Engine: All rendering and texture manipulation is done with
	this interface. You are able to use the Irrlicht Engine by only
	invoking methods of this interface if you like to, although the
	irr::scene::ISceneManager interface provides a lot of powerful classes
	and methods to make the programmer's life easier.

</member>
        <member name="T:irr.video.E_RENDER_TARGET">
These render targets (besides 0 and 1) need not be supported by gfx cards 
</member>
        <member name="F:irr.video.SOverrideMaterial.Enabled">
The Scenemanager uses the EnablePass array and sets Enabled to
		true if the Override material is enabled in the current pass. 
</member>
        <member name="F:irr.video.SOverrideMaterial.EnablePasses">
OR'ed values from E_SCENE_NODE_RENDER_PASS. 
</member>
        <member name="F:irr.video.SOverrideMaterial.EnableFlags">
OR'ed values from E_MATERIAL_FLAGS. 
</member>
        <member name="T:irr.video.SExposedVideoData">
This data can be retrieved by IVideoDriver::getExposedVideoData(). Use this with caution.
This only should be used to make it possible to extend the engine easily without
modification of its source. Note that this structure does not contain any valid data, if
you are using the software or the null device.

</member>
        <member name="M:irr.video.ITexture.getTextureFormatFromFlags(System.UInt32)">
\return Either ETCF_ALWAYS_32_BIT, ETCF_ALWAYS_16_BIT,
	ETCF_OPTIMIZED_FOR_QUALITY, or ETCF_OPTIMIZED_FOR_SPEED. 
</member>
        <member name="M:irr.video.ITexture.isRenderTarget">
Render targets can be set as such in the video driver, in order to
	render a scene into the texture. Once unbound as render target, they can
	be used just as usual textures again.
	\return True if this is a render target, otherwise false. 
</member>
        <member name="M:irr.video.ITexture.hasMipMaps">
\return True if texture has MipMaps, else false. 
</member>
        <member name="M:irr.video.ITexture.getPitch">
The pitch is the amount of bytes used for a row of pixels in a
	texture.
	\return Pitch of texture in bytes. 
</member>
        <member name="M:irr.video.ITexture.getOriginalColorFormat">
When create textures from image data we will often use different color formats.
	For example depending on driver TextureCreationFlag's. 
	This can give you the original format which the image used to create the texture had	
</member>
        <member name="M:irr.video.ITexture.getColorFormat">
\return The color format of texture. 
</member>
        <member name="M:irr.video.ITexture.getDriverType">
This is the driver, which created the texture. This method is used
	internally by the video devices, to check, if they may use a texture
	because textures may be incompatible between different devices.
	\return Driver type of texture. 
</member>
        <member name="M:irr.video.ITexture.getSize">
\return The size of the texture. 
</member>
        <member name="M:irr.video.ITexture.getOriginalSize">
The texture is usually scaled, if it was created with an unoptimal
	size. For example if the size was not a power of two. This method
	returns the size of the texture it had before it was scaled. Can be
	useful when drawing 2d images on the screen, which should have the
	exact size of the original texture. Use ITexture::getSize() if you want
	to know the real size it has now stored in the system.
	\return The original size of the texture. 
</member>
        <member name="M:irr.video.ITexture.regenerateMipMapLevels(System.Void*,System.UInt32)">
Required after modifying the texture, usually after calling unlock().
	\param data Optional parameter to pass in image data which will be
	used instead of the previously stored or automatically generated mipmap
	data. The data has to be a continuous pixel data for all mipmaps until
	1x1 pixel. Each mipmap has to be half the width and height of the previous
	level. At least one pixel will be always kept.
	\param layer It informs a texture about layer which needs
	mipmaps regeneration. 
</member>
        <member name="M:irr.video.ITexture.unlock">
One should avoid to call unlock more than once before another lock.
	The last locked mip level will be unlocked. 
</member>
        <member name="M:irr.video.ITexture.lock(irr.video.E_TEXTURE_LOCK_MODE,System.UInt32,System.UInt32,irr.video.E_TEXTURE_LOCK_FLAGS)">
Locks the Texture and returns a pointer to access the
	pixels. After lock() has been called and all operations on the pixels
	are done, you must call unlock().
	Locks are not accumulating, hence one unlock will do for an arbitrary
	number of previous locks. You should avoid locking different levels without
	unlocking in between, though, because only the last level locked will be
	unlocked.
	The size of the i-th mipmap level is defined as max(getSize().Width&gt;&gt;i,1)
	and max(getSize().Height&gt;&gt;i,1)
	\param mode Specifies what kind of changes to the locked texture are
	allowed. Unspecified behavior will arise if texture is written in read
	only mode or read from in write only mode.
	Support for this feature depends on the driver, so don't rely on the
	texture being write-protected when locking with read-only, etc.
	\param mipmapLevel NOTE: Currently broken, sorry, we try if we can repair it for 1.9 release.
	Number of the mipmapLevel to lock. 0 is main texture.
	Non-existing levels will silently fail and return 0.
	\param layer It determines which cubemap face or texture array layer should be locked.
	\param lockFlags See E_TEXTURE_LOCK_FLAGS documentation.
	\return Returns a pointer to the pixel data. The format of the pixel can
	be determined by using getColorFormat(). 0 is returned, if
	the texture cannot be locked. 
</member>
        <member name="T:irr.video.ITexture">
An ITexture is created by an IVideoDriver by using IVideoDriver::addTexture
or IVideoDriver::getTexture. After that, the texture may only be used by this
VideoDriver. As you can imagine, textures of the DirectX and the OpenGL device
will, e.g., not be compatible. An exception is the Software device and the
NULL device, their textures are compatible. If you try to use a texture
created by one device with an other device, the device will refuse to do that
and write a warning or an error message to the output buffer.

</member>
        <member name="F:ETLF_FLIP_Y_UP_RTT">
Irrlicht usually has all textures with left-top as origin.
	And for drivers with a left-bottom origin coordinate system (OpenGL)
	Irrlicht modifies the texture-matrix in the fixed function pipeline to make
	the textures show up correctly (shader coders have to handle upside down 
	textures themselves).
	But rendertarget textures (RTT's) are written by drivers the way the 
	coordinate system of that driver works. So on OpenGL images tend to look 
	upside down (aka Y coordinate going up) on lock() when this flag isn't set.
	When the flag is set it will flip such textures on lock() to make them look
	like non-rtt textures (origin left-top). Note that this also means the texture
	will be uploaded flipped on unlock. So mostly you want to have this flag set 
	when you want to look at the texture or save it, but unset if you want to 
	upload it again to the card.
	If you disable this flag you get the memory just as it is on the graphic card.
	For backward compatibility reasons this flag is enabled by default. 
</member>
        <member name="F:ETLM_WRITE_ONLY">
The updated texture is uploaded to the GPU.
	Used for initializing the shader from the CPU. 
</member>
        <member name="F:ETLM_READ_ONLY">
Often used to read back shader generated textures. 
</member>
        <member name="F:ETCF_FORCE_32_BIT_DO_NOT_USE">
This flag is never used, it only forces the compiler to compile
	these enumeration values to 32 bit. 
</member>
        <member name="F:ETCF_ALLOW_MEMORY_COPY">
Enabling this makes calls to ITexture::lock a lot faster, but costs main memory.
	Currently only used in combination with OpenGL drivers.
	NOTE: Disabling this does not yet work correctly with alpha-textures.
	So the default is off for now (but might change with Irrlicht 1.9 if we get the alpha-troubles fixed).

</member>
        <member name="F:ETCF_ALLOW_NON_POWER_2">
BurningVideo can handle Non-Power-2 Textures in 2D (GUI), but not in 3D. 
</member>
        <member name="F:ETCF_NO_ALPHA_CHANNEL">
Discard any alpha layer and use non-alpha color format. 
</member>
        <member name="F:ETCF_CREATE_MIP_MAPS">
Automatically creates mip map levels for the textures. 
</member>
        <member name="F:ETCF_OPTIMIZED_FOR_SPEED">
Lets the driver decide in which format the textures are created and
	tries to create them maximizing render speed.
	When using this flag, it does not make sense to use the flags
	ETCF_ALWAYS_16_BIT, ETCF_ALWAYS_32_BIT, or ETCF_OPTIMIZED_FOR_QUALITY,
	at the same time. 
</member>
        <member name="F:ETCF_OPTIMIZED_FOR_QUALITY">
Lets the driver decide in which format the textures are created and
	tries to make the textures look as good as possible. Usually it simply
	chooses the format in which the texture was stored on disk.
	When using this flag, it does not make sense to use the flags
	ETCF_ALWAYS_16_BIT, ETCF_ALWAYS_32_BIT, or ETCF_OPTIMIZED_FOR_SPEED at
	the same time. 
</member>
        <member name="F:ETCF_ALWAYS_32_BIT">
Forces the driver to create 32 bit textures always, independent of
	which format the file on disk has. Please note that some drivers (like
	the software device) will ignore this, because they are only able to
	create and use 16 bit textures.
	When using this flag, it does not make sense to use the flags
	ETCF_ALWAYS_16_BIT, ETCF_OPTIMIZED_FOR_QUALITY, or
	ETCF_OPTIMIZED_FOR_SPEED at the same time. 
</member>
        <member name="F:ETCF_ALWAYS_16_BIT">
Forces the driver to create 16 bit textures always, independent of
	which format the file on disk has. When choosing this you may lose
	some color detail, but gain much speed and memory. 16 bit textures can
	be transferred twice as fast as 32 bit textures and only use half of
	the space in memory.
	When using this flag, it does not make sense to use the flags
	ETCF_ALWAYS_32_BIT, ETCF_OPTIMIZED_FOR_QUALITY, or
	ETCF_OPTIMIZED_FOR_SPEED at the same time. 
</member>
        <member name="M:irr.video.IImage.isRenderTargetOnlyFormat(irr.video.ECOLOR_FORMAT!System.Runtime.CompilerServices.IsConst)">
Since we don't have support for e.g. floating point IImage formats
	one should test if the color format can be used for arbitrary usage, or
	if it is restricted to RTTs. 
</member>
        <member name="M:irr.video.IImage.hasMipMaps">
\return True if image has MipMaps, else false. 
</member>
        <member name="M:irr.video.IImage.copyToWithAlpha(irr.video.IImage*,irr.core.vector2d&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.rect&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
\param combineAlpha - When true then combine alpha channels. When false replace target image alpha with source image alpha.

</member>
        <member name="M:irr.video.IImage.setMipMapsData(System.Void*,System.Boolean,System.Boolean)">
This method allows you to put custom mipmaps data for
	image.
	\param data A byte array with pixel color information
	\param ownForeignMemory If true, the image will use the data
	pointer directly and own it afterward. If false, the memory
	will by copied internally.
	\param deleteMemory Whether the memory is deallocated upon
	destruction. 
</member>
        <member name="M:irr.video.IImage.unlock">
Should be called after the pointer received by lock() is not
	needed anymore. 
</member>
        <member name="M:irr.video.IImage.lock">
Use getData instead.
	\return Pointer to the image data. What type of data is pointed to
	depends on the color format of the image. For example if the color
	format is ECF_A8R8G8B8, it is of u32. Be sure to call unlock() after
	you don't need the pointer any more. 
</member>
        <member name="M:irr.video.IImage.getData">
\return Pointer to the image data. What type of data is pointed to
depends on the color format of the image. For example if the color
format is ECF_A8R8G8B8, it is of u32. 
</member>
        <member name="T:irr.video.IImage">
Image loaders create these images from files. IVideoDrivers convert
these images into their (hardware) textures.
NOTE: Floating point formats are not well supported yet. Basically only getData() works for them.

</member>
        <member name="M:irr.io.IFileSystem.createEmptyAttributes(irr.video.IVideoDriver*)">
\param driver: Video driver to be used to load textures when specified as attribute values.
	Can be null to prevent automatic texture loading by attributes.
	\return Pointer to the created object.
	If you no longer need the object, you should call IAttributes::drop().
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLWriter(irr.io.IWriteFile*)">
\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLWriter is returned. After use, the reader
	has to be deleted using its IXMLWriter::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLWriter(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLWriter is returned. After use, the reader
	has to be deleted using its IXMLWriter::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLWriterUTF8(irr.io.IWriteFile*)">
\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLWriter is returned. After use, the reader
	has to be deleted using its IXMLWriter::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLWriterUTF8(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLWriter is returned. After use, the reader
	has to be deleted using its IXMLWriter::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLReaderUTF8(irr.io.IReadFile*)">
Use createXMLReader() if you prefer wchar_t* instead of char*. See IIrrXMLReader for
	more information on how to use the parser.
	\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLReader is returned. After use, the reader
	has to be deleted using its IXMLReaderUTF8::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLReaderUTF8(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use createXMLReader() if you prefer wchar_t* instead of char*. See IIrrXMLReader for
	more information on how to use the parser.
	\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLReader is returned. After use, the reader
	has to be deleted using its IXMLReaderUTF8::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLReader(irr.io.IReadFile*)">
Use createXMLReaderUTF8() if you prefer char* instead of wchar_t*. See IIrrXMLReader for
	more information on how to use the parser.
	\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLReader is returned. After use, the reader
	has to be deleted using its IXMLReader::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createXMLReader(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Use createXMLReaderUTF8() if you prefer char* instead of wchar_t*. See IIrrXMLReader for
	more information on how to use the parser.
	\return 0, if file could not be opened, otherwise a pointer to the created
	IXMLReader is returned. After use, the reader
	has to be deleted using its IXMLReader::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.existFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param filename is the string identifying the file which should be tested for existence.
	\return True if file exists, and false if it does not exist or an error occurred. 
</member>
        <member name="M:irr.io.IFileSystem.createEmptyFileList(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
\return a Pointer to the created IFileList is returned. After the list has been used
	it has to be deleted using its IFileList::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createFileList">
\return a Pointer to the created IFileList is returned. After the list has been used
	it has to be deleted using its IFileList::drop() method.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.getFileBasename(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
If no directory is prefixed, the full name is returned.
	\param filename: The file to get the basename from
	\param keepExtension True if filename with extension is returned otherwise everything
	after the final '.' is removed as well. 
</member>
        <member name="M:irr.io.IFileSystem.getFileDir(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param filename: The file to get the directory from.
	\return String containing the directory of the file. 
</member>
        <member name="M:irr.io.IFileSystem.getAbsolutePath(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param filename Possibly relative file or directory name to query.
	\result Absolute filename which points to the same file. 
</member>
        <member name="M:irr.io.IFileSystem.getWorkingDirectory">
\return Current working directory as a string. 
</member>
        <member name="M:irr.io.IFileSystem.addPakFileArchive(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
\deprecated This function is provided for compatibility
	with older versions of Irrlicht and may be removed in Irrlicht 1.9,
	you should use addFileArchive instead.
	After calling this, the Irrlicht Engine will search and open files directly from this archive too.
	This is useful for hiding data from the end user, speeding up file access and making it possible to
	access for example Quake2/KingPin/Hexen2 .pak files
	\param filename: Filename of the pak archive to add to the file system.
	\param ignoreCase: If set to true, files in the archive can be accessed without
	writing all letters in the right case.
	\param ignorePaths: If set to true, files in the added archive can be accessed
	without its complete path.(should not use with Quake2 paks
	\return True if the archive was added successful, false if not. 
</member>
        <member name="M:irr.io.IFileSystem.addFolderFileArchive(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
\deprecated This function is provided for compatibility
	with older versions of Irrlicht and may be removed in Irrlicht 1.9,
	you should use addFileArchive instead.
	Useful for handling data which will be in a zip file
	\param filename: Filename of the unzipped zip archive base directory to add to the file system.
	\param ignoreCase: If set to true, files in the archive can be accessed without
	writing all letters in the right case.
	\param ignorePaths: If set to true, files in the added archive can be accessed
	without its complete path.
	\return True if the archive was added successful, false if not. 
</member>
        <member name="M:irr.io.IFileSystem.addZipFileArchive(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
\deprecated This function is provided for compatibility
	with older versions of Irrlicht and may be removed in Irrlicht 1.9,
	you should use addFileArchive instead.
	After calling this, the Irrlicht Engine will search and open files directly from this archive too.
	This is useful for hiding data from the end user, speeding up file access and making it possible to
	access for example Quake3 .pk3 files, which are no different than .zip files.
	\param filename: Filename of the zip archive to add to the file system.
	\param ignoreCase: If set to true, files in the archive can be accessed without
	writing all letters in the right case.
	\param ignorePaths: If set to true, files in the added archive can be accessed
	without its complete path.
	\return True if the archive was added successfully, false if not. 
</member>
        <member name="M:irr.io.IFileSystem.getArchiveLoader(System.UInt32)">
\param index The index of the loader to retrieve. This parameter is an 0-based
	array index.
	\return A pointer to the specified loader, 0 if the index is incorrect. 
</member>
        <member name="M:irr.io.IFileSystem.addArchiveLoader(irr.io.IArchiveLoader*)">
Use this function to add support for new archive types to the
	engine, for example proprietary or encrypted file storage. 
</member>
        <member name="M:irr.io.IFileSystem.moveFileArchive(System.UInt32,System.Int32)">
\param sourceIndex: The index of the archive to change
\param relative: The relative change in position, archives with a lower index are searched first 
</member>
        <member name="M:irr.io.IFileSystem.removeFileArchive(irr.io.IFileArchive!System.Runtime.CompilerServices.IsConst*)">
This will close the archive and free any file handles, but will not
	close resources which have already been loaded and are now cached, for
	example textures and meshes.
	\param archive The archive to remove.
	\return True on success, false on failure 
</member>
        <member name="M:irr.io.IFileSystem.removeFileArchive(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This will close the archive and free any file handles, but will not
	close resources which have already been loaded and are now cached, for
	example textures and meshes. Note that a relative filename might be
	interpreted differently on each call, depending on the current working
	directory. In case you want to remove an archive that was added using
	a relative path name, you have to change to the same working directory
	again. This means, that the filename given on creation is not an
	identifier for the archive, but just a usual filename that is used for
	locating the archive to work with.
	\param filename The archive pointed to by the name will be removed
	\return True on success, false on failure 
</member>
        <member name="M:irr.io.IFileSystem.removeFileArchive(System.UInt32)">
This will close the archive and free any file handles, but will not
	close resources which have already been loaded and are now cached, for
	example textures and meshes.
	\param index: The index of the archive to remove
	\return True on success, false on failure 
</member>
        <member name="M:irr.io.IFileSystem.addFileArchive(irr.io.IFileArchive*)">
\param archive: The archive to add to the file system.
	\return True if the archive was added successfully, false if not. 
</member>
        <member name="M:irr.io.IFileSystem.addFileArchive(irr.io.IReadFile*,System.Boolean,System.Boolean,irr.io.E_FILE_ARCHIVE_TYPE,irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.io.IFileArchive**)">
After calling this, the Irrlicht Engine will also search and open
	files directly from this archive. This is useful for hiding data from
	the end user, speeding up file access and making it possible to access
	for example Quake3 .pk3 files, which are just renamed .zip files. By
	default Irrlicht supports ZIP, PAK, TAR, PNK, and directories as
	archives. You can provide your own archive types by implementing
	IArchiveLoader and passing an instance to addArchiveLoader.
	Irrlicht supports AES-encrypted zip files, and the advanced compression
	techniques lzma and bzip2.
	If you want to add a directory as an archive, prefix its name with a
	slash in order to let Irrlicht recognize it as a folder mount (mypath/).
	Using this technique one can build up a search order, because archives
	are read first, and can be used more easily with relative filenames.
	\param file: Archive to add to the file system.
	\param ignoreCase: If set to true, files in the archive can be accessed without
	writing all letters in the right case.
	\param ignorePaths: If set to true, files in the added archive can be accessed
	without its complete path.
	\param archiveType: If no specific E_FILE_ARCHIVE_TYPE is selected then
	the type of archive will depend on the extension of the file name. If
	you use a different extension then you can use this parameter to force
	a specific type of archive.
	\param password An optional password, which is used in case of encrypted archives.
	\param retArchive A pointer that will be set to the archive that is added.
	\return True if the archive was added successfully, false if not. 
</member>
        <member name="M:irr.io.IFileSystem.addFileArchive(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,irr.io.E_FILE_ARCHIVE_TYPE,irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.io.IFileArchive**)">
After calling this, the Irrlicht Engine will also search and open
	files directly from this archive. This is useful for hiding data from
	the end user, speeding up file access and making it possible to access
	for example Quake3 .pk3 files, which are just renamed .zip files. By
	default Irrlicht supports ZIP, PAK, TAR, PNK, and directories as
	archives. You can provide your own archive types by implementing
	IArchiveLoader and passing an instance to addArchiveLoader.
	Irrlicht supports AES-encrypted zip files, and the advanced compression
	techniques lzma and bzip2.
	\param filename: Filename of the archive to add to the file system.
	\param ignoreCase: If set to true, files in the archive can be accessed without
	writing all letters in the right case.
	\param ignorePaths: If set to true, files in the added archive can be accessed
	without its complete path.
	\param archiveType: If no specific E_FILE_ARCHIVE_TYPE is selected then
	the type of archive will depend on the extension of the file name. If
	you use a different extension then you can use this parameter to force
	a specific type of archive.
	\param password An optional password, which is used in case of encrypted archives.
	\param retArchive A pointer that will be set to the archive that is added.
	\return True if the archive was added successfully, false if not. 
</member>
        <member name="M:irr.io.IFileSystem.createAndWriteFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
\param filename: Name of file to open.
	\param append: If the file already exist, all write operations are
	appended to the file.
	\return Pointer to the created file interface. 0 is returned, if the
	file could not created or opened for writing.
	The returned pointer should be dropped when no longer needed.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="M:irr.io.IFileSystem.createMemoryWriteFile(System.Void*,System.Int32,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
This allows you to use a pointer to memory where an IWriteFile is requested.
		You are responsible for allocating enough memory.
	\param memory: A pointer to the start of the file in memory (allocated by you)
	\param len: The length of the memory in bytes
	\param fileName: The name given to this file
	\param deleteMemoryWhenDropped: True if the memory should be deleted
	along with the IWriteFile when it is dropped.
	\return Pointer to the created file interface.
	The returned pointer should be dropped when no longer needed.
	See IReferenceCounted::drop() for more information.

</member>
        <member name="M:irr.io.IFileSystem.createLimitReadFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.io.IReadFile*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong)">
This is useful e.g. for archives.
	\param fileName: The name given to this file
	\param alreadyOpenedFile: Pointer to the enclosing file
	\param pos: Start of the file inside alreadyOpenedFile
	\param areaSize: The length of the file
	\return A pointer to the created file interface.
	The returned pointer should be dropped when no longer needed.
	See IReferenceCounted::drop() for more information.

</member>
        <member name="M:irr.io.IFileSystem.createMemoryReadFile(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
This allows you to use a pointer to memory where an IReadFile is requested.
	\param memory: A pointer to the start of the file in memory
	\param len: The length of the memory in bytes
	\param fileName: The name given to this file
	\param deleteMemoryWhenDropped: True if the memory should be deleted
	along with the IReadFile when it is dropped.
	\return Pointer to the created file interface.
	The returned pointer should be dropped when no longer needed.
	See IReferenceCounted::drop() for more information.

</member>
        <member name="M:irr.io.IFileSystem.createAndOpenFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param filename: Name of file to open.
	\return Pointer to the created file interface.
	The returned pointer should be dropped when no longer needed.
	See IReferenceCounted::drop() for more information. 
</member>
        <member name="T:irr.io.IFileSystem">
It manages where files are, so that modules which use the the IO do not
need to know where every file is located. A file could be in a .zip-Archive or
as file on disk, using the IFileSystem makes no difference to this. 
</member>
        <member name="M:irr.io.IArchiveLoader.createArchive(irr.io.IReadFile*,System.Boolean,System.Boolean)">
\param file File handle to use.
	\param ignoreCase Searching is performed without regarding the case
	\param ignorePaths Files are searched for without checking for the directories
	\return Pointer to newly created archive, or 0 upon error. 
</member>
        <member name="M:irr.io.IArchiveLoader.createArchive(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
\param filename File to use.
	\param ignoreCase Searching is performed without regarding the case
	\param ignorePaths Files are searched for without checking for the directories
	\return Pointer to newly created archive, or 0 upon error. 
</member>
        <member name="M:irr.io.IArchiveLoader.isALoadableFileFormat(irr.io.E_FILE_ARCHIVE_TYPE)">
Check based on the archive type.
	\param fileType The archive type to check.
	\return True if the archive loader supports this type, false if not 
</member>
        <member name="M:irr.io.IArchiveLoader.isALoadableFileFormat(irr.io.IReadFile*)">
This check may look into the file.
	\param file File handle to check.
	\return True if file seems to be loadable. 
</member>
        <member name="M:irr.io.IArchiveLoader.isALoadableFileFormat(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check based on the file extension (e.g. ".zip")
	\param filename Name of file to check.
	\return True if file seems to be loadable. 
</member>
        <member name="T:irr.io.IArchiveLoader">
If you want the Irrlicht Engine be able to load archives of
currently unsupported file formats (e.g .wad), then implement
this and add your new Archive loader with
IFileSystem::addArchiveLoader() to the engine. 
</member>
        <member name="F:irr.io.IFileArchive.Password">
This variable is publicly accessible from the interface in order to
	avoid single access patterns to this place, and hence allow some more
	obscurity.

</member>
        <member name="M:irr.io.IFileArchive.getFileList">
\return Returns the complete directory tree for the archive,
	including all files and folders 
</member>
        <member name="M:irr.io.IFileArchive.createAndOpenFile(System.UInt32)">
Creates and returns
	\param index The zero based index of the file.
	\return Returns a pointer to the created file on success, or 0 on failure. 
</member>
        <member name="M:irr.io.IFileArchive.createAndOpenFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates and returns a new IReadFile for a file in the archive.
	\param filename The file to open
	\return Returns A pointer to the created file on success,
	or 0 on failure. 
</member>
        <member name="M:irr.io.IFileList.addItem(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Boolean,System.UInt32)">
\param fullPath The file name including path, from the root of the file list.
	\param isDirectory True if this is a directory rather than a file.
	\param offset The file offset inside an archive
	\param size The size of the file in bytes.
	\param id The ID of the file in the archive which owns it 
</member>
        <member name="M:irr.io.IFileList.findFile(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Searches for a file by name
	\param filename The name of the file to search for.
	\param isFolder True if you are searching for a directory path, false if you are searching for a file
	\return Returns the index of the file in the file list, or -1 if
	no matching name name was found. 
</member>
        <member name="M:irr.io.IFileList.isDirectory(System.UInt32)">
\param index The zero based index which will be checked. The index
	must be less than the amount getFileCount() returns.
	\return True if the file is a directory, else false. 
</member>
        <member name="M:irr.io.IFileList.getID(System.UInt32)">
This optional ID can be used to link the file list entry to information held
	elsewhere. For example this could be an index in an IFileArchive, linking the entry
	to its data offset, uncompressed size and CRC.
	\param index is the zero based index of the file which should be returned.
	The index must be less than the amount getFileCount() returns.
	\return The ID of the file. 
</member>
        <member name="M:irr.io.IFileList.getFileOffset(System.UInt32)">
\param index is the zero based index of the file which should be returned.
	The index must be less than the amount getFileCount() returns.
	\return The offset of the file in bytes. 
</member>
        <member name="M:irr.io.IFileList.getFileSize(System.UInt32)">
\param index is the zero based index of the file which should be returned.
	The index must be less than the amount getFileCount() returns.
	\return The size of the file in bytes. 
</member>
        <member name="M:irr.io.IFileList.getFullFileName(System.UInt32)">
\param index is the zero based index of the file which name should
	be returned. The index must be less than the amount getFileCount() returns.
	\return File name of the file. Returns 0 if an error occurred. 
</member>
        <member name="M:irr.io.IFileList.getFileName(System.UInt32)">
The path is not included in this name. Use getFullFileName for this.
	\param index is the zero based index of the file which name should
	be returned. The index must be less than the amount getFileCount() returns.
	\return File name of the file. Returns 0, if an error occurred. 
</member>
        <member name="M:irr.io.IFileList.getFileCount">
\return Amount of files and directories in the file list. 
</member>
        <member name="T:irr.io.IFileList">
File lists usually contain a list of all files in a given folder,
but can also contain a complete directory structure. 
</member>
        <member name="M:irr.io.IReadFile.getFileName">
\return File name as zero terminated character string. 
</member>
        <member name="M:irr.io.IReadFile.getPos">
\return Current position in the file in bytes on success or -1L on failure. 
</member>
        <member name="M:irr.io.IReadFile.getSize">
\return Size of the file in bytes. 
</member>
        <member name="M:irr.io.IReadFile.seek(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
\param finalPos Destination position in the file.
		\param relativeMovement If set to true, the position in the file is
		changed relative to current position. Otherwise the position is changed
		from beginning of file.
		\return True if successful, otherwise false. 
</member>
        <member name="M:irr.io.IReadFile.read(System.Void*,System.UInt64)">
\param buffer Pointer to buffer where read bytes are written to.
		\param sizeToRead Amount of bytes to read from the file.
		\return How many bytes were read. 
</member>
        <member name="D:irr.io.IXMLWriterUTF8">
Call IFileSystem::createXMLReaderUtf8(). to create an IXMLWriter 
</member>
        <member name="D:irr.io.IXMLWriter">
Call IFileSystem::createXMLReader(). to create an IXMLWriter 
</member>
        <member name="D:irr.io.IXMLReaderUTF8">
This XML Parser can read any type of text files from any source
	Irrlicht can read. Just call IFileSystem::createXMLReaderUTF8(). For
	more information on how to use the parser, see IIrrXMLReader 
</member>
        <member name="D:irr.io.IXMLReader">
This XML Parser can read any type of text files from any source
	Irrlicht can read. Just call IFileSystem::createXMLReader(). For more
	information on how to use the parser, see IIrrXMLReader 
</member>
        <member name="M:irr.io.createIrrXMLReaderUTF32(irr.io.IFileReadCallBack*,System.Boolean)">
This means that
	all character data will be returned in UTF-32. The file to read can
	be in any format, it will be converted to UTF-32 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReader() instead.
	\param callback: Callback for file read abstraction. Implement your own
	callback to make the xml parser read in other things than just files. See
	IFileReadCallBack for more information about this.
	\param deleteCallback: if true, the callback will be deleted after the file
	has been read.  Otherwise the caller is responsible for cleaning it up.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReaderUTF32(_iobuf*)">
This means that all character data will be returned in UTF-32. The file to read can
	be in any format, it will be converted to UTF-32 if it is not in this format.
	if you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReader() instead.
	\param file: Pointer to opened file, must have been opened in binary mode, e.g.
	using fopen("foo.bar", "wb"); The file will not be closed after it has been read.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReaderUTF32(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
This means that all character data will be returned in UTF-32. The file to read can
	be in any format, it will be converted to UTF-32 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReader() instead.
	\param filename: Name of file to be opened.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReaderUTF16(irr.io.IFileReadCallBack*,System.Boolean)">
This means that all character data will be returned in UTF-16. The file to read can
	be in any format, it will be converted to UTF-16 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReader() instead.
	\param callback: Callback for file read abstraction. Implement your own
	callback to make the xml parser read in other things than just files. See
	IFileReadCallBack for more information about this.
	\param deleteCallback: if true, the callback will be deleted after the file
	has been read.  Otherwise the caller is responsible for cleaning it up.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReaderUTF16(_iobuf*)">
This means that all character data will be returned in UTF-16. The file to read can
	be in any format, it will be converted to UTF-16 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReader() instead.
	\param file: Pointer to opened file, must have been opened in binary mode, e.g.
	using fopen("foo.bar", "wb"); The file will not be closed after it has been read.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReaderUTF16(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
This means that
	all character data will be returned in UTF-16. The file to read can
	be in any format, it will be converted to UTF-16 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReader() instead.
	\param filename: Name of file to be opened.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReader(irr.io.IFileReadCallBack*,System.Boolean)">
This means that all character data will be returned in 8 bit ASCII or UTF-8. The file to read can
	be in any format, it will be converted to UTF-8 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReaderUTF8() instead.
	\param callback: Callback for file read abstraction. Implement your own
	callback to make the xml parser read in other things than just files. See
	IFileReadCallBack for more information about this.
	\param deleteCallback: if true, the callback will be deleted after the file
	has been read.  Otherwise the caller is responsible for cleaning it up.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReader(_iobuf*)">
This means that all character data will be returned in 8 bit ASCII or UTF-8. The file to read can
	be in any format, it will be converted to UTF-8 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReaderUTF8() instead.
	\param file: Pointer to opened file, must have been opened in binary mode, e.g.
	using fopen("foo.bar", "wb"); The file will not be closed after it has been read.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="M:irr.io.createIrrXMLReader(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
This means that all character data will be returned in 8 bit ASCII or UTF-8.
	The file to read can be in any format, it will be converted to UTF-8 if it is not in this format.
	If you are using the Irrlicht Engine, it is better not to use this function but
	IFileSystem::createXMLReaderUTF8() instead.
	\param filename: Name of file to be opened.
	\return Returns a pointer to the created xml parser. This pointer should be
	deleted using 'delete' after no longer needed. Returns 0 if an error occurred
	and the file could not be opened. 
</member>
        <member name="D:irr.io.IrrXMLReaderUTF32">
This means that all character data will be returned in UTF-32 by this parser.
	The file to read can be in any format, it will be converted to UTF-32 if it is not
	in this format.
	Create an instance of this with createIrrXMLReaderUTF32();
	See IIrrXMLReader for description on how to use it. 
</member>
        <member name="D:irr.io.IrrXMLReaderUTF16">
This means that all character data will be returned in UTF-16 by this parser.
	The file to read can be in any format, it will be converted to UTF-16 if it is not
	in this format.
	Create an instance of this with createIrrXMLReaderUTF16();
	See IIrrXMLReader for description on how to use it. 
</member>
        <member name="D:irr.io.IrrXMLReader">
This means that all character data will be returned in 8 bit ASCII or UTF-8 by this parser.
	The file to read can be in any format, it will be converted to UTF-8 if it is not
	in this format.
	Create an instance of this with createIrrXMLReader();
	See IIrrXMLReader for description on how to use it. 
</member>
        <member name="D:irr.io.char32">
Not using wchar_t for this because
	wchar_t has 16 bit on windows and 32 bit on other operating systems. 
</member>
        <member name="D:irr.io.char16">
Not using wchar_t for this because
	wchar_t has 16 bit on windows and 32 bit on other operating systems. 
</member>
        <member name="M:irr.io.IFileReadCallBack.read(System.Void*,System.Int32)">
\param buffer: Pointer to buffer where to read bytes will be written to.
		\param sizeToRead: Amount of bytes to read from the file.
		\return Returns how much bytes were read. 
</member>
        <member name="T:irr.io.IFileReadCallBack">
With this, it is possible to make the xml parser read in other
	things than just files. The Irrlicht engine is using this for example to
	read xml from compressed .zip files. To make the parser read in
	any other data, derive a class from this interface, implement the
	two methods to read your data and give a pointer to an instance of
	your implementation when calling createIrrXMLReader(),
	createIrrXMLReaderUTF16() or createIrrXMLReaderUTF32() 
</member>
        <member name="M:irr.scene.IAnimatedMeshMD2.getAnimationName(System.Int32)">
\param nr: Zero based index of animation. 
</member>
        <member name="M:irr.scene.IAnimatedMeshMD2.getFrameLoop(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param name Name of the animation.
		\param outBegin The returned beginning frame for animation type specified.
		\param outEnd The returned ending frame for the animation type specified.
		\param outFPS The number of frames per second, this animation should be played at.
		\return beginframe, endframe and frames per second for a special MD2 animation type. 
</member>
        <member name="M:irr.scene.IAnimatedMeshMD2.getFrameLoop(irr.scene.EMD2_ANIMATION_TYPE,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param l The EMD2_ANIMATION_TYPE to get the frames for.
		\param outBegin The returned beginning frame for animation type specified.
		\param outEnd The returned ending frame for the animation type specified.
		\param outFPS The number of frames per second, this animation should be played at.
		\return beginframe, endframe and frames per second for a default MD2 animation type. 
</member>
        <member name="M:irr.scene.IAnimatedMesh.getMeshType">
In most cases it is not necessary to use this method.
		This is useful for making a safe downcast. For example,
		if getMeshType() returns EAMT_MD2 it's safe to cast the
		IAnimatedMesh to IAnimatedMeshMD2.
		\returns Type of the mesh. 
</member>
        <member name="M:irr.scene.IAnimatedMesh.getMesh(System.Int32,System.Int32,System.Int32,System.Int32)">
\param frame: Frame number as zero based index. The maximum
		frame number is getFrameCount() - 1;
		\param detailLevel: Level of detail. 0 is the lowest, 255 the
		highest level of detail. Most meshes will ignore the detail level.
		\param startFrameLoop: Because some animated meshes (.MD2) are
		blended between 2 static frames, and maybe animated in a loop,
		the startFrameLoop and the endFrameLoop have to be defined, to
		prevent the animation to be blended between frames which are
		outside of this loop.
		If startFrameLoop and endFrameLoop are both -1, they are ignored.
		\param endFrameLoop: see startFrameLoop.
		\return Returns the animated mesh based on a detail level. 
</member>
        <member name="M:irr.scene.IAnimatedMesh.setAnimationSpeed(System.Single)">
\param fps Number of frames per second to play the
		animation with by default. If the amount is 0,
		it is not animated. The actual speed is set in the
		scene node the mesh is instantiated in.
</member>
        <member name="M:irr.scene.IAnimatedMesh.getAnimationSpeed">
\return The number of frames per second to play the
		animation with by default. If the amount is 0,
		it is a static, non animated mesh. 
</member>
        <member name="M:irr.scene.IAnimatedMesh.getFrameCount">
Note that the play-time is usually getFrameCount()-1 as it stops as soon as the last frame-key is reached.
		\return The amount of frames. If the amount is 1,
		it is a static, non animated mesh. 	
</member>
        <member name="T:irr.scene.IAnimatedMesh">
There are already simple implementations of this interface available so
	you don't have to implement this interface on your own if you need to:
	You might want to use irr::scene::SAnimatedMesh, irr::scene::SMesh,
	irr::scene::SMeshBuffer etc. 
</member>
        <member name="M:irr.scene.IMesh.getMeshType">
This is useful for making a safe downcast. For example,
		if getMeshType() returns EAMT_MD2 it's safe to cast the
		IMesh to IAnimatedMeshMD2.
		Note: It's no longer just about animated meshes, that name has just historical reasons.
		\returns Type of the mesh  
</member>
        <member name="M:irr.scene.IMesh.setDirty(irr.scene.E_BUFFER_TYPE)">
This method has to be called every time the vertices or
		indices have changed. Otherwise, changes won't be updated
		on the GPU in the next render cycle. 
</member>
        <member name="M:irr.scene.IMesh.setHardwareMappingHint(irr.scene.E_HARDWARE_MAPPING,irr.scene.E_BUFFER_TYPE)">
This methods allows to define optimization hints for the
		hardware. This enables, e.g., the use of hardware buffers on
		platforms that support this feature. This can lead to noticeable
		performance gains. 
</member>
        <member name="M:irr.scene.IMesh.setMaterialFlag(irr.video.E_MATERIAL_FLAG,System.Boolean)">
\param flag: Flag to set in all materials.
		\param newvalue: New value to set in all materials. 
</member>
        <member name="M:irr.scene.IMesh.setBoundingBox(irr.core.aabbox3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param box New bounding box to use for the mesh. 
</member>
        <member name="M:irr.scene.IMesh.getBoundingBox">
\return Bounding box of this mesh. 
</member>
        <member name="M:irr.scene.IMesh.getMeshBuffer(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param material: material to search for
		\return Pointer to the mesh buffer or 0 if there is no such
		mesh buffer. 
</member>
        <member name="M:irr.scene.IMesh.getMeshBuffer(System.UInt32)">
\param nr: Zero based index of the mesh buffer. The maximum value is
		getMeshBufferCount() - 1;
		\return Pointer to the mesh buffer or 0 if there is no such
		mesh buffer. 
</member>
        <member name="M:irr.scene.IMesh.getMeshBufferCount">
\return Amount of mesh buffers (IMeshBuffer) in this mesh. 
</member>
        <member name="T:irr.scene.IMesh">
An IMesh is nothing more than a collection of some mesh buffers
	(IMeshBuffer). SMesh is a simple implementation of an IMesh.
	A mesh is usually added to an IMeshSceneNode in order to be rendered.

</member>
        <member name="F:EAMT_OCT">
The oct file format contains 3D geometry and lightmaps and
		can be loaded directly by Irrlicht 
</member>
        <member name="M:irr.core.fast_atof(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
\param floatAsString The string to convert.
    \param out Optional pointer to the first character in the string that
    wasn't used to create the float value.
    \result Float value parsed from the input string

</member>
        <member name="M:irr.core.fast_atof_move(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This is not guaranteed to be as accurate as atof(), but is
    approximately 6 to 8 times as fast.
    \param[in] in The string to convert.
    \param[out] result The resultant float will be written here.
    \return Pointer to the first character in the string that wasn't used
    to create the float value.

</member>
        <member name="M:irr.core.strtof10(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
Only digits 0 to 9 are parsed.  Parsing stops at any other character,
    including sign characters or a decimal point.
    \param in: the sequence of digits to convert.
    \param out: (optional) will be set to point at the first non-converted
    character.
    \return The whole positive floating point representation of the digit
    sequence.

</member>
        <member name="M:irr.core.strtoul_prefix(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
\param[in] in The string of digits to convert. If string starts with 0x the
    hex parser is used, if only leading 0 is used, oct parser is used. In all
    other cases, the usual unsigned parser is used.
    \param[out] out (optional) If provided, it will be set to point at the
    first character not used in the calculation.
    \return The unsigned integer value of the digits. If the string specifies
    too many digits to encode in an u32 then INT_MAX will be returned.

</member>
        <member name="M:irr.core.strtoul8(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
\param[in] in The string of digits to convert. No leading chars are
    allowed, only digits 0 to 7 are allowed. Parsing stops at the first illegal
    char.
    \param[out] out (optional) If provided, it will be set to point at the
    first character not used in the calculation.
    \return The unsigned integer value of the digits. If the string specifies
    too many digits to encode in an u32 then INT_MAX will be returned.

</member>
        <member name="M:irr.core.strtoul16(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
\param[in] in: The string of digits to convert. No leading chars are
    allowed, only digits 0 to 9 and chars A-F,a-f are allowed. Parsing stops
    at the first illegal char.
    \param[out] out: (optional) If provided, it will be set to point at the
    first character not used in the calculation.
    \return The unsigned integer value of the digits. If the string specifies
    too many digits to encode in an u32 then INT_MAX will be returned.

</member>
        <member name="M:irr.core.ctoul16(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
\param[in] in The digit to convert. Only digits 0 to 9 and chars A-F,a-f
    will be considered.
    \return The unsigned integer value of the digit. 0xffffffff if the input is
    not hex

</member>
        <member name="M:irr.core.strtol10(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
\param[in] in: The string of digits to convert. Only a leading - or +
    followed by digits 0 to 9 will be considered. Parsing stops at the first
    non-digit.
    \param[out] out: (optional) If provided, it will be set to point at the
    first character not used in the calculation.
    \return The signed integer value of the digits. If the string specifies
    too many digits to encode in an s32 then +INT_MAX or -INT_MAX will be
    returned.

</member>
        <member name="M:irr.core.strtoul10(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**)">
\param[in] in: The string of digits to convert. No leading chars are
    allowed, only digits 0 to 9. Parsing stops at the first non-digit.
    \param[out] out: (optional) If provided, it will be set to point at the
    first character not used in the calculation.
    \return The unsigned integer value of the digits. If the string specifies
    too many digits to encode in an u32 then INT_MAX will be returned.

</member>
        <member name="T:irr.scene.ESCENE_NODE_TYPE">
A scene node type is represented by a four character code
	such as 'cube' or 'mesh' instead of simple numbers, to avoid
	name clashes with external scene nodes.
</member>
        <member name="T:irr.scene.EMESH_WRITER_TYPE">
A scene mesh writers is represented by a four character code
	such as 'irrm' or 'coll' instead of simple numbers, to avoid
	name clashes with external mesh writers.
</member>
        <member name="T:irr.gui.EGUI_ELEMENT_TYPE">
An IGUIElement returns this when calling IGUIElement::getType(); 
</member>
        <member name="F:EDT_OPENGL">
Performs hardware accelerated rendering of 3D and 2D
		primitives. 
</member>
        <member name="F:EDT_DIRECT3D9">
Performs hardware accelerated rendering of 3D and 2D
		primitives. 
</member>
        <member name="F:EDT_BURNINGSVIDEO">
Basically it can be described as the Irrlicht Software
		renderer on steroids. It rasterizes 3D geometry perfectly: It
		is able to perform correct 3d clipping, perspective correct
		texture mapping, perspective correct color mapping, and renders
		sub pixel correct, sub texel correct primitives. In addition,
		it does bilinear texel filtering and supports more materials
		than the EDT_SOFTWARE driver. This renderer has been written
		entirely by Thomas Alten, thanks a lot for this huge
		contribution. 
</member>
        <member name="F:EDT_SOFTWARE">
Runs on all platforms, with every hardware. It should only
		be used for 2d graphics, but it can also perform some primitive
		3d functions. These 3d drawing functions are quite fast, but
		very inaccurate, and don't even support clipping in 3D mode. 
</member>
        <member name="F:EDT_NULL">
The null device is able to load textures, but does not
		render and display any graphics. 
</member>
        <member name="M:irr.CProfileScope.#ctor(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Slowest scope constructor, but usually still fine unless speed is very critical.
	\param name: Name for displaying profile data.
	\param groupName: Each id belongs into a group - this helps on displaying profile data. 
</member>
        <member name="M:irr.CProfileScope.#ctor(System.Int32,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param id: Should be &gt;= 0 as negative id's are reserved for Irrlicht. Also very large numbers (near INT_MAX) might
	have been created already by the automatic add function of ::IProfiler.
	\param name: Name for displaying profile data.
	\param groupName: Each id belongs into a group - this helps on displaying profile data. 
</member>
        <member name="M:irr.CProfileScope.#ctor(System.Int32)">
This is the fastest scope constructor, but the id must have been added before.
	\param id Any id which you did add to the profiler before. 
</member>
        <member name="T:irr.CProfileScope">
This is a comfort wrapper around the IProfiler start/stop mechanism which is easier to use
when you want to profile a scope. You only have to create an object and it will profile it's own lifetime
for the given id. 
</member>
        <member name="M:irr.getProfiler">
Profiler is always accessible, except in destruction of global objects.
If you want to get internal profiling information about the engine itself
you will have to re-compile the engine with _IRR_COMPILE_WITH_PROFILING_ enabled.
But you can use the profiler for profiling your own projects without that. 
</member>
        <member name="M:irr.IProfiler.printGroup(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Boolean)">
\param result Receives the result string.
	\param groupIndex_	
</member>
        <member name="M:irr.IProfiler.printAll(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
\param result Receives the result string.
	\param includeOverview When true a group-overview is attached first
	\param suppressUncalled When true elements which got never called are not printed 
</member>
        <member name="M:irr.IProfiler.resetAll">
NOTE: This is not deleting id's or groups, just resetting all timers to 0. 
</member>
        <member name="M:irr.IProfiler.stop(System.Int32)">
This increases an internal run-counter for the given id. If it reaches 0 the time since start is recorded.
		You should have the same amount of start and stop calls. If stop is called more often than start
		then the additional stop calls will be ignored (counter never goes below 0)

</member>
        <member name="M:irr.IProfiler.start(System.Int32)">
This increases an internal run-counter for the given id. It will profile as long as that counter is &gt; 0.
	NOTE: you have to add the id first with one of the ::add functions

</member>
        <member name="M:irr.IProfiler.findGroupIndex(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param result Receives the resulting group index when one was found.
	\param name String with name to search for
	\return true when found, false when not found 
</member>
        <member name="M:irr.IProfiler.getGroupData(System.UInt32)">
NOTE: The first groups is always L"overview" which is an overview for all existing groups 
</member>
        <member name="M:irr.IProfiler.getGroupCount">
NOTE: The first groups is always L"overview" which is an overview for all existing groups 
</member>
        <member name="M:irr.IProfiler.getProfileDataById(System.UInt32)">
\param id Same value as used in ::add
	\return Profile data for the given id or 0 when it does not exist.	
</member>
        <member name="M:irr.IProfiler.getProfileDataByIndex(System.UInt32)">
\param index A value between 0 and getProfileDataCount()-1.	Indices can change when new id's are added.
</member>
        <member name="M:irr.IProfiler.findDataIndex(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param result Receives the resulting data index when one was found.
	\param name String with name to search for
	\return true when found, false when not found 
</member>
        <member name="M:irr.IProfiler.add(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
After calling this once you can start/stop profiling with the returned id.
	\param name: Name for displaying profile data.
	\param groupName: Each id belongs into a group - this helps on displaying profile data.
	\return Automatic id's start at INT_MAX and count down for each new id. If the name already has an id then that id will be returned. 
</member>
        <member name="M:irr.IProfiler.add(System.Int32,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
After calling this once you can start/stop profiling for the given id.
	\param id: Should be &gt;= 0 as negative id's are reserved for Irrlicht. Also very large numbers (near INT_MAX) might
	have been added automatically by the other add function.
	\param name: Name for displaying profile data.
	\param groupName: Each id belongs into a group - this helps on displaying profile data. 
</member>
        <member name="M:irr.ITimer.tick">
Makes the virtual timer update the time value based on the real
	time. This is called automatically when calling IrrlichtDevice::run(),
	but you can call it manually if you don't use this method. 
</member>
        <member name="M:irr.ITimer.getSpeed">
The speed is the factor with which the time is running faster or
	slower then the real system time. 
</member>
        <member name="M:irr.ITimer.setSpeed(System.Single)">
The speed is the factor with which the time is running faster or
	slower then the real system time. 
</member>
        <member name="M:irr.ITimer.start">
The timer is reference counted, which means everything which calls
	stop() will also have to call start(), otherwise the timer may not
	start/stop correctly again. 
</member>
        <member name="M:irr.ITimer.stop">
The timer is reference counted, which means everything which calls
	stop() will also have to call start(), otherwise the timer may not
	start/stop correctly again. 
</member>
        <member name="M:irr.ITimer.getTime">
This value starts with 0 and can be manipulated using setTime(),
	stopTimer(), startTimer(), etc. This value depends on the set speed of
	the timer if the timer is stopped, etc. If you need the system time,
	use getRealTime() 
</member>
        <member name="M:irr.ITimer.getRealTime">
This value does not start with 0 when the application starts.
	For example in one implementation the value returned could be the
	amount of milliseconds which have elapsed since the system was started.

</member>
        <member name="T:irr.io.SNamedPath">
Irrlicht is internally not case-sensitive when it comes to names.
    Also this class is a first step towards support for correctly serializing renamed objects.

</member>
        <member name="D:irr.io.path">
This type will transparently handle different file system encodings. 
</member>
        <member name="M:irr.scene.CIndexBuffer.getChangedID">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.CVertexBuffer.getChangedID">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getIndexCount">
\return Number of indices in this buffer. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getIndices">
\return Pointer to indices array. 

\return Pointer to indices array. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getIndexType">
\return Index type of this buffer. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getVertexCount">
\return Number of vertices in this buffer. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getVertices">
Which vertex type is used can be determined by getVertexType().
		\return Pointer to array of vertices. 

Which vertex type is used can be determined by getVertexType().
		\return Pointer to array of vertices. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getVertexType">
\return Vertex type of this buffer. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.append(irr.scene.IMeshBuffer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
Only works for compatible vertex types
		\param other Buffer to append to this one. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.append(System.Void!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.UInt32)">
Only works for compatible vertex types.
		\param vertices Pointer to a vertex array.
		\param numVertices Number of vertices in the array.
		\param indices Pointer to index array.
		\param numIndices Number of indices in array. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.setBoundingBox(irr.core.aabbox3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param box User defined axis aligned bounding box to use
		for this buffer. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getBoundingBox">
\return Axis aligned bounding box of this buffer. 
</member>
        <member name="M:irr.scene.IDynamicMeshBuffer.getMaterial">
\return Material of this buffer. 

\return Material of this buffer. 
</member>
        <member name="T:irr.scene.IDynamicMeshBuffer">
a dynamic meshBuffer 
</member>
        <member name="M:irr.scene.IIndexBuffer.getChangedID">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.IVertexBuffer.getChangedID">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.IMeshBuffer.setPrimitiveType(irr.scene.E_PRIMITIVE_TYPE)">
Note: Default is EPT_TRIANGLES. Using other types is fine for rendering.
		But meshbuffer manipulation functions might expect type EPT_TRIANGLES
		to work correctly. Also mesh writers will generally fail (badly!) with other
		types than EPT_TRIANGLES. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getChangedID_Index">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getChangedID_Vertex">
This shouldn't be used for anything outside the VideoDriver. 
</member>
        <member name="M:irr.scene.IMeshBuffer.append(irr.scene.IMeshBuffer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst)">
Only works for compatible vertex types
		\param other Buffer to append to this one. 
</member>
        <member name="M:irr.scene.IMeshBuffer.append(System.Void!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.UInt32,System.UInt16!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.UInt32)">
Only works for compatible vertex types.
		\param vertices Pointer to a vertex array.
		\param numVertices Number of vertices in the array.
		\param indices Pointer to index array.
		\param numIndices Number of indices in array. 
</member>
        <member name="M:irr.scene.IMeshBuffer.setBoundingBox(irr.core.aabbox3d&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param box User defined axis aligned bounding box to use
		for this buffer. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getBoundingBox">
\return Axis aligned bounding box of this buffer. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getIndexCount">
\return Number of indices in this buffer. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getIndices">
\return Pointer to indices array. 

\return Pointer to indices array. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getIndexType">
\return Index type of this buffer. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getVertexCount">
\return Number of vertices in this buffer. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getVertices">
Which vertex type is used can be determined by getVertexType().
		\return Pointer to array of vertices. 

Which vertex type is used can be determined by getVertexType().
		\return Pointer to array of vertices. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getVertexType">
\return Vertex type of this buffer. 
</member>
        <member name="M:irr.scene.IMeshBuffer.getMaterial">
\return Material of this buffer. 

\return Material of this buffer. 
</member>
        <member name="T:irr.scene.IMeshBuffer">
A part of an IMesh which has the same material on each face of that
	group. Logical groups of an IMesh need not be put into separate mesh
	buffers, but can be. Separately animated parts of the mesh must be put
	into separate mesh buffers.
	Some mesh buffer implementations have limitations on the number of
	vertices the buffer can hold. In that case, logical grouping can help.
	Moreover, the number of vertices should be optimized for the GPU upload,
	which often depends on the type of gfx card. Typical figures are
	1000-10000 vertices per buffer.
	SMeshBuffer is a simple implementation of a MeshBuffer, which supports
	up to 65535 vertices.

	Since meshbuffers are used for drawing, and hence will be exposed
	to the driver, chances are high that they are grab()'ed from somewhere.
	It's therefore required to dynamically allocate meshbuffers which are
	passed to a video driver and only drop the buffer once it's not used in
	the current code block anymore.

</member>
        <member name="T:irr.video.S3DVertexTangents">
Usually used for tangent space normal mapping. 
	Usually tangent and binormal get send to shaders as texture coordinate sets 1 and 2.

</member>
        <member name="T:irr.video.S3DVertex2TCoords">
Usually used for geometry with lightmaps
or other special materials.

</member>
        <member name="F:EVT_TANGENTS">
Usually used for tangent space normal mapping. 
		Usually tangent and binormal get send to shaders as texture coordinate sets 1 and 2.

</member>
        <member name="F:EVT_2TCOORDS">
Usually used for geometry with lightmaps or other special materials. 
</member>
        <member name="M:irr.video.SMaterial.op_Equality(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param b Material to compare to.
		\return True if the materials are equal, else false. 
</member>
        <member name="M:irr.video.SMaterial.op_Inequality(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param b Material to compare to.
		\return True if the materials differ, else false. 
</member>
        <member name="M:irr.video.SMaterial.getFlag(irr.video.E_MATERIAL_FLAG)">
\param flag The flag to query.
		\return The current value of the flag. 
</member>
        <member name="M:irr.video.SMaterial.setFlag(irr.video.E_MATERIAL_FLAG,System.Boolean)">
\param flag The flag to be set.
		\param value The new value for the flag. 
</member>
        <member name="M:irr.video.SMaterial.setTexture(System.UInt32,irr.video.ITexture*)">
If i&gt;=MATERIAL_MAX_TEXTURES this setting will be ignored.
		\param i The desired level.
		\param tex Texture for texture level i. 
</member>
        <member name="M:irr.video.SMaterial.getTexture(System.UInt32)">
\param i The desired level.
		\return Texture for texture level i, if defined, else 0. 
</member>
        <member name="M:irr.video.SMaterial.setTextureMatrix(System.UInt32,irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param i The desired level.
		\param mat Texture matrix for texture level i. 
</member>
        <member name="M:irr.video.SMaterial.getTextureMatrix(System.UInt32)">
\param i The desired level. Must not be larger than MATERIAL_MAX_TEXTURES
		\return Texture matrix for texture level i. 

\param i The desired level.
		\return Texture matrix for texture level i, or identity matrix for levels larger than MATERIAL_MAX_TEXTURES. 
</member>
        <member name="F:irr.video.SMaterial.ZWriteFineControl">
Note that there is also the global flag AllowZWriteOnTransparent
		which when set acts like all materials have set EZI_ALLOW_ON_TRANSPARENT. 
</member>
        <member name="F:irr.video.SMaterial.UseMipMaps">
Sometimes, disabling mipmap usage can be useful. Default: true 
</member>
        <member name="F:irr.video.SMaterial.NormalizeNormals">
Always use this if the mesh lit and scaled. Default: false 
</member>
        <member name="F:irr.video.SMaterial.ZWriteEnable">
This flag is forced to false if the MaterialType is a
		transparent type and the scene parameter
		ALLOW_ZWRITE_ON_TRANSPARENT is not set. If you set this parameter
		to true, make sure that ZBuffer value is other than ECFN_DISABLED 
</member>
        <member name="F:irr.video.SMaterial.Wireframe">
The user can access a material flag using
		\code material.Wireframe=true \endcode
		or \code material.setFlag(EMF_WIREFRAME, true); \endcode 
</member>
        <member name="F:irr.video.SMaterial.PolygonOffsetSlopeScale">
For polygons looking flat at a camera you could use 0 (for example in a 2D game)
		But in most cases you will have polygons rendered at a certain slope.
		The driver will calculate the slope for you and this value allows to scale that slope.
		The complete polygon offset is: PolygonOffsetSlopeScale*slope + PolygonOffsetDepthBias
		A good default here is to use 1.f if you want to push the polygons away from the camera
		and -1.f to pull them towards the camera.  
</member>
        <member name="F:irr.video.SMaterial.PolygonOffsetDepthBias">
The range of the value is driver specific.
		On OpenGL you get units which are multiplied by the smallest value that is guaranteed to produce a resolvable offset.
		On D3D9 you can pass a range between -1 and 1. But you should likely divide it by the range of the depthbuffer.
		Like dividing by 65535.0 for a 16 bit depthbuffer. Thought it still might produce too large of a bias.
		Some article (https://aras-p.info/blog/2008/06/12/depth-bias-and-the-power-of-deceiving-yourself/)
		recommends multiplying by 2.0*4.8e-7 (and strangely on both 16 bit and 24 bit).	
</member>
        <member name="F:irr.video.SMaterial.PolygonOffsetDirection">
Flag defining the direction the polygon offset is applied to.
		Can be to front or to back, specified by values from E_POLYGON_OFFSET. 	
</member>
        <member name="F:irr.video.SMaterial.PolygonOffsetFactor">
Factor specifying how far the polygon offset should be made.
		Specifying 0 disables the polygon offset. The direction is specified separately.
		The factor can be from 0 to 7.
		Note: This probably never worked on Direct3D9 (was coded for D3D8 which had different value ranges)	
</member>
        <member name="F:irr.video.SMaterial.BlendFactor">
textureBlendFunc/textureBlendFuncSeparate functions should be used to write
		properly blending factors to this parameter. If you use EMT_ONETEXTURE_BLEND
		type for this material, this field should be equal to MaterialTypeParam. 
</member>
        <member name="F:irr.video.SMaterial.BlendOperation">
Values to be chosen from E_BLEND_OPERATION. 
</member>
        <member name="F:irr.video.SMaterial.ColorMaterial">
Values should be chosen from E_COLOR_MATERIAL.
		When lighting is enabled, vertex color can be used instead of the
		material values for light modulation. This allows to easily change e.g. the
		diffuse light behavior of each face. The default, ECM_DIFFUSE, will result in
		a very similar rendering as with lighting turned off, just with light shading. 
</member>
        <member name="F:irr.video.SMaterial.ColorMask">
Values are defined as or'ed values of the E_COLOR_PLANE enum.
		Only enabled color planes will be rendered to the current render
		target. Typical use is to disable all colors when rendering only to
		depth or stencil buffer, or using Red and Green for Stereo rendering. 
</member>
        <member name="F:irr.video.SMaterial.AntiAliasing">
Values are chosen from E_ANTI_ALIASING_MODE. Default is
		EAAM_SIMPLE, i.e. simple multi-sample anti-aliasing. 
</member>
        <member name="F:irr.video.SMaterial.ZBuffer">
If you want to disable depth test for this material
		just set this parameter to ECFN_DISABLED.
		Values are from E_COMPARISON_FUNC. 
</member>
        <member name="F:irr.video.SMaterial.MaterialTypeParam2">
Mostly ignored. 
</member>
        <member name="F:irr.video.SMaterial.MaterialTypeParam">
Mostly ignored, used for example in EMT_PARALLAX_MAP_SOLID
		and EMT_TRANSPARENT_ALPHA_CHANNEL. 
</member>
        <member name="F:irr.video.SMaterial.Shininess">
A value of 20 is common. If set to 0, no specular
		highlights are being used. To activate, simply set the
		shininess of a material to a value in the range [0.5;128]:
		\code
		sceneNode-&gt;getMaterial(0).Shininess = 20.0f;
		\endcode

		You can change the color of the highlights using
		\code
		sceneNode-&gt;getMaterial(0).SpecularColor.set(255,255,255,255);
		\endcode

		The specular color of the dynamic lights
		(SLight::SpecularColor) will influence the the highlight color
		too, but they are set to a useful value by default when
		creating the light scene node. Here is a simple example on how
		to use specular highlights:
		\code
		// load and display mesh
		scene::IAnimatedMeshSceneNode* node = smgr-&gt;addAnimatedMeshSceneNode(
		smgr-&gt;getMesh("data/faerie.md2"));
		node-&gt;setMaterialTexture(0, driver-&gt;getTexture("data/Faerie2.pcx")); // set diffuse texture
		node-&gt;setMaterialFlag(video::EMF_LIGHTING, true); // enable dynamic lighting
		node-&gt;getMaterial(0).Shininess = 20.0f; // set size of specular highlights

		// add white light
		scene::ILightSceneNode* light = smgr-&gt;addLightSceneNode(0,
			core::vector3df(5,5,5), video::SColorf(1.0f, 1.0f, 1.0f));
		\endcode 
</member>
        <member name="F:irr.video.SMaterial.SpecularColor">
The default is to reflect white specular light. See
		SMaterial::Shininess on how to enable specular lights. 
</member>
        <member name="F:irr.video.SMaterial.DiffuseColor">
The default is full white. 
</member>
        <member name="F:irr.video.SMaterial.AmbientColor">
The default is full white, meaning objects are completely
		globally illuminated. Reduce this if you want to see diffuse
		or specular light effects. 
</member>
        <member name="M:irr.video.SMaterial.op_Assign(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param other Material to copy from. 
</member>
        <member name="M:irr.video.SMaterial.#ctor(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param other Material to copy from. 
</member>
        <member name="F:irr.video.MATERIAL_MAX_TEXTURES_USED">
Users can modify this value if they are certain they don't need all
		available textures per material in their application. For example if you
		never need more than 2 textures per material you can set this to 2.

		We (mostly) avoid dynamic memory in SMaterial, so the extra memory
		will still be allocated. But by lowering MATERIAL_MAX_TEXTURES_USED the
		material comparisons and assignments can be faster. Also several other
		places in the engine can be faster when reducing this value to the limit
		you need.

		NOTE: This should only be changed once and before any call to createDevice.
		NOTE: Do not set it below 1 or above the value of _IRR_MATERIAL_MAX_TEXTURES_.
		NOTE: Going below 4 is usually not worth it.

</member>
        <member name="T:irr.video.E_POLYGON_OFFSET">
Flags for the definition of the polygon offset feature. These flags define whether the offset should be into the screen, or towards the eye. 
</member>
        <member name="F:EPO_FRONT">
This is typically used for polygons which should appear on top
		of other elements, such as decals. 
</member>
        <member name="F:EPO_BACK">
This is typically used for rendering inner areas. 
</member>
        <member name="T:irr.video.E_COLOR_MATERIAL">
Without lighting being enabled the vertex color is the only value defining the fragment color.
	Once lighting is enabled, the four values for diffuse, ambient, emissive, and specular take over.
	With these flags it is possible to define which lighting factor shall be defined by the vertex color
	instead of the lighting factor which is the same for all faces of that material.
	The default is to use vertex color for the diffuse value, another pretty common value is to use
	vertex color for both diffuse and ambient factor. 
</member>
        <member name="T:irr.video.E_ANTI_ALIASING_MODE">
Techniques supported are multisampling, geometry smoothing, and alpha
	to coverage.
	Some drivers don't support a per-material setting of the anti-aliasing
	modes. In those cases, FSAA/multisampling is defined by the device mode
	chosen upon creation via irr::SIrrCreationParameters.

</member>
        <member name="F:EAAM_ALPHA_TO_COVERAGE">
Usually used with EMT_TRANSPARENT_ALPHA_CHANNEL_REF and multisampling. 
</member>
        <member name="M:irr.video.unpack_textureBlendFuncSeparate(irr.video.E_BLEND_FACTOR*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.E_BLEND_FACTOR*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.E_BLEND_FACTOR*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.E_BLEND_FACTOR*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.E_MODULATE_FUNC*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst)">
The fields don't use the full byte range, so we could pack even more... 
</member>
        <member name="M:irr.video.unpack_textureBlendFunc(irr.video.E_BLEND_FACTOR*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.E_BLEND_FACTOR*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.E_MODULATE_FUNC*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst)">
The fields don't use the full byte range, so we could pack even more... 
</member>
        <member name="M:irr.video.pack_textureBlendFuncSeparate(irr.video.E_BLEND_FACTOR!System.Runtime.CompilerServices.IsConst,irr.video.E_BLEND_FACTOR!System.Runtime.CompilerServices.IsConst,irr.video.E_BLEND_FACTOR!System.Runtime.CompilerServices.IsConst,irr.video.E_BLEND_FACTOR!System.Runtime.CompilerServices.IsConst,irr.video.E_MODULATE_FUNC!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst)">
alpha source can be an OR'ed combination of E_ALPHA_SOURCE values. 
</member>
        <member name="M:irr.video.pack_textureBlendFunc(irr.video.E_BLEND_FACTOR!System.Runtime.CompilerServices.IsConst,irr.video.E_BLEND_FACTOR!System.Runtime.CompilerServices.IsConst,irr.video.E_MODULATE_FUNC!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst)">
alpha source can be an OR'ed combination of E_ALPHA_SOURCE values. 
</member>
        <member name="T:irr.video.E_ALPHA_SOURCE">
This is currently only supported in EMT_ONETEXTURE_BLEND. You can use an
	or'ed combination of values. Alpha values are modulated (multiplied). 
</member>
        <member name="F:irr.video.SMaterialLayer.TextureMatrix">
Do not access this element directly as the internal
		resource management has to cope with Null pointers etc. 
</member>
        <member name="F:irr.video.SMaterialLayer.LODBias">
This value can make the textures more or less blurry than with the
		default value of 0. The value (divided by 8.f) is added to the mipmap level
		chosen initially, and thus takes a smaller mipmap for a region
		if the value is positive. 
</member>
        <member name="F:irr.video.SMaterialLayer.AnisotropicFilter">
In Irrlicht you can use anisotropic texture filtering
		in conjunction with bilinear or trilinear texture
		filtering to improve rendering results. Primitives
		will look less blurry with this flag switched on. The number gives
		the maximal anisotropy degree, and is often in the range 2-16.
		Value 1 is equivalent to 0, but should be avoided. 
</member>
        <member name="F:irr.video.SMaterialLayer.TrilinearFilter">
If the trilinear filter flag is enabled,
		the bilinear filtering flag is ignored. 
</member>
        <member name="F:irr.video.SMaterialLayer.TextureWrapU">
Values are taken from E_TEXTURE_CLAMP. 
</member>
        <member name="M:irr.video.SMaterialLayer.op_Equality(irr.video.SMaterialLayer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param b Layer to compare to.
		\return True if layers are equal, else false. 
</member>
        <member name="M:irr.video.SMaterialLayer.op_Inequality(irr.video.SMaterialLayer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param b Layer to compare to.
		\return True if layers are different, else false. 
</member>
        <member name="M:irr.video.SMaterialLayer.setTextureMatrix(irr.core.CMatrix4&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
NOTE: Pipelines can ignore this matrix when the 
		texture	is 0.
		\param mat New texture matrix for this layer. 
</member>
        <member name="M:irr.video.SMaterialLayer.getTextureMatrix">
\return Texture matrix of this layer. 

\return Texture matrix of this layer. 
</member>
        <member name="M:irr.video.SMaterialLayer.op_Assign(irr.video.SMaterialLayer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param other Material layer to copy from.
		\return This material layer, updated. 
</member>
        <member name="M:irr.video.SMaterialLayer.#ctor(irr.video.SMaterialLayer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param other Material layer to copy from. 
</member>
        <member name="F:EMF_NORMALIZE_NORMALS">
You can enable this if you need to scale a dynamic lighted
		model. Usually, its normals will get scaled too then and it
		will get darker. If you enable the EMF_NORMALIZE_NORMALS flag,
		the normals will be normalized again, and the model will look
		as bright as it should. 
</member>
        <member name="F:EMF_ANISOTROPIC_FILTER">
In Irrlicht you can use anisotropic texture filtering in
		conjunction with bilinear or trilinear texture filtering
		to improve rendering results. Primitives will look less
		blurry with this flag switched on. 
</member>
        <member name="F:EMF_TRILINEAR_FILTER">
If the trilinear filter flag is enabled,
		the bilinear filtering flag is ignored. 
</member>
        <member name="F:EMF_FRONT_FACE_CULLING">
Overrides EMF_BACK_FACE_CULLING if both are enabled. 
</member>
        <member name="F:EMF_ZWRITE_ENABLE">
This flag is ignored, if the material type is a transparent type. 
</member>
        <member name="F:EMT_ONETEXTURE_BLEND">
Using only first texture. Generic blending method. 
</member>
        <member name="F:EMT_PARALLAX_MAP_TRANSPARENT_VERTEX_ALPHA">
Using EMT_TRANSPARENT_VERTEX_ALPHA as base material. 
</member>
        <member name="F:EMT_PARALLAX_MAP_TRANSPARENT_ADD_COLOR">
Using EMT_TRANSPARENT_ADD_COLOR as base material. 
</member>
        <member name="F:EMT_PARALLAX_MAP_SOLID">
Looks a lot more realistic. This only works when the
		hardware supports at least vertex shader 1.1 and pixel shader
		1.4. First texture is the color map, the second should be the
		normal map. The normal map texture should contain the height
		value in the alpha component. The
		IVideoDriver::makeNormalMapTexture() method writes this value
		automatically when creating normal maps from a heightmap when
		using a 32 bit texture. The height scale of the material
		(affecting the bumpiness) is being controlled by the
		SMaterial::MaterialTypeParam member. If set to zero, the
		default value (0.02f) will be applied. Otherwise the value set
		in SMaterial::MaterialTypeParam is taken. This value depends on
		with which scale the texture is mapped on the material. Too
		high or low values of MaterialTypeParam can result in strange
		artifacts. 
</member>
        <member name="F:EMT_NORMAL_MAP_TRANSPARENT_VERTEX_ALPHA">
First texture is the color map, the second should be the
		normal map. Note that you should use this material only when
		drawing geometry consisting of vertices of type
		S3DVertexTangents (EVT_TANGENTS). You can convert any mesh into
		this format using IMeshManipulator::createMeshWithTangents()
		(See SpecialFX2 Tutorial). This shader runs on vertex shader
		1.1 and pixel shader 1.1 capable hardware and falls back to a
		fixed function lighted material if this hardware is not
		available.  Only two lights are supported by this shader, if
		there are more, the nearest two are chosen. 
</member>
        <member name="F:EMT_NORMAL_MAP_TRANSPARENT_ADD_COLOR">
First texture is the color map, the second should be the
		normal map. Note that you should use this material only when
		drawing geometry consisting of vertices of type
		S3DVertexTangents (EVT_TANGENTS). You can convert any mesh into
		this format using IMeshManipulator::createMeshWithTangents()
		(See SpecialFX2 Tutorial). This shader runs on vertex shader
		1.1 and pixel shader 1.1 capable hardware and falls back to a
		fixed function lighted material if this hardware is not
		available. Only two lights are supported by this shader, if
		there are more, the nearest two are chosen. 
</member>
        <member name="F:EMT_NORMAL_MAP_SOLID">
First texture is the color map, the second should be the
		normal map. Note that you should use this material only when
		drawing geometry consisting of vertices of type
		S3DVertexTangents (EVT_TANGENTS). You can convert any mesh into
		this format using IMeshManipulator::createMeshWithTangents()
		(See SpecialFX2 Tutorial). This shader runs on vertex shader
		1.1 and pixel shader 1.1 capable hardware and falls back to a
		fixed function lighted material if this hardware is not
		available. Only two lights are supported by this shader, if
		there are more, the nearest two are chosen. 
</member>
        <member name="F:EMT_TRANSPARENT_REFLECTION_2_LAYER">
The reflection map should be set as first texture. The
		transparency depends on the alpha value in the vertex colors. A
		texture which will not reflect can be set as second texture.
		Please note that this material type is currently not 100%
		implemented in OpenGL. 
</member>
        <member name="F:EMT_TRANSPARENT_ALPHA_CHANNEL_REF">
If the alpha channel value is greater than 127, a
		pixel is written to the target, otherwise not. This
		material does not use alpha blending and is a lot faster
		than EMT_TRANSPARENT_ALPHA_CHANNEL. It is ideal for drawing
		stuff like leaves of plants, because the borders are not
		blurry but sharp. Only first texture is used. If you are
		using this material with small textures and 3d object, it
		is a good idea to load the texture in 32 bit mode
		(video::IVideoDriver::setTextureCreationFlag()). 
</member>
        <member name="F:EMT_TRANSPARENT_ALPHA_CHANNEL">
The final color is blended together from the destination
		color and the texture color, using the alpha channel value as
		blend factor. Only first texture is used. If you are using
		this material with small textures, it is a good idea to load
		the texture in 32 bit mode
		(video::IVideoDriver::setTextureCreationFlag()). Also, an alpha
		ref is used, which can be manipulated using
		SMaterial::MaterialTypeParam. This value controls how sharp the
		edges become when going from a transparent to a solid spot on
		the texture. 
</member>
        <member name="F:EMT_TRANSPARENT_ADD_COLOR">
Only the first texture is used. The new color is calculated
		by simply adding the source color and the dest color. This
		means if for example a billboard using a texture with black
		background and a red circle on it is drawn with this material,
		the result is that only the red circle will be drawn a little
		bit transparent, and everything which was black is 100%
		transparent and not visible. This material type is useful for
		particle effects. 
</member>
        <member name="F:EMT_REFLECTION_2_LAYER">
The reflection map should be set as first texture. 
</member>
        <member name="F:EMT_SPHERE_MAP">
To make this possible, a texture called 'sphere map' is
		used, which must be set as the first texture. 
</member>
        <member name="F:EMT_DETAIL_MAP">
The first texture is diffuse color map, the second is added
		to this and usually displayed with a bigger scale value so that
		it adds more detail. The detail map is added to the diffuse map
		using ADD_SIGNED, so that it is possible to add and subtract
		color from the diffuse map. For example a value of
		(127,127,127) will not change the appearance of the diffuse map
		at all. Often used for terrain rendering. 
</member>
        <member name="F:EMT_LIGHTMAP_M4">
There should be 2 textures: The first texture layer is a
		diffuse map, the second is a light map. Dynamic light is
		ignored. The texture colors are effectively multiplied by 4
		for brightening. Like known in DirectX as D3DTOP_MODULATE4X. 
</member>
        <member name="F:EMT_LIGHTMAP_M2">
There should be 2 textures: The first texture layer is a
		diffuse map, the second is a light map. Dynamic light is
		ignored. The texture colors are effectively multiplied by 2
		for brightening. Like known in DirectX as D3DTOP_MODULATE2X. 
</member>
        <member name="F:EMT_LIGHTMAP_ADD">
But lightmap and diffuse texture are added instead of modulated. 
</member>
        <member name="F:EMT_LIGHTMAP">
There should be 2 textures: The first texture layer is a
		diffuse map, the second is a light map. Dynamic light is
		ignored. 
</member>
        <member name="F:EMT_SOLID_2_LAYER">
The second is blended onto the first using the alpha value
		of the vertex colors. This material is currently not implemented in OpenGL.

</member>
        <member name="F:EMT_SOLID">
Only first texture is used, which is supposed to be the
		diffuse material. 
</member>
        <member name="M:irr.core.multibyteToWString(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Wrapper around mbstowcs from standard library, but directly writing to Irrlicht string class.
What the function does exactly depends on the LC_CTYPE of the current c locale.
\param destination Wide-character string receiving the converted source
\param source multibyte string
\return The number of wide characters written to destination, not including the eventual terminating null character  or -1 when conversion failed. 
</member>
        <member name="M:irr.core.multibyteToWString(irr.core.string&lt;System.Char,irr.core.irrAllocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,irr.core.irrAllocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Wrapper around mbstowcs from standard library, but directly using Irrlicht string class.
What the function does exactly depends on the LC_CTYPE of the current c locale.
\param destination Wide-character string receiving the converted source
\param source multibyte string
\return The number of wide characters written to destination, not including the eventual terminating null character or -1 when conversion failed 
</member>
        <member name="M:irr.core.wcharToUtf8(System.Char!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64!System.Runtime.CompilerServices.IsConst)">
The resulting string is always NULL-terminated and well-formed.
\param len The size of the output buffer in bytes.

</member>
        <member name="M:irr.core.utf8ToWchar(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Char*,System.UInt64!System.Runtime.CompilerServices.IsConst)">
The resulting string is always NULL-terminated and well-formed.
\param len The size of the output buffer in bytes.

</member>
        <member name="D:irr.core.dimension2di">
There are few cases where negative dimensions make sense. Please consider using
		dimension2du instead. 
</member>
        <member name="T:irr.video.SColorHSL">
The color values for hue, saturation, luminance
	are stored in 32bit floating point variables. Hue is in range [0,360],
	Luminance and Saturation are in percent [0,100]

</member>
        <member name="M:irr.video.SColorf.getInterpolated_quadratic(irr.video.SColorf!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColorf!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\param c1: first color to interpolate with
		\param c2: second color to interpolate with
		\param d: value between 0.0f and 1.0f. 
</member>
        <member name="M:irr.video.SColorf.getInterpolated(irr.video.SColorf!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\param other: Other color
		\param d: value between 0.0f and 1.0f
		\return Interpolated color. 
</member>
        <member name="M:irr.video.SColorf.set(System.Single,System.Single,System.Single,System.Single)">
\param aa: Alpha component. Should be a value between 0.0f meaning
		fully transparent and 1.0f, meaning opaque.
		\param rr: Red color component. Should be a value between 0.0f meaning
		no red and 1.0f, meaning full red.
		\param gg: Green color component. Should be a value between 0.0f meaning
		no green and 1.0f, meaning full green.
		\param bb: Blue color component. Should be a value between 0.0f meaning
		no blue and 1.0f, meaning full blue. 
</member>
        <member name="M:irr.video.SColorf.set(System.Single,System.Single,System.Single)">
\param rr: Red color component. Should be a value between 0.0f meaning
		no red (=black) and 1.0f, meaning full red.
		\param gg: Green color component. Should be a value between 0.0f meaning
		no green (=black) and 1.0f, meaning full green.
		\param bb: Blue color component. Should be a value between 0.0f meaning
		no blue (=black) and 1.0f, meaning full blue. 
</member>
        <member name="M:irr.video.SColorf.#ctor(irr.video.SColor)">
\param c: 32 bit color from which this SColorf class is
		constructed from. 
</member>
        <member name="M:irr.video.SColorf.#ctor(System.Single,System.Single,System.Single,System.Single)">
\param r: Red color component. Should be a value between
		0.0f meaning no red and 1.0f, meaning full red.
		\param g: Green color component. Should be a value between 0.0f
		meaning no green and 1.0f, meaning full green.
		\param b: Blue color component. Should be a value between 0.0f
		meaning no blue and 1.0f, meaning full blue.
		\param a: Alpha color component of the color. The alpha
		component defines how transparent a color should be. Has to be
		a value between 0.0f and 1.0f, 1.0f means not transparent
		(opaque), 0.0f means fully transparent. 
</member>
        <member name="M:irr.video.SColorf.#ctor">
Sets red, green and blue to 0.0f and alpha to 1.0f. 
</member>
        <member name="T:irr.video.SColorf">
The color values for red, green, blue
	and alpha are each stored in a 32 bit floating point variable.
	So all four values may be between 0.0f and 1.0f.
	Another, faster way to define colors is using the class SColor, which
	stores the color values in a single 32 bit integer.

</member>
        <member name="M:irr.video.SColor.getData(System.Void*,irr.video.ECOLOR_FORMAT)">
\param data: target to write the color. Must contain sufficiently large memory to receive the number of bytes neede for format
			\param format: tells the format used to write the color into data

</member>
        <member name="M:irr.video.SColor.setData(System.Void!System.Runtime.CompilerServices.IsConst*,irr.video.ECOLOR_FORMAT)">
\param data: must point to valid memory containing color information in the given format
			\param format: tells the format in which data is available

</member>
        <member name="M:irr.video.SColor.getInterpolated_quadratic(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\param c1: first color to interpolate with
		\param c2: second color to interpolate with
		\param d: value between 0.0f and 1.0f. 
</member>
        <member name="M:irr.video.SColor.getInterpolated(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\param other: Other color
		\param d: value between 0.0f and 1.0f. d=0 returns other, d=1 returns this, values between interpolate.
		\return Interpolated color. 
</member>
        <member name="M:irr.video.SColor.op_Addition(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\param other Color to add to this color
		\return Addition of the two colors, clamped to 0..255 values 
</member>
        <member name="M:irr.video.SColor.op_LessThan(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\return True if this color is smaller than the other one 
</member>
        <member name="M:irr.video.SColor.op_Inequality(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\return True if the colors are different, and false if they are the same. 
</member>
        <member name="M:irr.video.SColor.op_Equality(irr.video.SColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\return True if the colors are the same, and false if not. 
</member>
        <member name="M:irr.video.SColor.set(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Constructs the color from 4 values representing the alpha,
		red, green and blue components of the color. Must be values
		between 0 and 255.
		\param a: Alpha component of the color. The alpha component
		defines how transparent a color should be. Has to be a value
		between 0 and 255. 255 means not transparent (opaque), 0 means
		fully transparent.
		\param r: Sets the red component of the Color. Has to be a
		value between 0 and 255. 0 means no red, 255 means full red.
		\param g: Sets the green component of the Color. Has to be a
		value between 0 and 255. 0 means no green, 255 means full
		green.
		\param b: Sets the blue component of the Color. Has to be a
		value between 0 and 255. 0 means no blue, 255 means full blue. 
</member>
        <member name="M:irr.video.SColor.toOpenGLColor(System.Byte*)">
From ARGB to RGBA in 4 byte components for endian aware
		passing to OpenGL
		\param dest: address where the 4x8 bit OpenGL color is stored. 
</member>
        <member name="M:irr.video.SColor.toA1R5G5B5">
\return 16 bit A1R5G5B5 value of this color. 
</member>
        <member name="M:irr.video.SColor.setBlue(System.UInt32)">
\param b: Has to be a value between 0 and 255.
		0 means no blue, 255 means full blue. 
</member>
        <member name="M:irr.video.SColor.setGreen(System.UInt32)">
\param g: Has to be a value between 0 and 255.
		0 means no green, 255 means full green. 
</member>
        <member name="M:irr.video.SColor.setRed(System.UInt32)">
\param r: Has to be a value between 0 and 255.
		0 means no red, 255 means full red. 
</member>
        <member name="M:irr.video.SColor.setAlpha(System.UInt32)">
The alpha component defines how transparent a color should be.
		\param a The alpha value of the color. 0 is fully transparent, 255 is fully opaque. 
</member>
        <member name="M:irr.video.SColor.getBlue">
\return Value between 0 and 255, specifying how blue the color is.
		0 means no blue, 255 means full blue. 
</member>
        <member name="M:irr.video.SColor.getGreen">
\return Value between 0 and 255, specifying how green the color is.
		0 means no green, 255 means full green. 
</member>
        <member name="M:irr.video.SColor.getRed">
\return Value between 0 and 255, specifying how red the color is.
		0 means no red, 255 means full red. 
</member>
        <member name="M:irr.video.SColor.getAlpha">
The alpha component defines how opaque a color is.
		\return The alpha value of the color. 0 is fully transparent, 255 is fully opaque. 
</member>
        <member name="M:irr.video.SColor.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Must be values between 0 and 255. 
</member>
        <member name="M:irr.video.SColor.#ctor">
The color value is not initialized to save time. 
</member>
        <member name="T:irr.video.SColor">
The color values for alpha, red, green, and blue are
	stored in a single u32. So all four values may be between 0 and 255.
	Alpha in Irrlicht is opacity, so 0 is fully transparent, 255 is fully opaque (solid).
	This class is used by most parts of the Irrlicht Engine
	to specify a color. Another way is using the class SColorf, which
	stores the color values in 4 floats.
	This class must consist of only one u32 and must not use virtual functions.

</member>
        <member name="M:irr.video.getBlue(System.UInt16)">
Shift left by 3 to get 8 bit value. 
</member>
        <member name="M:irr.video.getGreen(System.UInt16)">
Shift left by 3 to get 8 bit value. 
</member>
        <member name="M:irr.video.getRed(System.UInt16)">
Shift left by 3 to get 8 bit value. 
</member>
        <member name="M:irr.video.getAlpha(System.UInt16)">
In Irrlicht, alpha refers to opacity.
	\return The alpha value of the color. 0 is transparent, 1 is opaque. 
</member>
        <member name="M:irr.video.A1R5G5B5toA8R8G8B8(System.UInt16)">
build a nicer 32bit Color by extending dest lower bits with source high bits. 
</member>
        <member name="T:irr.video.ECOLOR_FORMAT">
A color format specifies how color information is stored.
	    NOTE: Byte order in memory is usually flipped (it's probably correct in bitmap files, but flipped on reading).
	    So for example ECF_A8R8G8B8 is BGRA in memory same as in DX9's D3DFMT_A8R8G8B8 format.

</member>
        <member name="F:ECF_D16">
Depth and stencil formats. 
</member>
        <member name="F:ECF_R8">
Unsigned normalized integer formats. 
</member>
        <member name="F:ECF_R16F">
The following formats may only be used for render target textures. 
Floating point formats. 
</member>
        <member name="F:ECF_DXT1">
Compressed image formats. *
</member>
        <member name="F:ECF_A1R5G5B5">
It is thus preferred by all other irrlicht engine video drivers.
		There are 5 bits for every color component, and a single bit is left
		for alpha information. 
</member>
        <member name="M:irr.IReferenceCounted.setDebugName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
The Debugname may only be set and changed by the object
		itself. This method should only be used in Debug mode.
		\param newName: New debug name to set. 
</member>
        <member name="M:irr.IReferenceCounted.getDebugName">
The Debugname may only be set and changed by the object
		itself. This method should only be used in Debug mode.
		\return Returns a string, previously set by setDebugName(); 
</member>
        <member name="M:irr.IReferenceCounted.getReferenceCount">
\return Current value of the reference counter. 
</member>
        <member name="M:irr.core.degToRad(System.Double)">
Provided as it can be clearer to write degToRad(X) than DEGTORAD * X
	\param degrees The degrees value to convert to radians.

</member>
        <member name="M:irr.core.degToRad(System.Single)">
Provided as it can be clearer to write degToRad(X) than DEGTORAD * X
	\param degrees The degrees value to convert to radians.

</member>
        <member name="M:irr.core.radToDeg(System.Double)">
Provided as it can be clearer to write radToDeg(X) than RADTODEG * X
	\param radians The radians value to convert to degrees.

</member>
        <member name="M:irr.core.radToDeg(System.Single)">
Provided as it can be clearer to write radToDeg(X) than RADTODEG * X
	\param radians The radians value to convert to degrees.

</member>
        <member name="D:irr.fschar_t">
Should the wide character version of the FileSystem be used it is a
16 bit character variable. Used for Unicode Filesystem and Unicode strings.
Else it is a 8 bit character variable. Used for ansi Filesystem and non-unicode
strings

</member>
        <member name="D:irr.f64">
This is a typedef for double, it ensures portability of the engine. 
</member>
        <member name="D:irr.f32">
This is a typedef for float, it ensures portability of the engine. 
</member>
        <member name="D:irr.s64">
This is a typedef for 64bit int, it ensures portability of the engine. 
</member>
        <member name="D:irr.u64">
This is a typedef for 64bit uint, it ensures portability of the engine. 
</member>
        <member name="D:irr.s32">
This is a typedef for signed int, it ensures portability of the engine. 
</member>
        <member name="D:irr.u32">
This is a typedef for unsigned int, it ensures portability of the engine. 
</member>
        <member name="D:irr.s16">
This is a typedef for signed short, it ensures portability of the engine. 
</member>
        <member name="D:irr.u16">
This is a typedef for unsigned short, it ensures portability of the engine. 
</member>
        <member name="D:irr.c8">
This is a typedef for char, it ensures portability of the engine. 
</member>
        <member name="D:irr.s8">
This is a typedef for signed char, it ensures portability of the engine. 
</member>
        <member name="D:irr.u8">
This is a typedef for unsigned char, it ensures portability of the engine. 
</member>
        <member name="P:IrrlichtLime.Video.Light.Type">
            <summary>
Type of the light.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.SpecularColor">
            <summary>
Specular color emitted by the light.
For details how to use specular highlights, see <c>Material.Shininess</c>.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.Radius">
            <summary>
Radius of the light.
Everything within this radius will be lighted.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.Position">
            <summary>
Position of the light.
If Type is <see cref="F:IrrlichtLime.Video.LightType.Directional" />, it is ignored.
Changed via light scene node's position.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.OuterCone">
            <summary>
The angle of the spot's outer cone.
Ignored for other lights.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.InnerCone">
            <summary>
The angle of the spot's inner cone.
Ignored for other lights.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.Falloff">
            <summary>
The light strength's decrease between Outer and Inner cone.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.Direction">
            <summary>
Direction of the light.
If Type is <see cref="F:IrrlichtLime.Video.LightType.Point" />, it is ignored.
Changed via light scene node's rotation.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.DiffuseColor">
            <summary>
Diffuse color emitted by the light.
This is the primary color you want to set.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.CastShadows">
            <summary>
Does the light cast shadows?
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.Attenuation">
            <summary>
Attenuation factors (constant, linear, quadratic).
Changes the light strength fading over distance.
Can also be altered by setting the Radius, Attenuation will change to (0,1.0f/Radius,0).
Can be overridden after radius was set.
</summary>
        </member>
        <member name="P:IrrlichtLime.Video.Light.AmbientColor">
            <summary>
Ambient color emitted by the light.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.Light.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="T:IrrlichtLime.Video.Light">
            <summary>
Describes a dynamic point light.
Irrlicht supports point lights, spot lights, and directional lights.
</summary>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.SetRenderTarget(IrrlichtLime.Video.Texture)">
            <summary>
Sets a new render target.
This will only work if the driver supports the <see cref="F:IrrlichtLime.Video.VideoDriverFeature.RenderToTarget" />, which can be queried with <c>QueryFeature()</c>.
Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target
at the same time. It is usually only possible to render into a texture between the <c>BeginScene()</c> and <c>EndScene()</c> calls.
</summary>
            <param name="texture">New render target. Must be a texture created with <c>AddRenderTargetTexture()</c>.
If set to <c>null</c>, it sets the previous render target which was set before the last method call.</param>
            <returns>True if successful and false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.SetRenderTarget(IrrlichtLime.Video.Texture,IrrlichtLime.Video.ClearBufferFlag)">
            <summary>
Sets a new render target.
This will only work if the driver supports the <see cref="F:IrrlichtLime.Video.VideoDriverFeature.RenderToTarget" />, which can be queried with <c>QueryFeature()</c>.
Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target
at the same time. It is usually only possible to render into a texture between the <c>BeginScene()</c> and <c>EndScene()</c> calls.
</summary>
            <param name="texture">New render target. Must be a texture created with <c>AddRenderTargetTexture()</c>.
If set to <c>null</c>, it sets the previous render target which was set before the last method call.</param>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <returns>True if successful and false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.SetRenderTarget(IrrlichtLime.Video.Texture,IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color)">
            <summary>
Sets a new render target.
This will only work if the driver supports the <see cref="F:IrrlichtLime.Video.VideoDriverFeature.RenderToTarget" />, which can be queried with <c>QueryFeature()</c>.
Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target
at the same time. It is usually only possible to render into a texture between the <c>BeginScene()</c> and <c>EndScene()</c> calls.
</summary>
            <param name="texture">New render target. Must be a texture created with <c>AddRenderTargetTexture()</c>.
If set to <c>null</c>, it sets the previous render target which was set before the last method call.</param>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is black.</param>
            <returns>True if successful and false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.SetRenderTarget(IrrlichtLime.Video.Texture,IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color,System.Single)">
            <summary>
Sets a new render target.
This will only work if the driver supports the <see cref="F:IrrlichtLime.Video.VideoDriverFeature.RenderToTarget" />, which can be queried with <c>QueryFeature()</c>.
Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target
at the same time. It is usually only possible to render into a texture between the <c>BeginScene()</c> and <c>EndScene()</c> calls.
</summary>
            <param name="texture">New render target. Must be a texture created with <c>AddRenderTargetTexture()</c>.
If set to <c>null</c>, it sets the previous render target which was set before the last method call.</param>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is black.</param>
            <param name="clearDepth">The clear value for the depth buffer. Default is 1.f.</param>
            <returns>True if successful and false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.SetRenderTarget(IrrlichtLime.Video.Texture,IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color,System.Single,System.Byte)">
            <summary>
Sets a new render target.
This will only work if the driver supports the <see cref="F:IrrlichtLime.Video.VideoDriverFeature.RenderToTarget" />, which can be queried with <c>QueryFeature()</c>.
Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target
at the same time. It is usually only possible to render into a texture between the <c>BeginScene()</c> and <c>EndScene()</c> calls.
</summary>
            <param name="texture">New render target. Must be a texture created with <c>AddRenderTargetTexture()</c>.
If set to <c>null</c>, it sets the previous render target which was set before the last method call.</param>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is black.</param>
            <param name="clearDepth">The clear value for the depth buffer. Default is 1.f.</param>
            <param name="clearStencil">The clear value for the stencil buffer. Default is 0.</param>
            <returns>True if successful and false if not.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.BeginScene">
            <summary>
Applications must call this method before performing any rendering. This method can clear the back- and the z-buffer.
</summary>
            <returns>False if failed.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.BeginScene(IrrlichtLime.Video.ClearBufferFlag)">
            <summary>
Applications must call this method before performing any rendering. This method can clear the back- and the z-buffer.
</summary>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <returns>False if failed.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.BeginScene(IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color)">
            <summary>
Applications must call this method before performing any rendering. This method can clear the back- and the z-buffer.
</summary>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is null (black).</param>
            <returns>False if failed.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.BeginScene(IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color,System.Single)">
            <summary>
Applications must call this method before performing any rendering. This method can clear the back- and the z-buffer.
</summary>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is null (black).</param>
            <param name="clearDepth">The clear value for the depth buffer. Default is 1.f.</param>
            <returns>False if failed.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.BeginScene(IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color,System.Single,System.Byte)">
            <summary>
Applications must call this method before performing any rendering. This method can clear the back- and the z-buffer.
</summary>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is null (black).</param>
            <param name="clearDepth">The clear value for the depth buffer. Default is 1.f.</param>
            <param name="clearStencil">The clear value for the stencil buffer. Default is 0.</param>
            <returns>False if failed.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.BeginScene(IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color,System.Single,System.Byte,IrrlichtLime.Video.ExposedVideoData)">
            <summary>
Applications must call this method before performing any rendering. This method can clear the back- and the z-buffer.
</summary>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is null (black).</param>
            <param name="clearDepth">The clear value for the depth buffer. Default is 1.f.</param>
            <param name="clearStencil">The clear value for the stencil buffer. Default is 0.</param>
            <param name="videoData">Handle of another window, if you want the bitmap to be displayed on another window.
If this is an empty element, everything will be displayed in the default window.
Note: This feature is not fully implemented for all devices. Default is null.</param>
            <returns>False if failed.</returns>
        </member>
        <member name="M:IrrlichtLime.Video.VideoDriver.BeginScene(IrrlichtLime.Video.ClearBufferFlag,IrrlichtLime.Video.Color,System.Single,System.Byte,IrrlichtLime.Video.ExposedVideoData,IrrlichtLime.Core.Recti)">
            <summary>
Applications must call this method before performing any rendering. This method can clear the back- and the z-buffer.
</summary>
            <param name="clearFlag">A combination of the <see cref="T:IrrlichtLime.Video.ClearBufferFlag" /> bit-flags. Default is <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Color" /> | <see cref="F:IrrlichtLime.Video.ClearBufferFlag.Depth" />.</param>
            <param name="clearColor">The clear color for the color buffer. Default is null (black).</param>
            <param name="clearDepth">The clear value for the depth buffer. Default is 1.f.</param>
            <param name="clearStencil">The clear value for the stencil buffer. Default is 0.</param>
            <param name="videoData">Handle of another window, if you want the bitmap to be displayed on another window.
If this is an empty element, everything will be displayed in the default window.
Note: This feature is not fully implemented for all devices. Default is null.</param>
            <param name="sourceRect">Rectangle defining the source rectangle of the area to be presented.
Note: not implemented in all devices. Default is null (present everything).</param>
            <returns>False if failed.</returns>
        </member>
        <member name="P:IrrlichtLime.Logger.LogLevel">
            <summary>
Current log level.
With this value, texts which are sent to the logger are filtered out.
For example setting this value to <see cref="F:IrrlichtLime.LogLevel.Warning" />, only warnings and errors are printed out.
Setting it to <see cref="F:IrrlichtLime.LogLevel.Information" />, which is the default setting, warnings, errors and informational texts are printed out.
</summary>
        </member>
        <member name="M:IrrlichtLime.Logger.Log(System.String)">
            <summary>
Prints out a text into the log.
</summary>
            <param name="text">Text to print out.</param>
        </member>
        <member name="M:IrrlichtLime.Logger.Log(System.String,IrrlichtLime.LogLevel)">
            <summary>
Prints out a text into the log.
</summary>
            <param name="text">Text to print out.</param>
            <param name="level">Log level of the text. Default is <see cref="F:IrrlichtLime.LogLevel.Information" />.</param>
        </member>
        <member name="M:IrrlichtLime.Logger.Log(System.String,System.String,IrrlichtLime.LogLevel)">
            <summary>
Prints out a text into the log.
</summary>
            <param name="text">Text to print out.</param>
            <param name="hint">Additional info. This string is added after a " :" to the string.</param>
            <param name="level">Log level of the text. Default is <see cref="F:IrrlichtLime.LogLevel.Information" />.</param>
        </member>
        <member name="T:IrrlichtLime.Logger">
            <summary>
Logging messages, warnings and errors.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.PovHat">
            <summary>
An indication of whether the joystick has a POV hat.
A Windows device will identify the presence or absence of the POV hat.
A Linux device cannot, and will always return <see cref="F:IrrlichtLime.JoystickInfo.PovHatPresence.Unknown" />.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.Name">
            <summary>
The name that the joystick uses to identify itself.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.Joystick">
            <summary>
The ID of the joystick.
This is an internal Irrlicht index; it does not map directly to any particular hardware joystick.
It corresponds to the <c>JoystickEvent.Joystick</c> value.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.ButtonCount">
            <summary>
The number of buttons that the joystick has.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.AxisCount">
            <summary>
The number of axes that the joystick has, i.e. X, Y, Z, R, U, V.
Note: with a Linux device, the POV hat (if any) will use two axes. These will be included in this count.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.PovHatPresence.Unknown">
            <summary>
The presence or absence of a hat cannot be determined.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.PovHatPresence.Absent">
            <summary>
A hat is definitely not present.
</summary>
        </member>
        <member name="F:IrrlichtLime.JoystickInfo.PovHatPresence.Present">
            <summary>
A hat is definitely present.
</summary>
        </member>
        <member name="T:IrrlichtLime.JoystickInfo.PovHatPresence">
            <summary>
An indication of whether the joystick has a POV hat.
</summary>
        </member>
        <member name="T:IrrlichtLime.JoystickInfo">
            <summary>
Information on a joystick, returned from <c>device.ActivateJoysticks()</c>.
</summary>
        </member>
        <member name="M:IrrlichtLime.Scene.Mesh.SetDirty">
            <summary>Flag the meshbuffer as changed, reloads hardware buffers.
This method has to be called every time the vertices or indices have changed. Otherwise, changes won't be updated on the GPU in the next render cycle.</summary>
        </member>
        <member name="M:IrrlichtLime.Scene.Mesh.SetDirty(IrrlichtLime.Scene.HardwareBufferType)">
            <summary>Flag the meshbuffer as changed, reloads hardware buffers.
This method has to be called every time the vertices or indices have changed. Otherwise, changes won't be updated on the GPU in the next render cycle.</summary>
            <param name="buffer">Type of buffer to flag as changed. Default: <see cref="F:IrrlichtLime.Scene.HardwareBufferType.VertexAndIndex" />.</param>
        </member>
        <!-- Discarding badly formed XML document comment for member 'T:_exception'. -->
        <!-- Discarding badly formed XML document comment for member 'T:irr.IReferenceCounted'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.IReferenceCounted.grab'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.IReferenceCounted.drop'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ESNT_CAMERA_MAYA'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ESNT_CAMERA_FPS'. -->
        <!-- Discarding badly formed XML document comment for member 'T:irr.io.IXMLBase'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.io.IFileSystem.changeWorkingDirectoryTo(irr.core.string<System.Char,irr.core.irrAllocator<System.Char>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:irr.video.SExposedVideoData.SD3D9.HWnd'. -->
        <!-- Discarding badly formed XML document comment for member 'F:irr.video.SExposedVideoData.SOpenGLWin32.HDc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:irr.video.SExposedVideoData.SOpenGLWin32.HRc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:irr.video.SExposedVideoData.SOpenGLWin32.HWnd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.video.IVideoDriver.setRenderTarget(irr.video.ITexture*,System.UInt16,irr.video.SColor,System.Single,System.Byte)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:irr.SIrrlichtCreationParameters.WindowId'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ECPB_X11_CACHE_UPDATES'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.gui.IGUIElement.setRelativePositionProportional(irr.core.rect<System.Single>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:irr.gui.IGUISpriteBank'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.gui.IGUIWindow.getClientRect'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.video.IMaterialRendererServices.setVertexShaderConstant(System.Int32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.IColladaMeshWriterProperties.getTransparency(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.IColladaMeshWriterProperties.getReflectivity(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.IColladaMeshWriterProperties.getIndexOfRefraction(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:irr.scene.EParticleBehavior'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.IrrlichtDevice.clearSystemMessages'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.ISceneManager.getMesh(irr.core.string<System.Char,irr.core.irrAllocator<System.Char>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.string<System.Char,irr.core.irrAllocator<System.Char>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.ISceneManager.createCollisionResponseAnimator(irr.scene.ITriangleSelector*,irr.scene.ISceneNode*,irr.core.vector3d<System.Single>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d<System.Single>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,irr.core.vector3d<System.Single>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.ISceneNodeAnimatorCollisionResponse.setEllipsoidRadius(irr.core.vector3d<System.Single>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.video.IShaderConstantSetCallBack.OnSetMaterial(irr.video.SMaterial!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.video.IShaderConstantSetCallBack.OnSetConstants(irr.video.IMaterialRendererServices*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.ITerrainSceneNode.getCurrentLODOfPatches(irr.core.array<System.Int32,irr.core.irrAllocator<System.Int32>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:irr.scene.ITerrainSceneNode.setFixedBorderLOD(System.Int32)'. -->
    </members>
</doc>